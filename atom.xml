<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>滴水成涓</title>
  
  <subtitle>每天进步一点点</subtitle>
  <link href="https://guozhe001.github.io/atom.xml" rel="self"/>
  
  <link href="https://guozhe001.github.io/"/>
  <updated>2021-01-25T11:32:58.842Z</updated>
  <id>https://guozhe001.github.io/</id>
  
  <author>
    <name>guozhe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ClientIdentity接口练习</title>
    <link href="https://guozhe001.github.io/2021/01/25/blockchain/fabric/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6API%E5%AD%A6%E4%B9%A0/ClientIdentity%E6%8E%A5%E5%8F%A3%E7%BB%83%E4%B9%A0/"/>
    <id>https://guozhe001.github.io/2021/01/25/blockchain/fabric/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6API%E5%AD%A6%E4%B9%A0/ClientIdentity%E6%8E%A5%E5%8F%A3%E7%BB%83%E4%B9%A0/</id>
    <published>2021-01-25T02:59:54.130Z</published>
    <updated>2021-01-25T11:32:58.842Z</updated>
    
    <content type="html"><![CDATA[<p>学习<code>/github.com/hyperledger/fabric-chaincode-go/pkg/cid/interfaces.go</code>中的ClientIdentity接口，源码如下，比较简单：</p><h3 id="源码">源码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientIdentity represents information about the identity that submitted the</span></span><br><span class="line"><span class="comment">// transaction</span></span><br><span class="line"><span class="comment">// ClientIdentity表示提交交易的身份的信息</span></span><br><span class="line"><span class="keyword">type</span> ClientIdentity <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// GetID returns the ID associated with the invoking identity.  This ID</span></span><br><span class="line">   <span class="comment">// is guaranteed to be unique within the MSP.</span></span><br><span class="line">   <span class="comment">// 返回与调用者身份关联的ID。该ID在MSP中保证是唯一的。</span></span><br><span class="line">   GetID() (<span class="keyword">string</span>, error)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Return the MSP ID of the client</span></span><br><span class="line">   <span class="comment">// 获取客户端的MSP的ID</span></span><br><span class="line">   GetMSPID() (<span class="keyword">string</span>, error)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// GetAttributeValue returns the value of the client's attribute named `attrName`.</span></span><br><span class="line">   <span class="comment">// If the client possesses the attribute, `found` is true and `value` equals the</span></span><br><span class="line">   <span class="comment">// value of the attribute.</span></span><br><span class="line">   <span class="comment">// If the client does not possess the attribute, `found` is false and `value`</span></span><br><span class="line">   <span class="comment">// equals "".</span></span><br><span class="line">   <span class="comment">// 返回名为`attrName`的客户端的属性信息</span></span><br><span class="line">   <span class="comment">// 如果客户端有这个属性，返回值`found`等于true并且返回值`value`等于这个属性。</span></span><br><span class="line">   <span class="comment">// 如果这个客户端不拥有这个属性，`found`等于false并且`value`等于""。</span></span><br><span class="line">   GetAttributeValue(attrName <span class="keyword">string</span>) (value <span class="keyword">string</span>, found <span class="keyword">bool</span>, err error)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// AssertAttributeValue verifies that the client has the attribute named `attrName`</span></span><br><span class="line">   <span class="comment">// with a value of `attrValue`; otherwise, an error is returned.</span></span><br><span class="line">   <span class="comment">// 验证客户端是否有名为`attrName`的属性，并且值为`attrValue`；如果没有或者值不一致则返回一个error</span></span><br><span class="line">   AssertAttributeValue(attrName, attrValue <span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">   <span class="comment">// GetX509Certificate returns the X509 certificate associated with the client,</span></span><br><span class="line">   <span class="comment">// or nil if it was not identified by an X509 certificate.</span></span><br><span class="line">   <span class="comment">// 返回与客户端关联的X509证书，如果没有被X509证书标识，则返回nil。</span></span><br><span class="line">   GetX509Certificate() (*x509.Certificate, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试代码：">测试代码：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-contract-api-go/contractapi"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientIdentityPractice ClientIdentity接口提供的方法练习</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">ClientIdentityPractice</span><span class="params">(ctx contractapi.TransactionContextInterface)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"ClientIdentityPractice==================start====================="</span>)</span><br><span class="line">clientIdentity := ctx.GetClientIdentity()</span><br><span class="line">id, err := clientIdentity.GetID()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"clientIdentity.GetID()=%s"</span>, id)</span><br><span class="line">mspid, err := clientIdentity.GetMSPID()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"clientIdentity.GetMSPID()=%s"</span>, mspid)</span><br><span class="line">certificate, err := clientIdentity.GetX509Certificate()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"clientIdentity.GetX509Certificate()=%#v"</span>, certificate)</span><br><span class="line">value, found, err := clientIdentity.GetAttributeValue(<span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> found &#123;</span><br><span class="line">log.Printf(<span class="string">"clientIdentity.GetAttributeValue(\"test\")=%s"</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := clientIdentity.AssertAttributeValue(<span class="string">"test"</span>, <span class="string">"hello"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"clientIdentity.AssertAttributeValue(\"test\", \"hello\") error!"</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">"ClientIdentityPractice===================end======================"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试日志">测试日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2021&#x2F;01&#x2F;25 03:42:33 ClientIdentityPractice&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2021&#x2F;01&#x2F;25 03:42:33 clientIdentity.GetID()&#x3D;eDUwOTo6Q049QWRtaW5AczIuc3VwcGx5LmNvbSxMPVNhbiBGcmFuY2lzY28sU1Q9Q2FsaWZvcm5pYSxDPVVTOjpDTj1jYS5zMi5zdXBwbHkuY29tLE89czIuc3VwcGx5LmNvbSxMPVNhbiBGcmFuY2lzY28sU1Q9Q2FsaWZvcm5pYSxDPVVT</span><br><span class="line">2021&#x2F;01&#x2F;25 03:42:33 clientIdentity.GetMSPID()&#x3D;GylSOrg2MSP</span><br><span class="line">2021&#x2F;01&#x2F;25 03:42:33 clientIdentity.GetX509Certificate()&#x3D;&amp;x509.Certificate&#123;Raw:[]uint8&#123;0x30, 0x82, 0x2, 0x11, 0x30, 0x82, 0x1, 0xb7, 0xa0, 0x3, 0x2, 0x1, 0x2, 0x2, 0x11, 0x0, 0x9c, 0x36, 0x61, 0x42, 0xa4, 0x9b, 0x22, 0xae, 0xb0, 0x61, 0xe6, 0xdf, 0x70, 0xfb, 0x2e, 0x19, 0x30, 0xa, 0x6, 0x8, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x4, 0x3, 0x2, 0x30, 0x6d, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x6, 0x3, 0x55, 0x4, 0x8, 0x13, 0xa, 0x43, 0x61, 0x6c, 0x69, 0x66, 0x6f, 0x72, 0x6e, 0x69, 0x61, 0x31, 0x16, 0x30, 0x14, 0x6, 0x3, 0x55, 0x4, 0x7, 0x13, 0xd, 0x53, 0x61, 0x6e, 0x20, 0x46, 0x72, 0x61, 0x6e, 0x63, 0x69, 0x73, 0x63, 0x6f, 0x31, 0x16, 0x30, 0x14, 0x6, 0x3, 0x55, 0x4, 0xa, 0x13, 0xd, 0x73, 0x32, 0x2e, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x31, 0x19, 0x30, 0x17, 0x6, 0x3, 0x55, 0x4, 0x3, 0x13, 0x10, 0x63, 0x61, 0x2e, 0x73, 0x32, 0x2e, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x1e, 0x17, 0xd, 0x32, 0x31, 0x30, 0x31, 0x30, 0x37, 0x30, 0x38, 0x33, 0x31, 0x30, 0x30, 0x5a, 0x17, 0xd, 0x33, 0x31, 0x30, 0x31, 0x30, 0x35, 0x30, 0x38, 0x33, 0x31, 0x30, 0x30, 0x5a, 0x30, 0x58, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x6, 0x3, 0x55, 0x4, 0x8, 0x13, 0xa, 0x43, 0x61, 0x6c, 0x69, 0x66, 0x6f, 0x72, 0x6e, 0x69, 0x61, 0x31, 0x16, 0x30, 0x14, 0x6, 0x3, 0x55, 0x4, 0x7, 0x13, 0xd, 0x53, 0x61, 0x6e, 0x20, 0x46, 0x72, 0x61, 0x6e, 0x63, 0x69, 0x73, 0x63, 0x6f, 0x31, 0x1c, 0x30, 0x1a, 0x6, 0x3, 0x55, 0x4, 0x3, 0xc, 0x13, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x40, 0x73, 0x32, 0x2e, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x59, 0x30, 0x13, 0x6, 0x7, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x2, 0x1, 0x6, 0x8, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x3, 0x1, 0x7, 0x3, 0x42, 0x0, 0x4, 0x9e, 0x80, 0x9f, 0x9b, 0xc7, 0x9a, 0xe8, 0x35, 0x60, 0x12, 0x14, 0x5c, 0xab, 0x83, 0xe7, 0x46, 0x49, 0xef, 0xd4, 0xe2, 0xc0, 0x39, 0x16, 0xe6, 0xe1, 0x2b, 0xd9, 0x99, 0x17, 0x53, 0x91, 0x26, 0x5f, 0x5, 0x65, 0xc7, 0x0, 0x8e, 0x2a, 0x97, 0xea, 0x28, 0xea, 0xf5, 0x5d, 0xd9, 0x34, 0xd, 0x63, 0x25, 0x1, 0x3, 0xd0, 0x23, 0x17, 0x97, 0x92, 0xd7, 0x55, 0x4, 0x9c, 0x45, 0x73, 0x82, 0xa3, 0x4d, 0x30, 0x4b, 0x30, 0xe, 0x6, 0x3, 0x55, 0x1d, 0xf, 0x1, 0x1, 0xff, 0x4, 0x4, 0x3, 0x2, 0x7, 0x80, 0x30, 0xc, 0x6, 0x3, 0x55, 0x1d, 0x13, 0x1, 0x1, 0xff, 0x4, 0x2, 0x30, 0x0, 0x30, 0x2b, 0x6, 0x3, 0x55, 0x1d, 0x23, 0x4, 0x24, 0x30, 0x22, 0x80, 0x20, 0x63, 0xbd, 0xab, 0x9a, 0x9c, 0xa7, 0x4f, 0x3d, 0x8b, 0xb6, 0xc3, 0xab, 0xc, 0xb1, 0x45, 0x87, 0x60, 0x69, 0x7e, 0xb9, 0x6, 0xfb, 0x38, 0x5f, 0x9c, 0x2, 0xb1, 0x75, 0x9b, 0xc6, 0x3d, 0xfb, 0x30, 0xa, 0x6, 0x8, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x4, 0x3, 0x2, 0x3, 0x48, 0x0, 0x30, 0x45, 0x2, 0x21, 0x0, 0x91, 0x4, 0x2f, 0xee, 0x17, 0xca, 0x28, 0x68, 0xb4, 0x33, 0x48, 0x3a, 0x3a, 0x7b, 0x9f, 0xb8, 0x51, 0xb0, 0x6a, 0x8d, 0x28, 0xb9, 0x31, 0x4c, 0xb7, 0x21, 0x87, 0xd5, 0xac, 0xce, 0x6d, 0x1d, 0x2, 0x20, 0x68, 0x61, 0xca, 0x5d, 0xc2, 0x99, 0x63, 0xba, 0xb4, 0x4f, 0x1b, 0x3a, 0x2e, 0xc6, 0xed, 0x6b, 0x25, 0xba, 0x91, 0x63, 0xce, 0x1, 0xe7, 0xba, 0x67, 0x55, 0xbc, 0xb6, 0x8a, 0x76, 0x54, 0x37&#125;, RawTBSCertificate:[]uint8&#123;0x30, 0x82, 0x1, 0xb7, 0xa0, 0x3, 0x2, 0x1, 0x2, 0x2, 0x11, 0x0, 0x9c, 0x36, 0x61, 0x42, 0xa4, 0x9b, 0x22, 0xae, 0xb0, 0x61, 0xe6, 0xdf, 0x70, 0xfb, 0x2e, 0x19, 0x30, 0xa, 0x6, 0x8, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x4, 0x3, 0x2, 0x30, 0x6d, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x6, 0x3, 0x55, 0x4, 0x8, 0x13, 0xa, 0x43, 0x61, 0x6c, 0x69, 0x66, 0x6f, 0x72, 0x6e, 0x69, 0x61, 0x31, 0x16, 0x30, 0x14, 0x6, 0x3, 0x55, 0x4, 0x7, 0x13, 0xd, 0x53, 0x61, 0x6e, 0x20, 0x46, 0x72, 0x61, 0x6e, 0x63, 0x69, 0x73, 0x63, 0x6f, 0x31, 0x16, 0x30, 0x14, 0x6, 0x3, 0x55, 0x4, 0xa, 0x13, 0xd, 0x73, 0x32, 0x2e, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x31, 0x19, 0x30, 0x17, 0x6, 0x3, 0x55, 0x4, 0x3, 0x13, 0x10, 0x63, 0x61, 0x2e, 0x73, 0x32, 0x2e, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x1e, 0x17, 0xd, 0x32, 0x31, 0x30, 0x31, 0x30, 0x37, 0x30, 0x38, 0x33, 0x31, 0x30, 0x30, 0x5a, 0x17, 0xd, 0x33, 0x31, 0x30, 0x31, 0x30, 0x35, 0x30, 0x38, 0x33, 0x31, 0x30, 0x30, 0x5a, 0x30, 0x58, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x6, 0x3, 0x55, 0x4, 0x8, 0x13, 0xa, 0x43, 0x61, 0x6c, 0x69, 0x66, 0x6f, 0x72, 0x6e, 0x69, 0x61, 0x31, 0x16, 0x30, 0x14, 0x6, 0x3, 0x55, 0x4, 0x7, 0x13, 0xd, 0x53, 0x61, 0x6e, 0x20, 0x46, 0x72, 0x61, 0x6e, 0x63, 0x69, 0x73, 0x63, 0x6f, 0x31, 0x1c, 0x30, 0x1a, 0x6, 0x3, 0x55, 0x4, 0x3, 0xc, 0x13, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x40, 0x73, 0x32, 0x2e, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x59, 0x30, 0x13, 0x6, 0x7, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x2, 0x1, 0x6, 0x8, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x3, 0x1, 0x7, 0x3, 0x42, 0x0, 0x4, 0x9e, 0x80, 0x9f, 0x9b, 0xc7, 0x9a, 0xe8, 0x35, 0x60, 0x12, 0x14, 0x5c, 0xab, 0x83, 0xe7, 0x46, 0x49, 0xef, 0xd4, 0xe2, 0xc0, 0x39, 0x16, 0xe6, 0xe1, 0x2b, 0xd9, 0x99, 0x17, 0x53, 0x91, 0x26, 0x5f, 0x5, 0x65, 0xc7, 0x0, 0x8e, 0x2a, 0x97, 0xea, 0x28, 0xea, 0xf5, 0x5d, 0xd9, 0x34, 0xd, 0x63, 0x25, 0x1, 0x3, 0xd0, 0x23, 0x17, 0x97, 0x92, 0xd7, 0x55, 0x4, 0x9c, 0x45, 0x73, 0x82, 0xa3, 0x4d, 0x30, 0x4b, 0x30, 0xe, 0x6, 0x3, 0x55, 0x1d, 0xf, 0x1, 0x1, 0xff, 0x4, 0x4, 0x3, 0x2, 0x7, 0x80, 0x30, 0xc, 0x6, 0x3, 0x55, 0x1d, 0x13, 0x1, 0x1, 0xff, 0x4, 0x2, 0x30, 0x0, 0x30, 0x2b, 0x6, 0x3, 0x55, 0x1d, 0x23, 0x4, 0x24, 0x30, 0x22, 0x80, 0x20, 0x63, 0xbd, 0xab, 0x9a, 0x9c, 0xa7, 0x4f, 0x3d, 0x8b, 0xb6, 0xc3, 0xab, 0xc, 0xb1, 0x45, 0x87, 0x60, 0x69, 0x7e, 0xb9, 0x6, 0xfb, 0x38, 0x5f, 0x9c, 0x2, 0xb1, 0x75, 0x9b, 0xc6, 0x3d, 0xfb&#125;, RawSubjectPublicKeyInfo:[]uint8&#123;0x30, 0x59, 0x30, 0x13, 0x6, 0x7, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x2, 0x1, 0x6, 0x8, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x3, 0x1, 0x7, 0x3, 0x42, 0x0, 0x4, 0x9e, 0x80, 0x9f, 0x9b, 0xc7, 0x9a, 0xe8, 0x35, 0x60, 0x12, 0x14, 0x5c, 0xab, 0x83, 0xe7, 0x46, 0x49, 0xef, 0xd4, 0xe2, 0xc0, 0x39, 0x16, 0xe6, 0xe1, 0x2b, 0xd9, 0x99, 0x17, 0x53, 0x91, 0x26, 0x5f, 0x5, 0x65, 0xc7, 0x0, 0x8e, 0x2a, 0x97, 0xea, 0x28, 0xea, 0xf5, 0x5d, 0xd9, 0x34, 0xd, 0x63, 0x25, 0x1, 0x3, 0xd0, 0x23, 0x17, 0x97, 0x92, 0xd7, 0x55, 0x4, 0x9c, 0x45, 0x73, 0x82&#125;, RawSubject:[]uint8&#123;0x30, 0x58, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x6, 0x3, 0x55, 0x4, 0x8, 0x13, 0xa, 0x43, 0x61, 0x6c, 0x69, 0x66, 0x6f, 0x72, 0x6e, 0x69, 0x61, 0x31, 0x16, 0x30, 0x14, 0x6, 0x3, 0x55, 0x4, 0x7, 0x13, 0xd, 0x53, 0x61, 0x6e, 0x20, 0x46, 0x72, 0x61, 0x6e, 0x63, 0x69, 0x73, 0x63, 0x6f, 0x31, 0x1c, 0x30, 0x1a, 0x6, 0x3, 0x55, 0x4, 0x3, 0xc, 0x13, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x40, 0x73, 0x32, 0x2e, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x2e, 0x63, 0x6f, 0x6d&#125;, RawIssuer:[]uint8&#123;0x30, 0x6d, 0x31, 0xb, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x6, 0x3, 0x55, 0x4, 0x8, 0x13, 0xa, 0x43, 0x61, 0x6c, 0x69, 0x66, 0x6f, 0x72, 0x6e, 0x69, 0x61, 0x31, 0x16, 0x30, 0x14, 0x6, 0x3, 0x55, 0x4, 0x7, 0x13, 0xd, 0x53, 0x61, 0x6e, 0x20, 0x46, 0x72, 0x61, 0x6e, 0x63, 0x69, 0x73, 0x63, 0x6f, 0x31, 0x16, 0x30, 0x14, 0x6, 0x3, 0x55, 0x4, 0xa, 0x13, 0xd, 0x73, 0x32, 0x2e, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x31, 0x19, 0x30, 0x17, 0x6, 0x3, 0x55, 0x4, 0x3, 0x13, 0x10, 0x63, 0x61, 0x2e, 0x73, 0x32, 0x2e, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x2e, 0x63, 0x6f, 0x6d&#125;, Signature:[]uint8&#123;0x30, 0x45, 0x2, 0x21, 0x0, 0x91, 0x4, 0x2f, 0xee, 0x17, 0xca, 0x28, 0x68, 0xb4, 0x33, 0x48, 0x3a, 0x3a, 0x7b, 0x9f, 0xb8, 0x51, 0xb0, 0x6a, 0x8d, 0x28, 0xb9, 0x31, 0x4c, 0xb7, 0x21, 0x87, 0xd5, 0xac, 0xce, 0x6d, 0x1d, 0x2, 0x20, 0x68, 0x61, 0xca, 0x5d, 0xc2, 0x99, 0x63, 0xba, 0xb4, 0x4f, 0x1b, 0x3a, 0x2e, 0xc6, 0xed, 0x6b, 0x25, 0xba, 0x91, 0x63, 0xce, 0x1, 0xe7, 0xba, 0x67, 0x55, 0xbc, 0xb6, 0x8a, 0x76, 0x54, 0x37&#125;, SignatureAlgorithm:10, PublicKeyAlgorithm:3, PublicKey:(*ecdsa.PublicKey)(0xc0003f4980), Version:3, SerialNumber:207641924046541125914056390919893757465, Issuer:pkix.Name&#123;Country:[]string&#123;&quot;US&quot;&#125;, Organization:[]string&#123;&quot;s2.supply.com&quot;&#125;, OrganizationalUnit:[]string(nil), Locality:[]string&#123;&quot;San Francisco&quot;&#125;, Province:[]string&#123;&quot;California&quot;&#125;, StreetAddress:[]string(nil), PostalCode:[]string(nil), SerialNumber:&quot;&quot;, CommonName:&quot;ca.s2.supply.com&quot;, Names:[]pkix.AttributeTypeAndValue&#123;pkix.AttributeTypeAndValue&#123;Type:asn1.ObjectIdentifier&#123;2, 5, 4, 6&#125;, Value:&quot;US&quot;&#125;, pkix.AttributeTypeAndValue&#123;Type:asn1.ObjectIdentifier&#123;2, 5, 4, 8&#125;, Value:&quot;California&quot;&#125;, pkix.AttributeTypeAndValue&#123;Type:asn1.ObjectIdentifier&#123;2, 5, 4, 7&#125;, Value:&quot;San Francisco&quot;&#125;, pkix.AttributeTypeAndValue&#123;Type:asn1.ObjectIdentifier&#123;2, 5, 4, 10&#125;, Value:&quot;s2.supply.com&quot;&#125;, pkix.AttributeTypeAndValue&#123;Type:asn1.ObjectIdentifier&#123;2, 5, 4, 3&#125;, Value:&quot;ca.s2.supply.com&quot;&#125;&#125;, ExtraNames:[]pkix.AttributeTypeAndValue(nil)&#125;, Subject:pkix.Name&#123;Country:[]string&#123;&quot;US&quot;&#125;, Organization:[]string(nil), OrganizationalUnit:[]string(nil), Locality:[]string&#123;&quot;San Francisco&quot;&#125;, Province:[]string&#123;&quot;California&quot;&#125;, StreetAddress:[]string(nil), PostalCode:[]string(nil), SerialNumber:&quot;&quot;, CommonName:&quot;Admin@s2.supply.com&quot;, Names:[]pkix.AttributeTypeAndValue&#123;pkix.AttributeTypeAndValue&#123;Type:asn1.ObjectIdentifier&#123;2, 5, 4, 6&#125;, Value:&quot;US&quot;&#125;, pkix.AttributeTypeAndValue&#123;Type:asn1.ObjectIdentifier&#123;2, 5, 4, 8&#125;, Value:&quot;California&quot;&#125;, pkix.AttributeTypeAndValue&#123;Type:asn1.ObjectIdentifier&#123;2, 5, 4, 7&#125;, Value:&quot;San Francisco&quot;&#125;, pkix.AttributeTypeAndValue&#123;Type:asn1.ObjectIdentifier&#123;2, 5, 4, 3&#125;, Value:&quot;Admin@s2.supply.com&quot;&#125;&#125;, ExtraNames:[]pkix.AttributeTypeAndValue(nil)&#125;, NotBefore:time.Time&#123;wall:0x0, ext:63745605060, loc:(*time.Location)(nil)&#125;, NotAfter:time.Time&#123;wall:0x0, ext:64060965060, loc:(*time.Location)(nil)&#125;, KeyUsage:1, Extensions:[]pkix.Extension&#123;pkix.Extension&#123;Id:asn1.ObjectIdentifier&#123;2, 5, 29, 15&#125;, Critical:true, Value:[]uint8&#123;0x3, 0x2, 0x7, 0x80&#125;&#125;, pkix.Extension&#123;Id:asn1.ObjectIdentifier&#123;2, 5, 29, 19&#125;, Critical:true, Value:[]uint8&#123;0x30, 0x0&#125;&#125;, pkix.Extension&#123;Id:asn1.ObjectIdentifier&#123;2, 5, 29, 35&#125;, Critical:false, Value:[]uint8&#123;0x30, 0x22, 0x80, 0x20, 0x63, 0xbd, 0xab, 0x9a, 0x9c, 0xa7, 0x4f, 0x3d, 0x8b, 0xb6, 0xc3, 0xab, 0xc, 0xb1, 0x45, 0x87, 0x60, 0x69, 0x7e, 0xb9, 0x6, 0xfb, 0x38, 0x5f, 0x9c, 0x2, 0xb1, 0x75, 0x9b, 0xc6, 0x3d, 0xfb&#125;&#125;&#125;, ExtraExtensions:[]pkix.Extension(nil), UnhandledCriticalExtensions:[]asn1.ObjectIdentifier(nil), ExtKeyUsage:[]x509.ExtKeyUsage(nil), UnknownExtKeyUsage:[]asn1.ObjectIdentifier(nil), BasicConstraintsValid:true, IsCA:false, MaxPathLen:-1, MaxPathLenZero:false, SubjectKeyId:[]uint8(nil), AuthorityKeyId:[]uint8&#123;0x63, 0xbd, 0xab, 0x9a, 0x9c, 0xa7, 0x4f, 0x3d, 0x8b, 0xb6, 0xc3, 0xab, 0xc, 0xb1, 0x45, 0x87, 0x60, 0x69, 0x7e, 0xb9, 0x6, 0xfb, 0x38, 0x5f, 0x9c, 0x2, 0xb1, 0x75, 0x9b, 0xc6, 0x3d, 0xfb&#125;, OCSPServer:[]string(nil), IssuingCertificateURL:[]string(nil), DNSNames:[]string(nil), EmailAddresses:[]string(nil), IPAddresses:[]net.IP(nil), URIs:[]*url.URL(nil), PermittedDNSDomainsCritical:false, PermittedDNSDomains:[]string(nil), ExcludedDNSDomains:[]string(nil), PermittedIPRanges:[]*net.IPNet(nil), ExcludedIPRanges:[]*net.IPNet(nil), PermittedEmailAddresses:[]string(nil), ExcludedEmailAddresses:[]string(nil), PermittedURIDomains:[]string(nil), ExcludedURIDomains:[]string(nil), CRLDistributionPoints:[]string(nil), PolicyIdentifiers:[]asn1.ObjectIdentifier(nil)&#125;</span><br><span class="line">2021&#x2F;01&#x2F;25 03:42:33 clientIdentity.AssertAttributeValue(&quot;test&quot;, &quot;hello&quot;) error!</span><br></pre></td></tr></table></figure><h3 id="测试日志分析">测试日志分析</h3><h4 id="clientIdentity-GetID">clientIdentity.GetID()</h4><h5 id="源码-v2">源码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id := fmt.Sprintf(<span class="string">"x509::%s::%s"</span>, getDN(&amp;c.cert.Subject), getDN(&amp;c.cert.Issuer))</span><br><span class="line"><span class="keyword">return</span> base64.StdEncoding.EncodeToString([]<span class="keyword">byte</span>(id)), <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>解码日志输出的base64编码的内容<code>eDUwOTo6Q049QWRtaW5AczIuc3VwcGx5LmNvbSxMPVNhbiBGcmFuY2lzY28sU1Q9Q2FsaWZvcm5pYSxDPVVTOjpDTj1jYS5zMi5zdXBwbHkuY29tLE89czIuc3VwcGx5LmNvbSxMPVNhbiBGcmFuY2lzY28sU1Q9Q2FsaWZvcm5pYSxDPVVT</code>结果如下，主要是证书里面的摘要信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x509::CN=Admin@s2.supply.com,L=San Francisco,ST=California,C=US::CN=ca.s2.supply.com,O=s2.supply.com,L=San Francisco,ST=California,C=US</span><br></pre></td></tr></table></figure><h4 id="clientIdentity-GetAttributeValue-“test”">clientIdentity.GetAttributeValue(“test”)</h4><p><code>log.Printf(&quot;clientIdentity.GetAttributeValue(\&quot;test\&quot;)=%s&quot;, value)</code>这行日志没有打印，是因为没有查询到这个属性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习&lt;code&gt;/github.com/hyperledger/fabric-chaincode-go/pkg/cid/interfaces.go&lt;/code&gt;中的ClientIdentity接口，源码如下，比较简单：&lt;/p&gt;
&lt;h3 id=&quot;源码&quot;&gt;源码&lt;/h3&gt;
&lt;fi</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="API" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/API/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="API" scheme="https://guozhe001.github.io/tags/API/"/>
    
    <category term="ClientIdentity" scheme="https://guozhe001.github.io/tags/ClientIdentity/"/>
    
  </entry>
  
  <entry>
    <title>contract_chaincode.go源码学习</title>
    <link href="https://guozhe001.github.io/2021/01/21/blockchain/fabric/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6API%E5%AD%A6%E4%B9%A0/contract_chaincode.go%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://guozhe001.github.io/2021/01/21/blockchain/fabric/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6API%E5%AD%A6%E4%B9%A0/contract_chaincode.go%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-01-21T06:35:50.424Z</published>
    <updated>2021-01-25T11:32:53.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chaincode如何被启用">Chaincode如何被启用</h2><h3 id="定义智能合约">定义智能合约</h3><p>我们看下面的，名为<code>SmartContract</code>的结构，就是智能合约，你也可以起其他的名字，但是无论名字叫什么，智能合约都必须有一个内嵌的<code>contractapi.Contract</code>，我们看一下它的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SmartContract <span class="keyword">struct</span> &#123;</span><br><span class="line">contractapi.Contract</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动智能合约的入口">启动智能合约的入口</h3><p>在每个chaincode中都必须有一个<code>main</code>方法，这个方法创建一个新的链码并调用它的<code>Start()</code>方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 通过NewChaincode()方法创建链码</span></span><br><span class="line">chaincode, err := contractapi.NewChaincode(<span class="built_in">new</span>(SmartContract))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">"Error create transfer asset chaincode: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 调用链码的Start()方法来启动链码</span></span><br><span class="line"><span class="keyword">if</span> err := chaincode.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">"Error starting asset chaincode: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="智能合约启动的源码">智能合约启动的源码</h3><p>让我们完整的看一下<code>contractapi</code>的源码，源码路径：<code>github.com/hyperledger/fabric-contract-api-go/contractapi/contract_chaincode.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright the Hyperledger Fabric contributors. All rights reserved.</span></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> contractapi</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"unicode"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-chaincode-go/pkg/cid"</span></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-chaincode-go/shim"</span></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-contract-api-go/internal"</span></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-contract-api-go/internal/utils"</span></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-contract-api-go/metadata"</span></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-contract-api-go/serializer"</span></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-protos-go/peer"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> contractChaincodeContract <span class="keyword">struct</span> &#123;</span><br><span class="line">info                      metadata.InfoMetadata</span><br><span class="line">functions                 <span class="keyword">map</span>[<span class="keyword">string</span>]*internal.ContractFunction</span><br><span class="line">unknownTransaction        *internal.TransactionHandler</span><br><span class="line">beforeTransaction         *internal.TransactionHandler</span><br><span class="line">afterTransaction          *internal.TransactionHandler</span><br><span class="line">transactionContextHandler reflect.Type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContractChaincode a struct to meet the chaincode interface and provide routing of calls to contracts</span></span><br><span class="line"><span class="keyword">type</span> ContractChaincode <span class="keyword">struct</span> &#123;</span><br><span class="line">DefaultContract       <span class="keyword">string</span></span><br><span class="line">contracts             <span class="keyword">map</span>[<span class="keyword">string</span>]contractChaincodeContract</span><br><span class="line">metadata              metadata.ContractChaincodeMetadata</span><br><span class="line">Info                  metadata.InfoMetadata</span><br><span class="line">TransactionSerializer serializer.TransactionSerializer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SystemContractName the name of the system smart contract</span></span><br><span class="line"><span class="keyword">const</span> SystemContractName = <span class="string">"org.hyperledger.fabric"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewChaincode creates a new chaincode using contracts passed. The function parses each</span></span><br><span class="line"><span class="comment">// of the passed functions and stores details about their make-up to be used by the chaincode.</span></span><br><span class="line"><span class="comment">// Public functions of the contracts are stored and are made callable in the chaincode. The function</span></span><br><span class="line"><span class="comment">// will error if contracts are invalid e.g. public functions take in illegal types. A system contract is added</span></span><br><span class="line"><span class="comment">// to the chaincode which provides functionality for getting the metadata of the chaincode. The generated</span></span><br><span class="line"><span class="comment">// metadata is a JSON formatted MetadataContractChaincode containing each contract as a name and details</span></span><br><span class="line"><span class="comment">// of the public functions and types they take in/return. It also outlines version details for contracts and the</span></span><br><span class="line"><span class="comment">// chaincode. If these are blank strings this is set to latest. The names for parameters do not match those used</span></span><br><span class="line"><span class="comment">// in the functions, instead they are recorded as param0, param1, ..., paramN. If there exists a file</span></span><br><span class="line"><span class="comment">// contract-metadata/metadata.json then this will overwrite the generated metadata. The contents of this file must</span></span><br><span class="line"><span class="comment">// validate against the schema. The transaction serializer for the contract is set to be the JSONSerializer by</span></span><br><span class="line"><span class="comment">// default. This can be updated using by changing the TransactionSerializer property</span></span><br><span class="line"><span class="comment">// 使用传入的`ContractInterface`列表创建一个新的链码（说明链码并不是智能合约，链码包含了很多智能合约）。</span></span><br><span class="line"><span class="comment">// 该函数解析每个被传递过来的`ContractInterface`的函数，并存储有关链码将使用的其组成的详细信息。</span></span><br><span class="line"><span class="comment">// contracts的公共方法被存储并且可以在链码中调用这些公共方法。如果合约定义的不合法（如公共方法使用非法的类型）这个方法会报错。</span></span><br><span class="line"><span class="comment">// 一个系统合约已添加到链码中，该合约提供了获取链码元数据的功能。</span></span><br><span class="line"><span class="comment">// 生成的元数据是JSON格式的MetadataContractChaincode，其中包含每个合约的名称以及公共函数以及它们参数和返回的类型的详细信息。</span></span><br><span class="line"><span class="comment">// 它还概述了合同和链码的版本详细信息。 如果这些是空白字符串，则将其设置为最新。</span></span><br><span class="line"><span class="comment">// 元数据对于公共方法的描述的参数名称与原始定义的函数中使用的名称不匹配，而是记录为param0，param1，...，paramN。</span></span><br><span class="line"><span class="comment">// 如果存在contract-metadata/metadata.json文件，那么它将覆盖生成的元数据。 该文件的内容必须根据架构进行验证。</span></span><br><span class="line"><span class="comment">// 默认情况下，合约的交易序列化器设置为JSONSerializer。可以通过更改TransactionSerializer属性来更改。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChaincode</span><span class="params">(contracts ...ContractInterface)</span> <span class="params">(*ContractChaincode, error)</span></span> &#123;</span><br><span class="line">ciMethods := getCiMethods()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// new一个ContractChaincode</span></span><br><span class="line">cc := <span class="built_in">new</span>(ContractChaincode)</span><br><span class="line">  <span class="comment">// 设置cc的contracts为一个空map</span></span><br><span class="line">cc.contracts = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]contractChaincodeContract)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历传入的合约列表</span></span><br><span class="line"><span class="keyword">for</span> _, contract := <span class="keyword">range</span> contracts &#123;</span><br><span class="line">additionalExcludes := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 如果传入的合约类型是IgnoreContractInterface</span></span><br><span class="line"><span class="keyword">if</span> castContract, ok := contract.(IgnoreContractInterface); ok &#123;</span><br><span class="line">      <span class="comment">// 则把castContract中的需要忽略的方法赋值给additionalExcludes切片</span></span><br><span class="line">additionalExcludes = castContract.GetIgnoredFunctions()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向cc中添加合约，下面再看addContract方法都干了什么</span></span><br><span class="line">err := cc.addContract(contract, <span class="built_in">append</span>(ciMethods, additionalExcludes...))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建系统合约，并把系统合约添加到链码中</span></span><br><span class="line">sysC := <span class="built_in">new</span>(SystemContract)</span><br><span class="line">sysC.Name = SystemContractName</span><br><span class="line"></span><br><span class="line">cc.addContract(sysC, ciMethods) <span class="comment">// should never error as system contract is good</span></span><br><span class="line"><span class="comment">// 增加元数据</span></span><br><span class="line">err := cc.augmentMetadata()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">metadataJSON, _ := json.Marshal(cc.metadata)</span><br><span class="line"><span class="comment">// 把元数据设置到系统合约中</span></span><br><span class="line">sysC.setMetadata(<span class="keyword">string</span>(metadataJSON))</span><br><span class="line">  <span class="comment">// 设置链码的交易序列化器</span></span><br><span class="line">cc.TransactionSerializer = <span class="built_in">new</span>(serializer.JSONSerializer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start starts the chaincode in the fabric shim</span></span><br><span class="line"><span class="comment">// 在fabric shim中启动链码</span></span><br><span class="line"><span class="comment">// 至于shim是什么，先了解大概：shim包为链码提供API，这些API可以访问状态变量、交易上下文和调用其他的链码。</span></span><br><span class="line"><span class="comment">// shim包源码注释：</span></span><br><span class="line"><span class="comment">// Package shim provides APIs for the chaincode to access its state</span></span><br><span class="line"><span class="comment">// variables, transaction context and call other chaincodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ContractChaincode)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Start(cc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init is called during Instantiate transaction after the chaincode container</span></span><br><span class="line"><span class="comment">// has been established for the first time, passes off details of the request to Invoke</span></span><br><span class="line"><span class="comment">// for handling the request if a function name is passed, otherwise returns shim.Success</span></span><br><span class="line"><span class="comment">// 首次建立链码容器后，在实例化交易之前调用Init</span></span><br><span class="line"><span class="comment">// 如果一个方法名被传递了过来，则把请求的详情传递给Invoke方法来处理，否则返回shim.Success</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ContractChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">nsFcn, _ := stub.GetFunctionAndParameters()</span><br><span class="line"><span class="keyword">if</span> nsFcn == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"Default initiator successful."</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cc.Invoke(stub)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke is called to update or query the ledger in a proposal transaction. Takes the</span></span><br><span class="line"><span class="comment">// args passed in the transaction and uses the first argument to identify the contract</span></span><br><span class="line"><span class="comment">// and function of that contract to be called. The remaining args are then used as</span></span><br><span class="line"><span class="comment">// parameters to that function. Args are converted from strings to the expected parameter</span></span><br><span class="line"><span class="comment">// types of the function before being passed using the set transaction serializer for the ContractChaincode.</span></span><br><span class="line"><span class="comment">// A transaction context is generated and is passed, if required, as the first parameter to the named function.</span></span><br><span class="line"><span class="comment">// Before and after functions are called before and after the named function passed if the contract defines such</span></span><br><span class="line"><span class="comment">// functions to exist. If the before function returns an error the named function is not called and its error</span></span><br><span class="line"><span class="comment">// is returned in shim.Error. If the after function returns an error then its value is returned</span></span><br><span class="line"><span class="comment">// to shim.Error otherwise the value returned from the named function is returned as shim.Success (formatted by</span></span><br><span class="line"><span class="comment">// the transaction serializer). If an unknown name is passed as part of the first arg a shim.Error is returned.</span></span><br><span class="line"><span class="comment">// If a valid name is passed but the function name is unknown then the contract with that name's</span></span><br><span class="line"><span class="comment">// unknown function is called and its value returned as success or error depending on its return. If no</span></span><br><span class="line"><span class="comment">// unknown function is defined for the contract then shim.Error is returned by Invoke. In the case of</span></span><br><span class="line"><span class="comment">// unknown function names being passed (and the unknown handler returns an error) or the named function</span></span><br><span class="line"><span class="comment">// returning an error then the after function if defined is not called. If the named function or unknown</span></span><br><span class="line"><span class="comment">// function handler returns a non-error type then then the after transaction is sent this value. The same</span></span><br><span class="line"><span class="comment">// transaction context is passed as a pointer to before, after, named and unknown functions on each Invoke.</span></span><br><span class="line"><span class="comment">// If no contract name is passed then the default contract is used.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ContractChaincode)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取方法和入参</span></span><br><span class="line">nsFcn, params := stub.GetFunctionAndParameters()</span><br><span class="line"><span class="comment">// 获取字符串":"在nsFcn中最后一次出现的下标</span></span><br><span class="line">li := strings.LastIndex(nsFcn, 字符串<span class="string">":"</span>在)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合约</span></span><br><span class="line"><span class="keyword">var</span> ns <span class="keyword">string</span></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">var</span> fn <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果nsFcn中不存在":"，则说明没有指定合约名称</span></span><br><span class="line"><span class="keyword">if</span> li == <span class="number">-1</span> &#123;</span><br><span class="line">ns = cc.DefaultContract</span><br><span class="line">fn = nsFcn</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ns = nsFcn[:li]</span><br><span class="line">fn = nsFcn[li+<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果合约名不在链码的合约里面，则报错</span></span><br><span class="line"><span class="keyword">if</span> _, ok := cc.contracts[ns]; !ok &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">"Contract not found with name %s"</span>, ns))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果方法为空，则报错</span></span><br><span class="line"><span class="keyword">if</span> fn == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(<span class="string">"Blank function name passed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">originalFn := fn</span><br><span class="line">  <span class="comment">// 把fn强转成rune(int32类型的别名)</span></span><br><span class="line">fnRune := []<span class="keyword">rune</span>(fn)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果传入的方法名的首字母是小写的，则转换成大写</span></span><br><span class="line"><span class="keyword">if</span> unicode.IsLower(fnRune[<span class="number">0</span>]) &#123;</span><br><span class="line">fnRune[<span class="number">0</span>] = unicode.ToUpper(fnRune[<span class="number">0</span>])</span><br><span class="line">fn = <span class="keyword">string</span>(fnRune)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从链码的合约列表中获取合约</span></span><br><span class="line">nsContract := cc.contracts[ns]</span><br><span class="line"><span class="comment">// 通过反射new一个transactionContextHandler类型；这几行有点看不懂了，暂停一下TODO</span></span><br><span class="line">ctx := reflect.New(nsContract.transactionContextHandler)</span><br><span class="line">ctxIface := ctx.Interface().(SettableTransactionContextInterface)</span><br><span class="line">ctxIface.SetStub(stub)</span><br><span class="line"></span><br><span class="line">ci, _ := cid.New(stub)</span><br><span class="line">ctxIface.SetClientIdentity(ci)</span><br><span class="line"></span><br><span class="line">beforeTransaction := nsContract.beforeTransaction</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> beforeTransaction != <span class="literal">nil</span> &#123;</span><br><span class="line">_, _, errRes := beforeTransaction.Call(ctx, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> errRes != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(errRes.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> successReturn <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> successIFace <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> errorReturn error</span><br><span class="line"></span><br><span class="line">serializer := cc.TransactionSerializer</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok := nsContract.functions[fn]; !ok &#123;</span><br><span class="line">unknownTransaction := nsContract.unknownTransaction</span><br><span class="line"><span class="keyword">if</span> unknownTransaction == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">"Function %s not found in contract %s"</span>, originalFn, ns))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">successReturn, successIFace, errorReturn = unknownTransaction.Call(ctx, <span class="literal">nil</span>, serializer)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">var</span> transactionSchema *metadata.TransactionMetadata</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> cc.metadata.Contracts[ns].Transactions &#123;</span><br><span class="line"><span class="keyword">if</span> v.Name == fn &#123;</span><br><span class="line">transactionSchema = &amp;v</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">successReturn, successIFace, errorReturn = nsContract.functions[fn].Call(ctx, transactionSchema, &amp;cc.metadata.Components, serializer, params...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> errorReturn != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(errorReturn.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">afterTransaction := nsContract.afterTransaction</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> afterTransaction != <span class="literal">nil</span> &#123;</span><br><span class="line">_, _, errRes := afterTransaction.Call(ctx, successIFace, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> errRes != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> shim.Error(errRes.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(successReturn))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ContractChaincode)</span> <span class="title">addContract</span><span class="params">(contract ContractInterface, excludeFuncs []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 返回合同名称。当合同用于创建新的链码时，将调用此函数，然后使用返回的名称在调用Init/Invoke时在链码中标识合同。</span></span><br><span class="line"><span class="comment">// 此函数可以返回空白字符串，但这是未定义的行为。</span></span><br><span class="line">ns := contract.GetName()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果合约名称为空，则使用合约类型通过反射的方式获取合约的名称</span></span><br><span class="line"><span class="keyword">if</span> ns == <span class="string">""</span> &#123;</span><br><span class="line">ns = reflect.TypeOf(contract).Elem().Name()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果链码中已经包含了相同的合约名称，则抛异常</span></span><br><span class="line"><span class="keyword">if</span> _, ok := cc.contracts[ns]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"Multiple contracts being merged into chaincode with name %s"</span>, ns)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ccn := contractChaincodeContract&#123;&#125;</span><br><span class="line">ccn.transactionContextHandler = reflect.ValueOf(contract.GetTransactionContextHandler()).Elem().Type()</span><br><span class="line">transactionContextPtrHandler := reflect.ValueOf(contract.GetTransactionContextHandler()).Type()</span><br><span class="line">ccn.functions = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*internal.ContractFunction)</span><br><span class="line"><span class="comment">// GetInfo方法返回存储的合约的信息，这个信息会用于构建合约的元数据。如果此信息中的版本信息为空，则使用"latest"</span></span><br><span class="line"><span class="comment">// 如果信息中的title为空，则使用合约的GetName方法返回的名称，如果这个名称也为空，则使用合约的类型名</span></span><br><span class="line">ccn.info = contract.GetInfo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ccn.info.Version == <span class="string">""</span> &#123;</span><br><span class="line">ccn.info.Version = <span class="string">"latest"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ccn.info.Title == <span class="string">""</span> &#123;</span><br><span class="line">ccn.info.Title = ns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contractType := reflect.PtrTo(reflect.TypeOf(contract).Elem())</span><br><span class="line">contractValue := reflect.ValueOf(contract).Elem().Addr()</span><br><span class="line"><span class="comment">// returns the unknown function to be used for a contract.</span></span><br><span class="line"><span class="comment">// When the contract is used in creating a new chaincode this function is called</span></span><br><span class="line"><span class="comment">// and the unknown transaction returned is stored. The unknown function is then</span></span><br><span class="line"><span class="comment">// called in cases where an unknown function name is passed for a call to the</span></span><br><span class="line"><span class="comment">// contract via Init/Invoke of the chaincode. If nil is returned the</span></span><br><span class="line"><span class="comment">// chaincode uses its default handling for unknown function names</span></span><br><span class="line"><span class="comment">// 返回要用于合约的未知函数，当合约被用于创建一个新的链码时此方法被调用并且返回存储的未知的交易。</span></span><br><span class="line"><span class="comment">// 在链码通过Init/Invoke调用合约时，如果一个未知的方法名称被传入了则调用此未知方法</span></span><br><span class="line"><span class="comment">// 如果此方法返回nil。则chaincode使用一个默认值来处理未知的方法名</span></span><br><span class="line"><span class="comment">// 个人理解就是不指定方法名调用合约时的默认处理逻辑。</span></span><br><span class="line">ut := contract.GetUnknownTransaction()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ut != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">ccn.unknownTransaction, err = internal.NewTransactionHandler(ut, transactionContextPtrHandler, internal.TransactionHandlerTypeUnknown)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// returns the before function to be used for a contract.</span></span><br><span class="line"><span class="comment">// When the contract is used in creating a new chaincode this function is called</span></span><br><span class="line"><span class="comment">// and the before transaction returned is stored. The before function is then</span></span><br><span class="line"><span class="comment">// called before the named function on each Init/Invoke of that contract via the</span></span><br><span class="line"><span class="comment">// chaincode. When called the before function is passed no extra args, only the</span></span><br><span class="line"><span class="comment">// the transaction context (if specified to take it). If nil is returned</span></span><br><span class="line"><span class="comment">// then no before function is called on Init/Invoke.</span></span><br><span class="line"><span class="comment">// 返回需要对此合约使用的前置函数，当合约被用于创建一个新的链码时此方法被调用并且返回存储的前置交易。</span></span><br><span class="line"><span class="comment">// 然后通过链码在该合约使用Init/Invoke调用指定函数之前调用前置函数。</span></span><br><span class="line"><span class="comment">// 当调用before函数时，不传递任何额外的参数，仅传递事务上下文（如果指定使用它）。</span></span><br><span class="line"><span class="comment">// 如果此方法返回nil，则在调用Init/Invoke之前没有需要执行的函数。</span></span><br><span class="line">bt := contract.GetBeforeTransaction()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bt != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">ccn.beforeTransaction, err = internal.NewTransactionHandler(bt, transactionContextPtrHandler, internal.TransactionHandlerTypeBefore)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取后置函数，在调用合约的指定方法之后调用此函数</span></span><br><span class="line">at := contract.GetAfterTransaction()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> at != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">ccn.afterTransaction, err = internal.NewTransactionHandler(at, transactionContextPtrHandler, internal.TransactionHandlerTypeAfter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">evaluateMethods := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> eci, ok := contract.(EvaluationContractInterface); ok &#123;</span><br><span class="line"><span class="comment">// returns a list of function names that should be tagged in the</span></span><br><span class="line"><span class="comment">// metadata as "evaluate" to indicate to a user of the chaincode that they should query</span></span><br><span class="line"><span class="comment">// rather than invoke these functions</span></span><br><span class="line"><span class="comment">// 返回应该在元数据上打上"求值"标签的方法列表，来向链码的用户展示他们应该查询这个函数而不是调用它</span></span><br><span class="line"><span class="comment">// 个人理解：所以这些函数应该只是计算一些数据的，不会对账本产生影响。如果对账本产生影响又打上这个标签是不是很流氓？</span></span><br><span class="line">evaluateMethods = eci.GetEvaluateTransactions()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历合约中的所有的方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; contractType.NumMethod(); i++ &#123;</span><br><span class="line">typeMethod := contractType.Method(i)</span><br><span class="line">valueMethod := contractValue.Method(i)</span><br><span class="line"><span class="comment">// 如果此方法不再排除的列表中，则可以调用</span></span><br><span class="line"><span class="keyword">if</span> !utils.StringInSlice(typeMethod.Name, excludeFuncs) &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="comment">// 默认的调用方式是CallTypeSubmit</span></span><br><span class="line"><span class="keyword">var</span> callType internal.CallType = internal.CallTypeSubmit</span><br><span class="line"><span class="comment">// 如果在只用于计算的函数列表中，则调用方法修改为CallTypeEvaluate；</span></span><br><span class="line"><span class="comment">// 两次调用StringInSlice会遍历啊两个列表，是不是可以用map把这里优化一下呢？</span></span><br><span class="line"><span class="keyword">if</span> utils.StringInSlice(typeMethod.Name, evaluateMethods) &#123;</span><br><span class="line">callType = internal.CallTypeEvaluate</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建合约的方法</span></span><br><span class="line">ccn.functions[typeMethod.Name], err = internal.NewContractFunctionFromReflect(typeMethod, valueMethod, callType, transactionContextPtrHandler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果合约方法的列表为空，则报错，一个合约中至少有一个公共方法</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ccn.functions) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"Contracts are required to have at least 1 (non-ignored) public method. Contract %s has none. Method names that have been ignored: %s"</span>, ns, utils.SliceAsCommaSentence(excludeFuncs))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cc.contracts[ns] = ccn</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果链码的默认的合约为空，则把当前的合约设置为默认的合约；所以传入的第一个合约就是默认的合约</span></span><br><span class="line"><span class="keyword">if</span> cc.DefaultContract == <span class="string">""</span> &#123;</span><br><span class="line">cc.DefaultContract = ns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反射的方式获取元数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ContractChaincode)</span> <span class="title">reflectMetadata</span><span class="params">()</span> <span class="title">metadata</span>.<span class="title">ContractChaincodeMetadata</span></span> &#123;</span><br><span class="line">reflectedMetadata := metadata.ContractChaincodeMetadata&#123;&#125;</span><br><span class="line">reflectedMetadata.Contracts = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]metadata.ContractMetadata)</span><br><span class="line">reflectedMetadata.Components.Schemas = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]metadata.ObjectMetadata)</span><br><span class="line">reflectedMetadata.Info = &amp;cc.Info</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cc.Info.Version == <span class="string">""</span> &#123;</span><br><span class="line">reflectedMetadata.Info.Version = <span class="string">"latest"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cc.Info.Title == <span class="string">""</span> &#123;</span><br><span class="line">reflectedMetadata.Info.Title = <span class="string">"undefined"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历链码的合约</span></span><br><span class="line"><span class="keyword">for</span> key, contract := <span class="keyword">range</span> cc.contracts &#123;</span><br><span class="line"><span class="comment">// 创建合约的元数据</span></span><br><span class="line">contractMetadata := metadata.ContractMetadata&#123;&#125;</span><br><span class="line">contractMetadata.Name = key</span><br><span class="line">infoCopy := contract.info</span><br><span class="line">contractMetadata.Info = &amp;infoCopy</span><br><span class="line"><span class="comment">// 如果这个合约是默认的合约，元数据的字段也设置为true</span></span><br><span class="line"><span class="keyword">if</span> cc.DefaultContract == key &#123;</span><br><span class="line">contractMetadata.Default = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历合约的所有方法，并创建方法的元数据，最后把这些方法的元数据加入到合约的元数据</span></span><br><span class="line"><span class="keyword">for</span> key, fn := <span class="keyword">range</span> contract.functions &#123;</span><br><span class="line">fnMetadata := fn.ReflectMetadata(key, &amp;reflectedMetadata.Components)</span><br><span class="line"></span><br><span class="line">contractMetadata.Transactions = <span class="built_in">append</span>(contractMetadata.Transactions, fnMetadata)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Slice(contractMetadata.Transactions, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> contractMetadata.Transactions[i].Name &lt; contractMetadata.Transactions[j].Name</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">reflectedMetadata.Contracts[key] = contractMetadata</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> reflectedMetadata</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ContractChaincode)</span> <span class="title">augmentMetadata</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 读取元数据的文件，就是上面说的contract-metadata/metadata.json文件</span></span><br><span class="line">fileMetadata, err := metadata.ReadMetadataFile()</span><br><span class="line"><span class="comment">// 如果报错了并且报错信息不是因为文件不存在的错误，则把错误抛出去</span></span><br><span class="line"><span class="comment">// 优化建议：这里能不能使用不同的error类型来做这种判断呢，这么判断如果error信息更改了就必须两个地方同时修改</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !strings.Contains(err.Error(), <span class="string">"Failed to read metadata from file"</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reflectedMetadata := cc.reflectMetadata()</span><br><span class="line"></span><br><span class="line">fileMetadata.Append(reflectedMetadata)</span><br><span class="line">err = fileMetadata.CompileSchemas()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line">err = metadata.ValidateAgainstSchema(fileMetadata)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cc.metadata = fileMetadata</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getCiMethods 获取合约接口的方法描述的切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCiMethods</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="comment">// 通过反射的方式获取这个类型</span></span><br><span class="line">contractInterfaceType := reflect.TypeOf((*ContractInterface)(<span class="literal">nil</span>)).Elem()</span><br><span class="line">ignoreContractInterfaceType := reflect.TypeOf((*IgnoreContractInterface)(<span class="literal">nil</span>)).Elem()</span><br><span class="line">evaluateContractInterfaceType := reflect.TypeOf((*EvaluationContractInterface)(<span class="literal">nil</span>)).Elem()</span><br><span class="line"></span><br><span class="line">interfaceTypes := []reflect.Type&#123;contractInterfaceType, ignoreContractInterfaceType, evaluateContractInterfaceType&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历这些反射的类型，把他们的方法描述添加到ciMethods切片中</span></span><br><span class="line"><span class="keyword">var</span> ciMethods []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, interfaceType := <span class="keyword">range</span> interfaceTypes &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; interfaceType.NumMethod(); i++ &#123;</span><br><span class="line">ciMethods = <span class="built_in">append</span>(ciMethods, interfaceType.Method(i).Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ciMethods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Chaincode如何被启用&quot;&gt;Chaincode如何被启用&lt;/h2&gt;
&lt;h3 id=&quot;定义智能合约&quot;&gt;定义智能合约&lt;/h3&gt;
&lt;p&gt;我们看下面的，名为&lt;code&gt;SmartContract&lt;/code&gt;的结构，就是智能合约，你也可以起其他的名字，但是无论名字叫什</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="API" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/API/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="contractapi" scheme="https://guozhe001.github.io/tags/contractapi/"/>
    
    <category term="API" scheme="https://guozhe001.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Private data</title>
    <link href="https://guozhe001.github.io/2021/01/21/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Private%20data/"/>
    <id>https://guozhe001.github.io/2021/01/21/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Private%20data/</id>
    <published>2021-01-21T03:52:47.162Z</published>
    <updated>2021-01-25T04:36:11.139Z</updated>
    
    <content type="html"><![CDATA[<p>官方文档：<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private-data/private-data.html" target="_blank" rel="noopener">Private data</a></p><h2 id="What-is-a-private-data-collection">What is a private data collection?</h2><p>A collection is the combination of two elements:</p><ol><li><strong>The actual private data</strong>, sent peer-to-peer <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/gossip.html" target="_blank" rel="noopener">via gossip protocol</a> to only the organization(s) authorized to see it. This data is stored in a private state database on the peers of authorized organizations, which can be accessed from chaincode on these authorized peers. The ordering service is not involved here and does not see the private data. Note that because gossip distributes the private data peer-to-peer across authorized organizations, it is required to set up anchor peers on the channel, and configure CORE_PEER_GOSSIP_EXTERNALENDPOINT on each peer, in order to bootstrap cross-organization communication.</li><li><strong>A hash of that data</strong>, which is endorsed, ordered, and written to the ledgers of every peer on the channel. The hash serves as evidence of the transaction and is used for state validation and can be used for audit purposes.</li></ol><p>The following diagram illustrates the ledger contents of a peer authorized to have private data and one which is not.</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/PrivateDataConcept-2.png" alt="PrivateDataConcept-2"></p><p>Collection members may decide to share the private data with other parties if they get into a dispute or if they want to transfer the asset to a third party. The third party can then compute the hash of the private data and see if it matches the state on the channel ledger, proving that the state existed between the collection members at a certain point in time.</p><p>In some cases, you may decide to have a set of collections each comprised of a single organization. For example an organization may record private data in their own collection, which could later be shared with other channel members and referenced in chaincode transactions. We’ll see examples of this in the sharing private data topic below.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官方文档：&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/release-2.2/private-data/private-data.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pri</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="Key Concepts" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/Key-Concepts/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="Private data" scheme="https://guozhe001.github.io/tags/Private-data/"/>
    
  </entry>
  
  <entry>
    <title>Fabric chaincode lifecycle</title>
    <link href="https://guozhe001.github.io/2021/01/21/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Fabric%20chaincode%20lifecycle/"/>
    <id>https://guozhe001.github.io/2021/01/21/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Fabric%20chaincode%20lifecycle/</id>
    <published>2021-01-21T03:36:22.831Z</published>
    <updated>2021-01-21T06:32:54.667Z</updated>
    
    <content type="html"><![CDATA[<p>官方文档：<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/chaincode_lifecycle.html#what-is-chaincode" target="_blank" rel="noopener">Fabric chaincode lifecycle</a></p><h2 id="Install-and-define-a-chaincode">Install and define a chaincode</h2><ol><li><strong>Package the chaincode:</strong> This step can be completed by one organization or by each organization.</li><li><strong>Install the chaincode on your peers:</strong> Every organization that will use the chaincode to endorse a transaction or query the ledger needs to complete this step.</li><li><strong>Approve a chaincode definition for your organization:</strong> Every organization that will use the chaincode needs to complete this step. The chaincode definition needs to be approved by a sufficient number of organizations to satisfy the channel’s LifecycleEndorsment policy (a majority, by default) before the chaincode can be started on the channel.</li><li><strong>Commit the chaincode definition to the channel:</strong> The commit transaction needs to be submitted by one organization once the required number of organizations on the channel have approved. The submitter first collects endorsements from enough peers of the organizations that have approved, and then submits the transaction to commit the chaincode definition.</li></ol><h2 id="Upgrade-a-chaincode">Upgrade a chaincode</h2><ol><li><p><strong>Repackage the chaincode:</strong> You only need to complete this step if you are upgrading the chaincode binaries.</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-upgrade-package.png" alt="Re-package the chaincode package"></p><p><em>Org1 and Org2 upgrade the chaincode binaries and repackage the chaincode. Both organizations use a different package label.</em></p></li><li><p><strong>Install the new chaincode package on your peers:</strong> Once again, you only need to complete this step if you are upgrading the chaincode binaries. Installing the new chaincode package will generate a package ID, which you will need to pass to the new chaincode definition. You also need to change the chaincode version, which is used by the lifecycle process to track if the chaincode binaries have been upgraded.</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-upgrade-install.png" alt="Re-install the chaincode package"></p><p><em>Org1 and Org2 install the new package on their peers. The installation creates a new packageID.</em></p></li><li><p><strong>Approve a new chaincode definition:</strong> If you are upgrading the chaincode binaries, you need to update the chaincode version and the package ID in the chaincode definition. You can also update your chaincode endorsement policy without having to repackage your chaincode binaries. Channel members simply need to approve a definition with the new policy. The new definition needs to increment the <strong>sequence</strong> variable in the definition by one.</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-upgrade-approve.png" alt="Approve a new chaincode definition"></p><p><em>Organization administrators from Org1 and Org2 approve the new chaincode definition for their respective organizations. The new definition references the new packageID and changes the chaincode version. Since this is the first update of the chaincode, the sequence is incremented from one to two.</em></p></li><li><p><strong>Commit the definition to the channel:</strong> When a sufficient number of channel members have approved the new chaincode definition, one organization can commit the new definition to upgrade the chaincode definition to the channel. There is no separate upgrade command as part of the lifecycle process.</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-upgrade-commit.png" alt="Commit the new definition to the channel"></p><p><em>An organization administrator from Org1 or Org2 commits the new chaincode definition to the channel.</em></p></li></ol><h3 id="Organizations-install-different-chaincode-packages">Organizations install different chaincode packages</h3><p>Each organization can use a different packageID when they approve a chaincode definition. This allows channel members to install different chaincode binaries that use the same endorsement policy and read and write to data in the same chaincode namespace.</p><p>每个组织在批准链码定义时都可以使用不同的packageID。这允许通道成员安装使用相同背书策略的不同链代码二进制文件，并在同一链码名称空间中读取和写入数据。</p><p>Organizations can use this capability to install smart contracts that contain business logic that is specific to their organization. Each organization’s smart contract could contain additional validation that the organization requires before their peers endorse a transaction. Each organization can also write code that helps integrate the smart contract with data from their existing systems.</p><p>组织可以使用此功能来安装包含其组织的特殊的业务逻辑的智能合约。每个组织的智能合约都可以包含组织在其peer认可交易之前所需的其他验证。每个组织还可以编写代码将智能合约与他们现有系统中的数据集成在一起。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-binaries.png" alt="Using different chaincode binaries"></p><p><em>Org1 and Org2 each install versions of the MYCC chaincode containing business logic that is specific to their organization.</em></p><h3 id="Creating-multiple-chaincodes-using-one-package">Creating multiple chaincodes using one package</h3><p>You can use one chaincode package to create multiple chaincode instances on a channel by approving and committing multiple chaincode definitions. Each definition needs to specify a different chaincode name. This allows you to run multiple instances of a smart contract on a channel, but have the contract be subject to different endorsement policies.</p><p>您可以通过批准并提交多个链码定义，使用一个链码包在一个通道上创建多个链码实例。每个定义都需要指定一个不同的链码名称。这使您可以在一个通道上运行智能合约的多个实例，但是要让合约遵循不同的背书策略。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-multiple.png" alt="Starting multiple chaincodes"></p><p><em>Org1 and Org2 use the MYCC_1 chaincode package to approve and commit two different chaincode definitions. As a result, both peers have two chaincode containers running on their peers. MYCC1 has an endorsement policy of 1 out of 2, while MYCC2 has an endorsement policy of 2 out of 2.</em></p><p><em>个人疑问：部署相的链码，使用不同的背书策略，这么做有什么用呢？</em></p><h2 id="Migrate-to-the-new-Fabric-lifecycle">Migrate to the new Fabric lifecycle</h2><p>For information about migrating to the new lifecycle, check out <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrade_to_newest_version.html#chaincode-lifecycle" target="_blank" rel="noopener">Considerations for getting to v2.0</a>.</p><p>If you need to update your channel configurations to enable the new lifecycle, check out <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/enable_cc_lifecycle.html" target="_blank" rel="noopener">Enabling the new chaincode lifecycle</a>.</p><h2 id="More-information">More information</h2><p>You can watch video below to learn more about the motivation of the new Fabric chaincode lifecycle and how it is implemented.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官方文档：&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/release-2.2/chaincode_lifecycle.html#what-is-chaincode&quot; target=&quot;_blank&quot; rel=&quot;n</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="Key Concepts" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/Key-Concepts/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="Fabric chaincode lifecycle" scheme="https://guozhe001.github.io/tags/Fabric-chaincode-lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Smart Contracts and Chaincode</title>
    <link href="https://guozhe001.github.io/2021/01/21/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Smart%20Contracts%20and%20Chaincode/"/>
    <id>https://guozhe001.github.io/2021/01/21/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Smart%20Contracts%20and%20Chaincode/</id>
    <published>2021-01-21T03:29:27.117Z</published>
    <updated>2021-01-21T06:25:06.015Z</updated>
    
    <content type="html"><![CDATA[<p>官方文档：<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/smartcontract/smartcontract.html" target="_blank" rel="noopener">Smart Contracts and Chaincode</a></p><p>TODO</p><p>下图展示Fabric是如何处理验证成功的交易和验证不成功的交易的。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/smartcontract.diagram.04.png" alt="smartcontract.diagram.04"></p><p><em>All transactions have an identifier, a proposal, and a response signed by a set of organizations. All transactions are recorded on the blockchain, whether valid or invalid, but only valid transactions contribute to the world state.</em></p><h2 id="Intercommunication">Intercommunication</h2><p>A Smart Contract can call other smart contracts both within the same channel and across different channels. It this way, they can read and write world state data to which they would not otherwise have access due to smart contract namespaces.</p><p>There are limitations to this inter-contract communication, which are described fully in the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/developapps/chaincodenamespace.html#cross-chaincode-access" target="_blank" rel="noopener">chaincode namespace</a> topic.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官方文档：&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/release-2.2/smartcontract/smartcontract.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;S</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="Key Concepts" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/Key-Concepts/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="Smart Contracts and Chaincode" scheme="https://guozhe001.github.io/tags/Smart-Contracts-and-Chaincode/"/>
    
  </entry>
  
  <entry>
    <title>Peers</title>
    <link href="https://guozhe001.github.io/2021/01/20/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Peers/"/>
    <id>https://guozhe001.github.io/2021/01/20/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Peers/</id>
    <published>2021-01-20T02:15:07.132Z</published>
    <updated>2021-01-21T03:29:55.513Z</updated>
    
    <content type="html"><![CDATA[<p>官方文档：<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/peers/peers.html" target="_blank" rel="noopener">Peers</a></p><h1 id="Peers">Peers</h1><p>A blockchain network is comprised primarily of a set of <em>peer nodes</em> (or, simply, <em>peers</em>). Peers are a fundamental element of the network because they host ledgers and smart contracts. Recall that a ledger immutably records all the transactions generated by smart contracts (which in Hyperledger Fabric are contained in a <em>chaincode</em>, more on this later). Smart contracts and ledgers are used to encapsulate the shared <em>processes</em> and shared <em>information</em> in a network, respectively. These aspects of a peer make them a good starting point to understand a Fabric network.</p><p>区块链网络主要由一组peer节点组成（简称peers）。peers是网络的基本元素，是因为它们托管账本和智能合约。回想一下，账本一成不变地记录了智能合约生成的所有交易。智能合约和账本分别用于封装网络中的共享程序和共享信息。peers的这些方面使它们成为了解Fabric网络的良好起点。</p><p>Other elements of the blockchain network are of course important: ledgers and smart contracts, orderers, policies, channels, applications, organizations, identities, and membership, and you can read more about them in their own dedicated sections. This section focusses on peers, and their relationship to those other elements in a Fabric network.</p><p>组成区块链网络的其他元素当然也很重要：账本和智能合约、orderers、策略、通道、应用程序、组织、身份识别，以及联盟成员，您可以在他们自己的专用部分中阅读有关它们的更多信息。本节重点介绍peers及其与Fabric网络中其他元素的关系。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/peers.diagram.1.png" alt="peers.diagram.1"></p><p><em>A blockchain network is comprised of peer nodes, each of which can hold copies of ledgers and copies of smart contracts. In this example, the network N consists of peers P1, P2 and P3, each of which maintain their own instance of the distributed ledger L1. P1, P2 and P3 use the same chaincode, S1, to access their copy of that distributed ledger</em>.</p><p><em>智能合约的网络是由peer节点构成，每个peer节点都托管账本的副本以及智能合约的副本。略。。。</em></p><p>Peers can be created, started, stopped, reconfigured, and even deleted. They expose a set of APIs that enable administrators and applications to interact with the services that they provide. We’ll learn more about these services in this section.</p><p>Peers可以被删除、启动、停止、重新配置甚至删除。它们暴露了一组API，使管理员和应用程序可以与其提供的服务进行交互。我们将在本节中详细了解这些服务。</p><h2 id="A-word-on-terminology（术语）">A word on terminology（术语）</h2><p>Fabric implements <strong>smart contracts</strong> with a technology concept it calls <strong>chaincode</strong> — simply a piece of code that accesses the ledger, written in one of the supported programming languages. In this topic, we’ll usually use the term <strong>chaincode</strong>, but feel free to read it as <strong>smart contract</strong> if you’re more used to that term. It’s the same thing! If you want to learn more about chaincode and smart contracts, check out our <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/smartcontract/smartcontract.html" target="_blank" rel="noopener">documentation on smart contracts and chaincode</a>.</p><p>Fabric通过称为链码的技术概念实现智能合约，<strong>chaincode</strong>是用一种使用Fabric支持的编程语言编写的访问账本的一段代码。在本主题中，我们通常使用<strong>chaincode</strong>一词，但如果您更习惯<strong>smart contract</strong>术语，也可以将其作为智能合约阅读。It’s the same thing! If you want to learn more about chaincode and smart contracts, check out our <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/smartcontract/smartcontract.html" target="_blank" rel="noopener">documentation on smart contracts and chaincode</a>.</p><h2 id="Ledgers-and-Chaincode">Ledgers and Chaincode</h2><p>Let’s look at a peer in a little more detail. We can see that it’s the peer that hosts both the ledger and chaincode. More accurately, the peer actually hosts <em>instances</em> of the ledger, and <em>instances</em> of chaincode. Note that this provides a deliberate redundancy in a Fabric network — it avoids single points of failure. We’ll learn more about the distributed and decentralized nature of a blockchain network later in this section.</p><p>让我们再详细的看一下peer。我们可以看到peer既托管了账本也托管了链码。更准确地说，peer实际上托管账本实例和链码实例。请注意，这在Fabric网络中提供了有意的冗余-避免了单点故障。在本节的后面，我们将详细了解区块链网络的分布式和分散式性质。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/peers.diagram.2.png" alt="peers.diagram.2"></p><p><em>A peer hosts instances of ledgers and instances of chaincodes. In this example, P1 hosts an instance of ledger L1 and an instance of chaincode S1. There can be many ledgers and chaincodes hosted on an individual peer.</em></p><p>Because a peer is a <em>host</em> for ledgers and chaincodes, applications and administrators must interact with a peer if they want to access these resources. That’s why peers are considered the most fundamental building blocks of a Fabric network. When a peer is first created, it has neither ledgers nor chaincodes. We’ll see later how ledgers get created, and how chaincodes get installed, on peers.</p><p>因为peer托管了账本和链码，因此应用程序和系统管理员如果想要获取这些资源必须与peer进行交互。这就是为什么将peer视为Fabric网络的最基本组成部分。当peer在一开始被创建时，它既没有账本也没有链码。我们会在后面看到在peers上账本是如何创建的以及链码是如何安装的。</p><h3 id="Multiple-Ledgers">Multiple Ledgers</h3><p>A peer is able to host more than one ledger, which is helpful because it allows for a flexible system design. The simplest configuration is for a peer to manage a single ledger, but it’s absolutely appropriate for a peer to host two or more ledgers when required.</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/peers.diagram.3.png" alt="peers.diagram.3"></p><p><em>A peer hosting multiple ledgers. Peers host one or more ledgers, and each ledger has zero or more chaincodes that apply to them. In this example, we can see that the peer P1 hosts ledgers L1 and L2. Ledger L1 is accessed using chaincode S1. Ledger L2 on the other hand can be accessed using chaincodes S1 and S2.</em></p><p><em>peer托管了一个或多个账本，并且托管了0个或更多的链码</em></p><p>Although it is perfectly possible for a peer to host a ledger instance without hosting any chaincodes which access that ledger, it’s rare that peers are configured this way. The vast majority of peers will have at least one chaincode installed on it which can query or update the peer’s ledger instances. It’s worth mentioning in passing that, whether or not users have installed chaincodes for use by external applications, peers also have special <strong>system chaincodes</strong> that are always present. These are not discussed in detail in this topic.</p><p>尽管对等点完全有可能托管一个账本实例而不托管任何访问该账本的链码，但很少有peer以这种方式配置。绝大多数对等点将至少安装一个链码，可以查询或更新peer的账本实例。值得一提的是，无论用户是否安装了供外部应用程序使用的链码，peer都有始终存在的特殊的系统链码。这些将不在本主题中详细讨论。</p><h3 id="Multiple-Chaincodes">Multiple Chaincodes</h3><p>There isn’t a fixed relationship between the number of ledgers a peer has and the number of chaincodes that can access that ledger. A peer might have many chaincodes and many ledgers available to it.</p><p>Peer拥有的账本数量与可以访问该账本的链码数量之间的关系不是固定的。一个peer可能有许多可用的链码和分类帐。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/peers.diagram.4.png" alt="peers.diagram.4"></p><p><em>An example of a peer hosting multiple chaincodes. Each ledger can have many chaincodes which access it. In this example, we can see that peer P1 hosts ledgers L1 and L2, where L1 is accessed by chaincodes S1 and S2, and L2 is accessed by S1 and S3. We can see that S1 can access both L1 and L2.</em></p><p><em>如上图所示，既可以有多个链码访问同一个账本；也可以一个链码访问多个账本。</em></p><p>We’ll see a little later why the concept of <strong>channels</strong> in Fabric is important when hosting multiple ledgers or multiple chaincodes on a peer.</p><p>我们稍后再看到当在peer上托管多个分类帐或多个链码时，Fabric中的通道概念重要的原因。</p><h2 id="Applications-and-Peers">Applications and Peers</h2><p>We’re now going to show how applications interact with peers to access the ledger. Ledger-query interactions involve a simple three-step dialogue between an application and a peer; ledger-update interactions are a little more involved, and require two extra steps. We’ve simplified these steps a little to help you get started with Fabric, but don’t worry — what’s most important to understand is the difference in application-peer interactions for ledger-query compared to ledger-update transaction styles.</p><p>现在，我们将展示应用程序如何与peer交互以访问账本。账本查询交互包括应用程序和peer之间简单的三步对话；账本更新的交互要复杂得多，并且需要两个额外的步骤。我们已简化了这些步骤，以帮助您开始使用Fabric，但请放心，最重要的是要了解账本查询与账本更新两种交易方式之间的应用程序和peer交互的差异。</p><p>Applications always connect to peers when they need to access ledgers and chaincodes. The Fabric Software Development Kit (SDK) makes this easy for programmers — its APIs enable applications to connect to peers, invoke chaincodes to generate transactions, submit transactions to the network that will get ordered, validated and committed to the distributed ledger, and receive events when this process is complete.</p><p>当应用程序需要访问账本和链码时总是与peer链接。Fabric的SDK让这变得简单，它的API可以让应用程序链接到peers，调用链码来生成交易，提交交易到网络并且获得排序，验证和提交到分布式账本以及当这些程序结束时接收事件。</p><p>Through a peer connection, applications can execute chaincodes to query or update a ledger. The result of a ledger query transaction is returned immediately, whereas ledger updates involve a more complex interaction between applications, peers and orderers. Let’s investigate this in a little more detail.</p><p>通过连接到一个peer，应用程序可以执行链码来查询或者更新账本。账本的查询交易结果将立即返回，但是账本的更新将涉及应用程序、peers和orderers之间的更复杂的的交互。让我们对此进行更详细的研究。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/peers.diagram.6.png" alt="peers.diagram.6"></p><p><em>Peers, in conjunction with orderers, ensure that the ledger is kept up-to-date on every peer. In this example, application A connects to P1 and invokes chaincode S1 to query or update the ledger L1. P1 invokes S1 to generate a proposal response that contains a query result or a proposed ledger update. Application A receives the proposal response and, for queries, the process is now complete. For updates, A builds a transaction from all of the responses, which it sends to O1 for ordering. O1 collects transactions from across the network into blocks, and distributes these to all peers, including P1. P1 validates the transaction before committing to L1. Once L1 is updated, P1 generates an event, received by A, to signify completion.</em></p><p>查询时有图中的1、2、3三个步骤。更新时需要额外的4、5两个步骤的操作。</p><ul><li>1 应用程序链接到peer</li><li>2 应用程序（带着交易提议）调用链码</li><li>2.1 peer（带着交易提议）调用托管在peer上的链码</li><li>2.2 链码生成查询或更新的提议响应</li><li>3 peer把提议响应返回给应用程序</li><li>4 应用程序请求排序节点对交易进行排序</li><li>4.1 排序节点把排好序并打包在区块中交易发送给peers</li><li>4.2 peer使用交易区块更新本地的账本</li><li>5 peer发出账本更新的事件</li></ul><p>A peer can return the results of a query to an application immediately since all of the information required to satisfy the query is in the peer’s local copy of the ledger. Peers never consult with other peers in order to respond to a query from an application. Applications can, however, connect to one or more peers to issue a query; for example, to corroborate a result between multiple peers, or retrieve a more up-to-date result from a different peer if there’s a suspicion that information might be out of date. In the diagram, you can see that ledger query is a simple three-step process.</p><p>peer可以马上把查询结果返回给应用程序是因为查询的所有信息都存在于peer节点的本地账本副本中。Peers从不与其他peer协商以响应来自应用程序的查询。但是应用程序可以链接一个或多个peer来发出查询，例如，在多个peer之间确认结果，或者如果怀疑信息可能已过时，则从另一个peer检索最新结果。</p><p>An update transaction starts in the same way as a query transaction, but has two extra steps. Although ledger-updating applications also connect to peers to invoke a chaincode, unlike with ledger-querying applications, an individual peer cannot perform a ledger update at this time, because other peers must first agree to the change — a process called <strong>consensus</strong>. Therefore, peers return to the application a <strong>proposed</strong> update — one that this peer would apply subject to other peers’ prior agreement. The first extra step — step four — requires that applications send an appropriate set of matching proposed updates to the entire network of peers as a transaction for commitment to their respective ledgers. This is achieved by the application by using an <strong>orderer</strong> to package transactions into blocks, and distributing them to the entire network of peers, where they can be verified before being applied to each peer’s local copy of the ledger. As this whole ordering processing takes some time to complete (seconds), the application is notified asynchronously, as shown in step five.</p><p>Later in this section, you’ll learn more about the detailed nature of this ordering process — and for a really detailed look at this process see the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/txflow.html" target="_blank" rel="noopener">Transaction Flow</a> topic.</p><h2 id="Peers-and-Channels">Peers and Channels</h2><p>Although this section is about peers rather than channels, it’s worth spending a little time understanding how peers interact with each other, and with applications, via <em>channels</em> — a mechanism by which a set of components within a blockchain network can communicate and transact <em>privately</em>.</p><p>尽管本部分介绍的是peer而不是通道，但是值得花一些时间来了解peer如何通过通道与其他peer以及应用程序进行交互。通道是一种机制，区块链网络中的一组组件可以通过该机制进行私下通信和交易。</p><p>These components are typically peer nodes, orderer nodes and applications and, by joining a channel, they agree to collaborate to collectively share and manage identical copies of the ledger associated with that channel. Conceptually, you can think of channels as being similar to groups of friends (though the members of a channel certainly don’t need to be friends!). A person might have several groups of friends, with each group having activities they do together. These groups might be totally separate (a group of work friends as compared to a group of hobby friends), or there can be some crossover between them. Nevertheless, each group is its own entity, with “rules” of a kind.</p><p>这些组件通常是peer节点，orderer节点和应用程序，通过加入通道，它们同意协作以共同共享和管理与该通道关联的账本的相同副本。从概念上讲，您可以将通道视为与朋友组相似。一个人可能有多组朋友，每组都有他们一起做的活动。这些组可能完全分开，它们之间也可能会有交叉。但是，每个组都是其自己的实体，具有某种“规则”。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/peers.diagram.5.png" alt="peers.diagram.5"></p><p><em>Channels allow a specific set of peers and applications to communicate with each other within a blockchain network. In this example, application A can communicate directly with peers P1 and P2 using channel C. You can think of the channel as a pathway for communications between particular applications and peers. (For simplicity, orderers are not shown in this diagram, but must be present in a functioning network.)</em></p><p><em>在区块链网络中通道允许指定的一组peer和应用程序进行通信。</em></p><p>We see that channels don’t exist in the same way that peers do — it’s more appropriate to think of a channel as a logical structure that is formed by a collection of physical peers. <em>It is vital to understand this point — peers provide the control point for access to, and management of, channels</em>.</p><p>通道是一组物理peer的逻辑结构，peer提供了对通道的访问与管理权限。</p><h2 id="Peers-and-Organizations">Peers and Organizations</h2><p>Now that you understand peers and their relationship to ledgers, chaincodes and channels, you’ll be able to see how multiple organizations come together to form a blockchain network.</p><p>Blockchain networks are administered by a collection of organizations rather than a single organization. Peers are central to how this kind of distributed network is built because they are owned by — and are the connection points to the network for — these organizations.</p><p>区块链网络由多个组织管理，而不是单个组织管理。peers对于这种分布式网络的构建至关重要因为他们属于他们的组织，并且他们是他们组织的网络连接点。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/peers.diagram.8.png" alt="peers.diagram.8"></p><p><em>Peers in a blockchain network with multiple organizations. The blockchain network is built up from the peers owned and contributed by the different organizations. In this example, we see four organizations contributing eight peers to form a network. The channel C connects five of these peers in the network N — P1, P3, P5, P7 and P8. The other peers owned by these organizations have not been joined to this channel, but are typically joined to at least one other channel. Applications that have been developed by a particular organization will connect to their own organization’s peers as well as those of different organizations. Again, for simplicity, an orderer node is not shown in this diagram.</em></p><p>It’s really important that you can see what’s happening in the formation of a blockchain network. <em>The network is both formed and managed by the multiple organizations who contribute resources to it.</em> Peers are the resources that we’re discussing in this topic, but the resources an organization provides are more than just peers. There’s a principle at work here — the network literally does not exist without organizations contributing their individual resources to the collective network. Moreover, the network grows and shrinks with the resources that are provided by these collaborating organizations.</p><p>区块链由向其贡献资源的多个组织组成和管理。</p><p>You can see that (other than the ordering service) there are no centralized resources — in the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/peers/peers.html#Peer8" target="_blank" rel="noopener">example above</a>, the network, <strong>N</strong>, would not exist if the organizations did not contribute their peers. This reflects the fact that the network does not exist in any meaningful sense unless and until organizations contribute the resources that form it. Moreover, the network does not depend on any individual organization — it will continue to exist as long as one organization remains, no matter which other organizations may come and go. This is at the heart of what it means for a network to be decentralized.</p><p>Applications in different organizations, as in the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/peers/peers.html#Peer8" target="_blank" rel="noopener">example above</a>, may or may not be the same. That’s because it’s entirely up to an organization as to how its applications process their peers’ copies of the ledger. This means that both application and presentation logic may vary from organization to organization even though their respective peers host exactly the same ledger data.</p><p>如上例所示，不同组织中的应用程序可能相同，也可能不同。</p><p>Applications connect either to peers in their organization, or peers in another organization, depending on the nature of the ledger interaction that’s required. For ledger-query interactions, applications typically connect to their own organization’s peers. For ledger-update interactions, we’ll see later why applications need to connect to peers representing <em>every</em> organization that is required to endorse the ledger update.</p><p>应用程序可以连接到自己组织的peer节点，也可以连接到其他组织的peer节点，具体取决于所需的账本交互的性质。对于账本查询交互，应用程序通常会连接到自己组织的peer节点。对于账本更新交互，我们将在后面看到为什么应用程序需要连接到代表认可账本更新所需的每个组织的peer。</p><h2 id="Peers-and-Identity">Peers and Identity</h2><p>Now that you’ve seen how peers from different organizations come together to form a blockchain network, it’s worth spending a few moments understanding how peers get assigned to organizations by their administrators.</p><p>Peers have an identity assigned to them via a digital certificate from a particular certificate authority. You can read lots more about how X.509 digital certificates work elsewhere in this guide but, for now, think of a digital certificate as being like an ID card that provides lots of verifiable information about a peer. <em>Each and every peer in the network is assigned a digital certificate by an administrator from its owning organization</em>.</p><p>Peers具有通过特定证书颁发机构通过数字证书分配给他们的身份。***。网络中的每个peer节点都由其所属组织的管理员分配的数字证书。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/peers.diagram.9.png" alt="peers.diagram.9"></p><p><em>When a peer connects to a channel, its digital certificate identifies its owning organization via a channel MSP. In this example, P1 and P2 have identities issued by CA1. Channel C determines from a policy in its channel configuration that identities from CA1 should be associated with Org1 using ORG1.MSP. Similarly, P3 and P4 are identified by ORG2.MSP as being part of Org2.</em></p><p><em>当peer连接到通道时，其数字证书通过通道MSP标识其归属的组织。</em></p><p>Whenever a peer connects using a channel to a blockchain network, <em>a policy in the channel configuration uses the peer’s identity to determine its rights.</em> The mapping of identity to organization is provided by a component called a <em>Membership Service Provider</em> (MSP) — it determines how a peer gets assigned to a specific role in a particular organization and accordingly gains appropriate access to blockchain resources. Moreover, a peer can be owned only by a single organization, and is therefore associated with a single MSP. We’ll learn more about peer access control later in this section, and there’s an entire section on MSPs and access control policies elsewhere in this guide. But for now, think of an MSP as providing linkage between an individual identity and a particular organizational role in a blockchain network.</p><p>每当peer使用通道连接到区块链网络时，通道配置中的策略都会使用peer的身份来确定其权利。***</p><p>To digress for a moment, peers as well as <em>everything that interacts with a blockchain network acquire their organizational identity from their digital certificate and an MSP</em>. Peers, applications, end users, administrators and orderers must have an identity and an associated MSP if they want to interact with a blockchain network. <em>We give a name to every entity that interacts with a blockchain network using an identity — a principal.</em> You can learn lots more about principals and organizations elsewhere in this guide, but for now you know more than enough to continue your understanding of peers!</p><p>Peers以及与区块链网络交互的所有事物均从其数字证书和MSP获取其组织身份。***</p><p>Finally, note that it’s not really important where the peer is physically located — it could reside in the cloud, or in a data centre owned by one of the organizations, or on a local machine — it’s the digital certificate associated with it that identifies it as being owned by a particular organization. In our example above, P3 could be hosted in Org1’s data center, but as long as the digital certificate associated with it is issued by CA2, then it’s owned by Org2.</p><p>最后，注意peer的物理位置不是很重要，它可以部署在云上，也可以部署在本地物理机上；不管它在哪里，之相关联的数字证书将其标识为特定组织所拥有。***</p><h2 id="Peers-and-Orderers">Peers and Orderers</h2><p>We’ve seen that peers form the basis for a blockchain network, hosting ledgers and smart contracts which can be queried and updated by peer-connected applications. However, the mechanism by which applications and peers interact with each other to ensure that every peer’s ledger is kept consistent with each other is mediated by special nodes called <em>orderers</em>, and it’s to these nodes we now turn our attention.</p><p>An update transaction is quite different from a query transaction because a single peer cannot, on its own, update the ledger — updating requires the consent of other peers in the network. A peer requires other peers in the network to approve a ledger update before it can be applied to a peer’s local ledger. This process is called <em>consensus</em>, which takes much longer to complete than a simple query. But when all the peers required to approve the transaction do so, and the transaction is committed to the ledger, peers will notify their connected applications that the ledger has been updated. You’re about to be shown a lot more detail about how peers and orderers manage the consensus process in this section.</p><p>更新交易与查询交易是有很大区别的，因为单独的peer不可以自己完成更新账本的工作。更新账本的操作需要网络中其他peer的同意。peer需要网络中的其他peer批准账本更新，然后才能将其应用于peer上的本地账本。此过程称为共识，与简单的查询相比，此过程需要更长的时间才能完成。但是，当所有需要批准交易的peer节点都批准了该交易并将交易提交到账本时，peer将通知其连接的应用程序账本已更新。在本部分中，您将获得有关peers和peers如何管理共识过程的更多详细信息。</p><p>Specifically, applications that want to update the ledger are involved in a 3-phase process, which ensures that all the peers in a blockchain network keep their ledgers consistent with each other.</p><p>具体来说，想要更新账本的应用程序需要3个阶段的过程，这确保了区块链网络中的所有peer保持账本彼此一致。</p><ul><li><p>In the first phase, applications work with a subset of <em>endorsing peers</em>, each of which provide an endorsement of the proposed ledger update to the application, but do not apply the proposed update to their copy of the ledger.</p><p>在第一个阶段，应用程序与一些背书peer节点一起工作，每个背书peer节点都向应用程序提供对提议的账本更新的背书，但不将提议的更新应用于其账本的副本。</p></li><li><p>In the second phase, these separate endorsements are collected together as transactions and packaged into blocks.</p><p>在第二阶段，这些单独的背书将作为交易收集在一起，并打包成块。</p></li><li><p>In the third and final phase, these blocks are distributed back to every peer where each transaction is validated before being committed to that peer’s copy of the ledger.</p><p>在第三阶段（也是最后阶段），这些区块会重新分配给每个peer节点，在此之前，每个交易均经过验证，然后再提交给该peer的账本副本。</p></li></ul><p>As you will see, orderer nodes are central to this process, so let’s investigate in a little more detail how applications and peers use orderers to generate ledger updates that can be consistently applied to a distributed, replicated ledger.</p><p>如您所见，排序者节点是此过程的核心，因此，让我们更详细地研究一下应用程序和peer如何使用排序服务来生成账本更新，该更新可始终应用于分布式复制分类帐。</p><h3 id="Phase-1-Proposal">Phase 1: Proposal</h3><p>Phase 1 of the transaction workflow involves an interaction between an application and a set of peers — it does not involve orderers. Phase 1 is only concerned with an application asking different organizations’ endorsing peers to agree to the results of the proposed chaincode invocation.</p><p>交易流程的第一阶段涉及应用程序与一组peer之间的交互-它不涉及排序者。第一阶段只关心应用程序要求不同组织的背书节点同意提议的链码调用的结果。</p><p>To start phase 1, applications generate a transaction proposal which they send to each of the required set of peers for endorsement. Each of these <em>endorsing peers</em> then independently executes a chaincode using the transaction proposal to generate a transaction proposal response. It does not apply this update to the ledger, but rather simply signs it and returns it to the application. Once the application has received a sufficient number of signed proposal responses, the first phase of the transaction flow is complete. Let’s examine this phase in a little more detail.</p><p>为了开始第一阶段，应用程序生成一个交易提议，然后发送这个交易提议到每个需要背书的peer列表。然后每个背书节点使用交易提议执行链码来生成交易提议响应。它不会将此更新应用于账本，而只是对其进行签名并将其返回给应用程序。一旦应用程序收到足够数量的已签名提案响应后，交易流程的第一阶段就完成了。让我们更详细地研究这个阶段。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/peers.diagram.10.png" alt="peers.diagram.10"></p><p><em>Transaction proposals are independently executed by peers who return endorsed proposal responses. In this example, application A1 generates transaction T1 proposal P which it sends to both peer P1 and peer P2 on channel C. P1 executes S1 using transaction T1 proposal P generating transaction T1 response R1 which it endorses with E1. Independently, P2 executes S1 using transaction T1 proposal P generating transaction T1 response R2 which it endorses with E2. Application A1 receives two endorsed responses for transaction T1, namely E1 and E2.</em></p><p><em>交易提议被每个peer节点独立的执行然后返回背书提议响应。</em></p><p>Initially, a set of peers are chosen by the application to generate a set of proposed ledger updates. Which peers are chosen by the application? Well, that depends on the <em>endorsement policy</em> (defined for a chaincode), which defines the set of organizations that need to endorse a proposed ledger change before it can be accepted by the network. This is literally what it means to achieve consensus — every organization who matters must have endorsed the proposed ledger change <em>before</em> it will be accepted onto any peer’s ledger.</p><p>最初应用程序选择一组peer节点来生成一组提议的账本更新。应用程序会选择哪些peer节点呢？这取决于（为链码定义的）背书策略，该策略定义了一个需要在网络接受之前批准提议的账本更新的组织列表。从字面上看，这是达成共识的意思 – 每个重要的组织都必须已经批准提议的账本更新，然后该更改才会被接受到其他peer的账本中。</p><p>A peer endorses a proposal response by adding its digital signature, and signing the entire payload using its private key. This endorsement can be subsequently used to prove that this organization’s peer generated a particular response. In our example, if peer P1 is owned by organization Org1, endorsement E1 corresponds to a digital proof that “Transaction T1 response R1 on ledger L1 has been provided by Org1’s peer P1!”.</p><p>peer节点通过添加数字签名来认可提议响应，并且使用它的私钥对整个负载的数据进行签名。这个背书随后可以被用于证明这个组织的peer生成了响应。***</p><p>Phase 1 ends when the application receives signed proposal responses from sufficient peers. We note that different peers can return different and therefore inconsistent transaction responses to the application <em>for the same transaction proposal</em>. It might simply be that the result was generated at different times on different peers with ledgers at different states, in which case an application can simply request a more up-to-date proposal response. Less likely, but much more seriously, results might be different because the chaincode is <em>non-deterministic</em>. Non-determinism is the enemy of chaincodes and ledgers and if it occurs it indicates a serious problem with the proposed transaction, as inconsistent results cannot, obviously, be applied to ledgers. An individual peer cannot know that their transaction result is non-deterministic — transaction responses must be gathered together for comparison before non-determinism can be detected. (Strictly speaking, even this is not enough, but we defer this discussion to the transaction section, where non-determinism is discussed in detail.)</p><p>当应用程序收到足够的peer签署的提议响应时，阶段一就结束了。对于同一交易提议，客户端应用程序可能收到不一致的交易响应。这可能只是简单的因为结果是在不同的时间、不同的peer节点使用不同的账本状态下生成的，在这种情况下，应用程序可以简单地请求最新的提议响应。可能性较小但是更严重的是，结果可能会因为链码是不确定的而有所不同。非确定性是链码和账本的敌人，如果发生，则表明提议交易存在严重问题，因为不一致的结果显然不能应用于账本。单个peer无法知道其交易结果是不确定的 – 必须先收集交易响应以进行比较，然后才能检测到不确定性。（严格说来，这还不够，但是我们将讨论推迟到交易部分，在此部分将详细讨论不确定性。）</p><p>At the end of phase 1, the application is free to discard inconsistent transaction responses if it wishes to do so, effectively terminating the transaction workflow early. We’ll see later that if an application tries to use an inconsistent set of transaction responses to update the ledger, it will be rejected.</p><p>在阶段一结束时，应用程序可以随意丢弃不一致的交易响应，从而有效地尽早终止交易流程。稍后我们将看到，如果应用程序尝试使用一组不一致的交易响应来更新账本，它将被拒绝。</p><h3 id="Phase-2-Ordering-and-packaging-transactions-into-blocks">Phase 2: Ordering and packaging transactions into blocks</h3><p>The second phase of the transaction workflow is the packaging phase. The orderer is pivotal to this process — it receives transactions containing endorsed transaction proposal responses from many applications, and orders the transactions into blocks. For more details about the ordering and packaging phase, check out our <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/orderer/ordering_service.html#phase-two-ordering-and-packaging-transactions-into-blocks" target="_blank" rel="noopener">conceptual information about the ordering phase</a>.</p><p>交易流程的第二个阶段是打包阶段。排序者对于此过程至关重要-它从许多应用程序接收包含背书的交易提议响应的交易，并将交易排序打包成区块。***</p><h3 id="Phase-3-Validation-and-commit">Phase 3: Validation and commit</h3><p>At the end of phase 2, we see that orderers have been responsible for the simple but vital processes of collecting proposed transaction updates, ordering them, and packaging them into blocks, ready for distribution to the peers.</p><p>The final phase of the transaction workflow involves the distribution and subsequent validation of blocks from the orderer to the peers, where they can be committed to the ledger. Specifically, at each peer, every transaction within a block is validated to ensure that it has been consistently endorsed by all relevant organizations before it is committed to the ledger. Failed transactions are retained for audit, but are not committed to the ledger.</p><p>交易流程的最后阶段涉及从排序者到peer节点的区块分配和后续验证，在这个阶段可以将它们提交到账本。具体来说，每个peer节点对区块中的每个交易都进行验证，以确保在将其提交到账本之前所有相关组织都一致认可该交易。失败的交易将保留以进行审核，但不会提交到分类账。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/peers.diagram.12.png" alt="peers.diagram.12"></p><p><em>The second role of an orderer node is to distribute blocks to peers. In this example, orderer O1 distributes block B2 to peer P1 and peer P2. Peer P1 processes block B2, resulting in a new block being added to ledger L1 on P1. In parallel, peer P2 processes block B2, resulting in a new block being added to ledger L1 on P2. Once this process is complete, the ledger L1 has been consistently updated on peers P1 and P2, and each may inform connected applications that the transaction has been processed.</em></p><p><em>排序者节点的第二个指责是将区块分发到peer节点。</em></p><p>Phase 3 begins with the orderer distributing blocks to all peers connected to it. Peers are connected to orderers on channels such that when a new block is generated, all of the peers connected to the orderer will be sent a copy of the new block. Each peer will process this block independently, but in exactly the same way as every other peer on the channel. In this way, we’ll see that the ledger can be kept consistent. It’s also worth noting that not every peer needs to be connected to an orderer — peers can cascade blocks to other peers using the <strong>gossip</strong> protocol, who also can process them independently. But let’s leave that discussion to another time!</p><p>第三阶段开始于排序者分发区块到链接它的所有peer节点上。peer节点链接到通道上的排序节点，这样当一个新的区块生成是，所有的链接到排序节点的peer都会收到一个新区块的副本。每个peer都使用与通道上的其他节点一样的方式来独立处理这个区块。通过这种方式账本就可以保持一致了。还值得注意的是，并非每个peer节点都需要连接到排序者 – peer节点可以使用八卦协议将块级联到其他peer，这些peer也可以独立处理区块。</p><p>Upon receipt of a block, a peer will process each transaction in the sequence in which it appears in the block. For every transaction, each peer will verify that the transaction has been endorsed by the required organizations according to the <em>endorsement policy</em> of the chaincode which generated the transaction. For example, some transactions may only need to be endorsed by a single organization, whereas others may require multiple endorsements before they are considered valid. This process of validation verifies that all relevant organizations have generated the same outcome or result. Also note that this validation is different than the endorsement check in phase 1, where it is the application that receives the response from endorsing peers and makes the decision to send the proposal transactions. In case the application violates the endorsement policy by sending wrong transactions, the peer is still able to reject the transaction in the validation process of phase 3.</p><p>收到区块之后后，peer节点将按照区块块中的顺序处理每个交易。对于每笔交易，每个peer节点都将根据产生交易的链码的背书政策来验证该交易是否已被所需的组织背书。例如，某些交易可能只需要由单个组织背书，而其他交易可能需要多个背书才能被视为有效。这个验证过程验证所有相关的组织都生成相同的产物或结果。另请注意，此验证与第一阶段中的背书检查不同，第一阶段的背书检查是应用程序在接收到来自背书节点的响应并做出发送提议交易的决定。如果应用程序发送了错误的交易违反了背书策略，在第三阶段的验证程序中peer节点仍然有能力拒绝此交易。</p><p>If a transaction has been endorsed correctly, the peer will attempt to apply it to the ledger. To do this, a peer must perform a ledger consistency check to verify that the current state of the ledger is compatible with the state of the ledger when the proposed update was generated. This may not always be possible, even when the transaction has been fully endorsed. For example, another transaction may have updated the same asset in the ledger such that the transaction update is no longer valid and therefore can no longer be applied. In this way, the ledger is kept consistent across each peer in the channel because they each follow the same rules for validation.</p><p>如果交易已被正确的认可，则peer节点将尝试将其应用于账本。为此，peer节点必须执行账本一致性检查，以验证生成提议的更新时账本的状态与当前账本的状态一致。即使交易已得到完全认可，这也不总是一致的。例如，另一笔交易可能已更新账本中的同一资产，因此该交易更新不再有效，因此无法再应用。这样，账本在通道中的每个peer节点之间保持一致，因为它们都遵循相同的验证规则。</p><p>After a peer has successfully validated each individual transaction, it updates the ledger. Failed transactions are not applied to the ledger, but they are retained for audit purposes, as are successful transactions. This means that peer blocks are almost exactly the same as the blocks received from the orderer, except for a valid or invalid indicator on each transaction in the block.</p><p>在peer节点成功验证了每个单独的交易后，它将更新分类帐。失败的交易不会被应用于账本，但保留它们以进行审计，就像成功交易一样。这意味着peer节点的区块<strong>几乎</strong>与从排序者接收到的区块完全相同，除了该块中每个交易的有效或无效指示符。</p><p>We also note that phase 3 does not require the running of chaincodes — this is done only during phase 1, and that’s important. It means that chaincodes only have to be available on endorsing nodes, rather than throughout the blockchain network. This is often helpful as it keeps the logic of the chaincode confidential to endorsing organizations. This is in contrast to the output of the chaincodes (the transaction proposal responses) which are shared with every peer in the channel, whether or not they endorsed the transaction. This specialization of endorsing peers is designed to help scalability and confidentiality.</p><p>我们还注意到，第3阶段不需要运行Chaincode，这仅在第1阶段才做，这一点很重要。这意味着链码仅在背书节点上可用，而不是在整个区块链网络上可用。这通常很有用，因为它可以使背书组织的链码逻辑保持私密。这与链码的输出（交易提议响应）相反，链码的输出与通道中的每个peer节点共享，无论他们是否认可交易。这种背书节点的专业化旨在帮助提高可伸缩性和机密性。</p><p>Finally, every time a block is committed to a peer’s ledger, that peer generates an appropriate <em>event</em>. <em>Block events</em> include the full block content, while <em>block transaction events</em> include summary information only, such as whether each transaction in the block has been validated or invalidated. <em>Chaincode</em> events that the chaincode execution has produced can also be published at this time. Applications can register for these event types so that they can be notified when they occur. These notifications conclude the third and final phase of the transaction workflow.</p><p>最后，每次将一个区块提交给peer节点的账本之后，该peer节点都会生成一个适当的<em>event</em>。</p><ul><li><em>Block events</em> 包含所有的区块内容，</li><li><em>block transaction events</em> 只包含摘要信息（例如区块中的每笔交易是否已通过验证或无效）</li><li><em>Chaincode</em> events 链码执行时产生的<em>Chaincode</em> events也可以在此时发布</li></ul><p>应用程序可以注册这些事件类型，以便在事件发生时得到通知。这些通知结束了交易流程的第三阶段也就是最后阶段。</p><p>In summary, phase 3 sees the blocks which are generated by the orderer consistently applied to the ledger. The strict ordering of transactions into blocks allows each peer to validate that transaction updates are consistently applied across the blockchain network.</p><p>总结来说，第三阶段将看到排序者生成的区块一致的应用于账本。严格的将交易排序然后打包到区块使每个peer节点验证交易更新被一致应用到blockchain网络中。</p><h3 id="Orderers-and-Consensus">Orderers and Consensus</h3><p>This entire transaction workflow process is called <em>consensus</em> because all peers have reached agreement on the order and content of transactions, in a process that is mediated by orderers. Consensus is a multi-step process and applications are only notified of ledger updates when the process is complete — which may happen at slightly different times on different peers.</p><p>整个交易流程被称为共识，是因为在排序节点的调解下所有peer节点都已就交易的顺序和内容达成共识。共识是一个多步骤的过程，只有在该过程完成后，才将账本更新通知应用程序 – 在不同的peer上，发生时间可能略有不同。</p><p>We will discuss orderers in a lot more detail in a future orderer topic, but for now, think of orderers as nodes which collect and distribute proposed ledger updates from applications for peers to validate and include on the ledger.</p><p>That’s it! We’ve now finished our tour of peers and the other components that they relate to in Fabric. We’ve seen that peers are in many ways the most fundamental element — they form the network, host chaincodes and the ledger, handle transaction proposals and responses, and keep the ledger up-to-date by consistently applying transaction updates to it.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官方文档：&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/release-2.2/peers/peers.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Peers&lt;/a&gt;&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="Key Concepts" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/Key-Concepts/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="Peers" scheme="https://guozhe001.github.io/tags/Peers/"/>
    
  </entry>
  
  <entry>
    <title>The Ordering Service</title>
    <link href="https://guozhe001.github.io/2021/01/19/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/The-Ordering-Service/"/>
    <id>https://guozhe001.github.io/2021/01/19/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/The-Ordering-Service/</id>
    <published>2021-01-19T10:13:46.868Z</published>
    <updated>2021-01-21T06:25:08.155Z</updated>
    
    <content type="html"><![CDATA[<p>本文档来自<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/orderer/ordering_service.html" target="_blank" rel="noopener">The Ordering Service</a>,有所简化。</p><h2 id="What-is-ordering">What is ordering?</h2><p>Many distributed blockchains, such as Ethereum and Bitcoin, are not permissioned, which means that any node can participate in the consensus process, wherein transactions are ordered and bundled into blocks. Because of this fact, these systems rely on <strong>probabilistic</strong> consensus algorithms which eventually guarantee ledger consistency to a high degree of probability, but which are still vulnerable to divergent ledgers (also known as a ledger “fork”), where different participants in the network have a different view of the accepted order of transactions.</p><p>许多的分布式区块链系统，例如以太坊和比特币都是不需要认可的；这意味着任何节点都可以参与共识过程，这个共识就是把交易排序并打包成区块。由于这个事实，这些系统依赖于概率共识算法（目前是Pow共识算法），该算法最终可以确保分类帐的一致性具有很高的概率，但是它们仍然容易收到分叉的影响，在分叉的分类账中，网络中的不同参与者对接受的交易顺序有不同的看法。</p><p>Hyperledger Fabric works differently. It features a node called an <strong>orderer</strong> (it’s also known as an “ordering node”) that does this transaction ordering, which along with other orderer nodes forms an <strong>ordering service</strong>. Because Fabric’s design relies on <strong>deterministic</strong> consensus algorithms, any block validated by the peer is guaranteed to be final and correct. Ledgers cannot fork the way they do in many other distributed and permissionless blockchain networks.</p><p>Hyperledger Fabric的工作方式有所不同。它具有一个称为“排序者”的节点（也称为“排序节点”）来执行此交易的排序，该节点与其他排序节点一起构成排序服务。由于Fabric的设计依赖于确定性共识算法，因此可以保证peer验证的任何块都是最终的和正确的。账本也不会像以太坊和比特币那样出现分叉。</p><p>In addition to promoting finality, separating the endorsement of chaincode execution (which happens at the peers) from ordering gives Fabric advantages in performance and scalability, eliminating bottlenecks which can occur when execution and ordering are performed by the same nodes.</p><p>除了促进不可变性之外，将链码执行的背书（在同级中发生）与排序分开可以使Fabric在性能和可伸缩性方面具有优势，消除了由相同节点执行和排序时可能发生的瓶颈。</p><h2 id="Orderer-nodes-and-channel-configuration">Orderer nodes and channel configuration</h2><p>In addition to their <strong>ordering</strong> role, orderers also maintain the list of organizations that are allowed to create channels. This list of organizations is known as the “consortium”, and the list itself is kept in the configuration of the “orderer system channel” (also known as the “ordering system channel”). By default, this list, and the channel it lives on, can only be edited by the orderer admin. Note that it is possible for an ordering service to hold several of these lists, which makes the consortium a vehicle for Fabric multi-tenancy.</p><p>除了作为排序的角色之外，orderers还维护允许创建通道的组织的列表。这个组织的列表被称为“联盟”，并且这个列表被保存在 “orderer system channel” 的配置中。默认情况下，此列表及其所处的通道只能由orderer的管理员进行编辑。</p><p>Orderers also enforce basic access control for channels, restricting who can read and write data to them, and who can configure them. Remember that who is authorized to modify a configuration element in a channel is subject to the policies that the relevant administrators set when they created the consortium or the channel. Configuration transactions are processed by the orderer, as it needs to know the current set of policies to execute its basic form of access control. In this case, the orderer processes the configuration update to make sure that the requestor has the proper administrative rights. If so, the orderer validates the update request against the existing configuration, generates a new configuration transaction, and packages it into a block that is relayed to all peers on the channel. The peers then process the configuration transactions in order to verify that the modifications approved by the orderer do indeed satisfy the policies defined in the channel.</p><p>Orderers还对通道实施基本访问控制，限制谁可以向通道读取和写入数据以及谁可以对其进行配置。</p><h2 id="Orderer-nodes-and-identity">Orderer nodes and identity</h2><p>Everything that interacts with a blockchain network, including peers, applications, admins, and orderers, acquires their organizational identity from their digital certificate and their Membership Service Provider (MSP) definition.</p><p>For more information about identities and MSPs, check out our documentation on <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/identity/identity.html" target="_blank" rel="noopener">Identity</a> and <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/membership/membership.html" target="_blank" rel="noopener">Membership</a>.</p><p>Just like peers, ordering nodes belong to an organization. And similar to peers, a separate Certificate Authority (CA) should be used for each organization. Whether this CA will function as the root CA, or whether you choose to deploy a root CA and then intermediate CAs associated with that root CA, is up to you.</p><h2 id="Orderers-and-the-transaction-flow">Orderers and the transaction flow</h2><h3 id="Phase-one-Proposal">Phase one: Proposal</h3><p>We’ve seen from our topic on <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/peers/peers.html" target="_blank" rel="noopener">Peers</a> that they form the basis for a blockchain network, hosting ledgers, which can be queried and updated by applications through smart contracts.</p><p>Specifically, applications that want to update the ledger are involved in a process with three phases that ensures all of the peers in a blockchain network keep their ledgers consistent with each other.</p><p>具体来说，应用程序想要更新账本需要涉及三个阶段的过程来确保区块链网络中的所有peer节点保持账本彼此一致。</p><p>In the first phase, a client application sends a transaction proposal to a subset of peers that will invoke a smart contract to produce a proposed ledger update and then endorse the results. The endorsing peers do not apply the proposed update to their copy of the ledger at this time. Instead, the endorsing peers return a proposal response to the client application. The endorsed transaction proposals will ultimately be ordered into blocks in phase two, and then distributed to all peers for final validation and commit in phase three.</p><p>在第一个阶段中，客户端应用程序将交易建议发送给一些peer节点，这些peer节点将调用智能合约以产生提议的账本更新，然后对结果进行背书。背书的peer节点此时不将建议的更新应用于其账本副本。相反，背书的对等方将提议响应返回到客户端应用程序。然后认可的交易建议将最终在第二阶段按顺序排列，然后分发给所有peer节点以进行最终验证并在第三阶段进行提交。</p><p>For an in-depth look at the first phase, refer back to the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/peers/peers.html#phase-1-proposal" target="_blank" rel="noopener">Peers</a> topic.</p><h3 id="Phase-two-Ordering-and-packaging-transactions-into-blocks">Phase two: Ordering and packaging transactions into blocks</h3><p>After the completion of the first phase of a transaction, a client application has received an endorsed transaction proposal response from a set of peers. It’s now time for the second phase of a transaction.</p><p>在完成交易的第一阶段之后，客户端应用程序已经接收到来自一群peer节点的已经背书的交易提议响应。***</p><p>In this phase, application clients submit transactions containing endorsed transaction proposal responses to an ordering service node. The ordering service creates blocks of transactions which will ultimately be distributed to all peers on the channel for final validation and commit in phase three.</p><p>在这个阶段，客户端应用程序提交包含已经背书的交易提议响应的交易到一个排序服务节点。排序服务创建包含交易的区块，这个区块最终将分发给通道上的所有peer节点，以进行最终验证并在第三阶段进行提交。</p><p>Ordering service nodes receive transactions from many different application clients concurrently. These ordering service nodes work together to collectively form the ordering service. Its job is to arrange batches of submitted transactions into a well-defined sequence and package them into <em>blocks</em>. These blocks will become the <em>blocks</em> of the blockchain!</p><p>排序服务节点同时接收来自许多不同应用程序客户端的交易。这些排序服务节点一起工作以共同形成排序服务。排序服务的工作是对提交过来的批量的交易安排一个明确定义的顺序，并将它们打包成区块。这些区块将成为区块链的区块！</p><p>The number of transactions in a block depends on channel configuration parameters related to the desired size and maximum elapsed duration for a block (<code>BatchSize</code> and <code>BatchTimeout</code> parameters, to be exact). The blocks are then saved to the orderer’s ledger and distributed to all peers that have joined the channel. If a peer happens to be down at this time, or joins the channel later, it will receive the blocks after reconnecting to an ordering service node, or by gossiping with another peer. We’ll see how this block is processed by peers in the third phase.</p><p>区块中的交易数量取决于通道配置参数，与区块的所需大小和最大经过时间有关（更精确的说是<code>BatchSize</code> 和 <code>BatchTimeout</code> 两个参数）。然后这个区块被保存到排序者的账本中并分发给加入到通道的所有peer节点。如果某个peer节点在这时发生了宕机或者在这以后加入到通道，他会在重新连接到排序服务节点之后收到此区块，或者通过gossiping从其他peer获取。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/orderer.diagram.1.png" alt="Orderer1"></p><p><em>The first role of an ordering node is to package proposed ledger updates. In this example, application A1 sends a transaction T1 endorsed by E1 and E2 to the orderer O1. In parallel, Application A2 sends transaction T2 endorsed by E1 to the orderer O1. O1 packages transaction T1 from application A1 and transaction T2 from application A2 together with other transactions from other applications in the network into block B2. We can see that in B2, the transaction order is T1,T2,T3,T4,T6,T5 – which may not be the order in which these transactions arrived at the orderer! (This example shows a very simplified ordering service configuration with only one ordering node.)</em></p><p><em>排序节点的第一个角色时打包提议的账本更新。</em></p><p>It’s worth noting that the sequencing of transactions in a block is not necessarily the same as the order received by the ordering service, since there can be multiple ordering service nodes that receive transactions at approximately the same time. What’s important is that the ordering service puts the transactions into a strict order, and peers will use this order when validating and committing transactions.</p><p>值得注意的是，一个区块中的交易顺序不一定与排序服务所接收的订单顺序相同，因为可能有多个排序服务节点大约在同一时间接收交易。重要的是排序服务将交易置于严格的顺序中，并且peer节点在验证和提交交易时将使用该顺序。</p><p><em>个人理解：看第一遍时觉得多个排序服务节点收到不同的交易进行排序，这些排序服务是如何保持交易顺序的一致性的呢？如果把排序服务看作一个整体这个问题就解决了，不同的排序服务节点接收到交易之后还会对所有的接收到的交易做一个汇总，并不是每个排序服务节点都对交易进行排序。况且每个排序服务节点只是接收连接到这个排序服务节点的应用程序的交易，所以接收到的交易并不是整个通道上的所有的交易内容，因此肯定是不能够由排序服务节点进行单独排序的。</em></p><p>This strict ordering of transactions within blocks makes Hyperledger Fabric a little different from other blockchains where the same transaction can be packaged into multiple different blocks that compete to form a chain. In Hyperledger Fabric, the blocks generated by the ordering service are <strong>final</strong>. Once a transaction has been written to a block, its position in the ledger is immutably assured. As we said earlier, Hyperledger Fabric’s finality means that there are no <strong>ledger forks</strong> — validated transactions will never be reverted or dropped.</p><p>这种区块内的交易具有严格的顺序使Hyperledger Fabric和其他的区块链系统有一点不同，其他的区块链系统相同的交易可以被打包到不同区块中然后竞争形成一个链。在 Hyperledger Fabric中，由排序服务生成的区块是最终的。一旦一个交易被写入一个区块，它在账本中的位置就永远不变了。像我们之前说的， Hyperledger Fabric的最终性意味着没有账本分叉 – 经验证的交易将永远不会被回滚或丢弃。</p><p>We can also see that, whereas peers execute smart contracts and process transactions, orderers most definitely do not. Every authorized transaction that arrives at an orderer is mechanically packaged in a block — the orderer makes no judgement as to the content of a transaction (except for channel configuration transactions, as mentioned earlier).</p><p>我们还可以看到，peer节点执行智能合约并处理交易，而排序者绝对不会做这些。到达排序者的每笔已经授权交易以机械方式打包在一个区块中 – 排序者不对交易的内容做出判断（除了前面所述的通道配置交易）。</p><p>At the end of phase two, we see that orderers have been responsible for the simple but vital processes of collecting proposed transaction updates, ordering them, and packaging them into blocks, ready for distribution.</p><p>在第二阶段的最后，我们看到排序者负责简单但至关重要的过程，这些过程包括收集提议的交易更新，进行排序并将它们打包成区块以便分发。</p><h3 id="Phase-three-Validation-and-commit">Phase three: Validation and commit</h3><p>The third phase of the transaction workflow involves the distribution and subsequent validation of blocks from the orderer to the peers, where they can be committed to the ledger.</p><p>Phase 3 begins with the orderer distributing blocks to all peers connected to it. It’s also worth noting that not every peer needs to be connected to an orderer — peers can cascade blocks to other peers using the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/gossip.html" target="_blank" rel="noopener"><strong>gossip</strong></a> protocol.</p><p>Each peer will validate distributed blocks independently, but in a deterministic fashion, ensuring that ledgers remain consistent. Specifically, each peer in the channel will validate each transaction in the block to ensure it has been endorsed by the required organization’s peers, that its endorsements match, and that it hasn’t become invalidated by other recently committed transactions which may have been in-flight when the transaction was originally endorsed. Invalidated transactions are still retained in the immutable block created by the orderer, but they are marked as invalid by the peer and do not update the ledger’s state.</p><p><img src="https://gitee.com/guozhe001/images/raw/master/orderer.diagram.2.png" alt="Orderer2"></p><p><em>The second role of an ordering node is to distribute blocks to peers. In this example, orderer O1 distributes block B2 to peer P1 and peer P2. Peer P1 processes block B2, resulting in a new block being added to ledger L1 on P1. In parallel, peer P2 processes block B2, resulting in a new block being added to ledger L1 on P2. Once this process is complete, the ledger L1 has been consistently updated on peers P1 and P2, and each may inform connected applications that the transaction has been processed.</em></p><p>In summary, phase three sees the blocks generated by the ordering service applied consistently to the ledger. The strict ordering of transactions into blocks allows each peer to validate that transaction updates are consistently applied across the blockchain network.</p><p>For a deeper look at phase 3, refer back to the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/peers/peers.html#phase-3-validation-and-commit" target="_blank" rel="noopener">Peers</a> topic.</p><h2 id="Ordering-service-implementations">Ordering service implementations</h2><p>While every ordering service currently available handles transactions and configuration updates the same way, there are nevertheless several different implementations for achieving consensus on the strict ordering of transactions between ordering service nodes.</p><p>当前可用的每个排序服务都以相同的方式处理交易和配置更新，但是有几种不同的实现方式可用于在排序服务节点之间对严格的交易顺序达成共识。</p><p>For information about how to stand up an ordering node (regardless of the implementation the node will be used in), check out <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/orderer_deploy.html" target="_blank" rel="noopener">our documentation on standing up an ordering node</a>.</p><ul><li><p><strong>Raft</strong> (recommended)</p><p>New as of v1.4.1, Raft is a crash fault tolerant (CFT) ordering service based on an implementation of <a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">Raft protocol</a> in <a href="https://coreos.com/etcd/" target="_blank" rel="noopener"><code>etcd</code></a>. Raft follows a “leader and follower” model, where a leader node is elected (per channel) and its decisions are replicated by the followers. Raft ordering services should be easier to set up and manage than Kafka-based ordering services, and their design allows different organizations to contribute nodes to a distributed ordering service.</p><p>自v1.4.1起新增，Raft是基于<a href="https://coreos.com/etcd/" target="_blank" rel="noopener"><code>etcd</code></a>的 <a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">Raft 协议</a> 实现的故障容错排序服务。Raft遵从“领导者和跟随者”模型，这个模型是领导者节点（按通道）被选出并由跟随者复制其决策。Raft协议排序服务相较于基于Kafka的排序服务更容易设置和管理，其设计允许不同的组织将节点贡献给分布式排序服务。（<em>个人理解最后一句话是说排序服务是由不同组织的排序服务节点组成</em>）</p></li><li><p><strong>Kafka</strong> (deprecated in v2.x)</p><p>Similar to Raft-based ordering, Apache Kafka is a CFT implementation that uses a “leader and follower” node configuration. Kafka utilizes a ZooKeeper ensemble for management purposes. The Kafka based ordering service has been available since Fabric v1.0, but many users may find the additional administrative overhead of managing a Kafka cluster intimidating or undesirable.</p><p>与基于Raft的排序类似，Apache Kafka是使用“领导者和跟随者”节点配置的CFT实现。Kafka利用ZooKeeper集合进行管理。从Fabric v1.0开始提供基于Kafka的排序服务，但是许多用户可能会发现管理Kafka群集的额外管理开销令人生畏或不受欢迎。</p></li><li><p><strong>Solo</strong> (deprecated in v2.x)</p><p>The Solo implementation of the ordering service is intended for test only and consists only of a single ordering node. It has been deprecated and may be removed entirely in a future release. Existing users of Solo should move to a single node Raft network for equivalent function.</p><p>排序服务的Solo实现仅用于测试，并且仅包含一个订购节点。它已被弃用，在将来的发行版中可能会完全删除。Solo的现有用户应移至单节点Raft网络以实现等效功能。</p></li></ul><h2 id="Raft">Raft</h2><p>For information on how to configure a Raft ordering service, check out our <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/raft_configuration.html" target="_blank" rel="noopener">documentation on configuring a Raft ordering service</a>.</p><p>The go-to ordering service choice for production networks, the Fabric implementation of the established Raft protocol uses a “leader and follower” model, in which a leader is dynamically elected among the ordering nodes in a channel (this collection of nodes is known as the “consenter set”), and that leader replicates messages to the follower nodes. Because the system can sustain the loss of nodes, including leader nodes, as long as there is a majority of ordering nodes (what’s known as a “quorum”) remaining, Raft is said to be “crash fault tolerant” (CFT). In other words, if there are three nodes in a channel, it can withstand the loss of one node (leaving two remaining). If you have five nodes in a channel, you can lose two nodes (leaving three remaining nodes). This feature of a Raft ordering service is a factor in the establishment of a high availability strategy for your ordering service. Additionally, in a production environment, you would want to spread these nodes across data centers and even locations. For example, by putting one node in three different data centers. That way, if a data center or entire location becomes unavailable, the nodes in the other data centers continue to operate.</p><p>生产网络的首选排序服务实现方式，Fabric中已建立的Raft协议的实现是使用“领导者和跟随者”模型，其中领导者是在通道中的排序节点之间动态选举的（该节点集合称为“同意者集”），领导者将消息复制到跟随者节点。因为系统可以承受包括领导节点在内的节点的丢失，所以只要剩下大多数排序节点（所谓的“法定人数”）即可，因此Raft被称为“故障容错”（CFT）。换句话说，如果通道中有三个节点，那么它可以承受一个节点的损失（剩下两个活着的节点）。如果通道中有五个节点，则允许丢失两个节点（剩下三个剩余节点）。Raft排序服务的此功能是为您的排序服务建立高可用性策略的一个因素。此外，在生产环境中，您可能希望将这些节点分布在数据中心甚至本地。例如，通过将节点放置在三个不同的数据中心中。这样，如果一个数据中心或整个位置不可用，则其他数据中心中的节点将继续运行。</p><p>From the perspective of the service they provide to a network or a channel, Raft and the existing Kafka-based ordering service (which we’ll talk about later) are similar. They’re both CFT ordering services using the leader and follower design. If you are an application developer, smart contract developer, or peer administrator, you will not notice a functional difference between an ordering service based on Raft versus Kafka. However, there are a few major differences worth considering, especially if you intend to manage an ordering service:</p><p>从它们提供给网络或通道的服务的角度来看，Raft与现有的基于Kafka的排序服务（我们将在后面讨论）很相似。 它们都是采用领导者和跟随者设计的CFT排序服务。如果你是一个应用程序开发者、智能合约开发者或者是peer绩点管理员，您不会注意到基于Raft和Kafka的排序服务之间的功能差异。但是，有一些主要差异值得考虑，尤其是如果您打算管理排序服务：</p><ul><li><p>Raft is easier to set up. Although Kafka has many admirers, even those admirers will (usually) admit that deploying a Kafka cluster and its ZooKeeper ensemble can be tricky, requiring a high level of expertise in Kafka infrastructure and settings. Additionally, there are many more components to manage with Kafka than with Raft, which means that there are more places where things can go wrong. And Kafka has its own versions, which must be coordinated with your orderers. <strong>With Raft, everything is embedded into your ordering node</strong>.</p><p>Raft的排序服务更容易搭建。</p></li><li><p>Kafka and Zookeeper are not designed to be run across large networks. While Kafka is CFT, it should be run in a tight group of hosts. This means that practically speaking you need to have one organization run the Kafka cluster. Given that, having ordering nodes run by different organizations when using Kafka (which Fabric supports) doesn’t give you much in terms of decentralization because the nodes will all go to the same Kafka cluster which is under the control of a single organization. With Raft, each organization can have its own ordering nodes, participating in the ordering service, which leads to a more decentralized system.</p><p>Kafka和Zookeeper并非是为了跨大型网络运行而设计的。</p></li><li><p>Raft is supported natively, which means that users are required to get the requisite images and learn how to use Kafka and ZooKeeper on their own. Likewise, support for Kafka-related issues is handled through <a href="https://kafka.apache.org/" target="_blank" rel="noopener">Apache</a>, the open-source developer of Kafka, not Hyperledger Fabric. The Fabric Raft implementation, on the other hand, has been developed and will be supported within the Fabric developer community and its support apparatus.</p></li><li><p>Where Kafka uses a pool of servers (called “Kafka brokers”) and the admin of the orderer organization specifies how many nodes they want to use on a particular channel, Raft allows the users to specify which ordering nodes will be deployed to which channel. In this way, peer organizations can make sure that, if they also own an orderer, this node will be made a part of a ordering service of that channel, rather than trusting and depending on a central admin to manage the Kafka nodes.</p></li><li><p>Raft is the first step toward Fabric’s development of a byzantine fault tolerant (BFT) ordering service. As we’ll see, some decisions in the development of Raft were driven by this. If you are interested in BFT, learning how to use Raft should ease the transition.</p><p>Raft是Fabric开发拜占庭式容错（BFT）排序服务的第一步。</p></li></ul><p>Note: Similar to Solo and Kafka, a Raft ordering service can lose transactions after acknowledgement of receipt has been sent to a client. For example, if the leader crashes at approximately the same time as a follower provides acknowledgement of receipt. Therefore, application clients should listen on peers for transaction commit events regardless (to check for transaction validity), but extra care should be taken to ensure that the client also gracefully tolerates a timeout in which the transaction does not get committed in a configured timeframe. Depending on the application, it may be desirable to resubmit the transaction or collect a new set of endorsements upon such a timeout.</p><p>在已将回执确认发送给客户之后，Raft排序服务可能会丢失交易。例如，如果领导者大约在追随者提供回执确认的同时崩溃。因此，无论如何应用程序客户端都应在peer上侦听交易提交事件（以检查交易有效性），但应格外小心，以确保客户端也能容忍超时，在该超时中不会在配置的时间范围内提交事务。</p><h3 id="Raft-concepts">Raft concepts</h3><p>While Raft offers many of the same features as Kafka — albeit in a simpler and easier-to-use package — it functions substantially different under the covers from Kafka and introduces a number of new concepts, or twists on existing concepts, to Fabric.</p><p>尽管Raft提供了许多与Kafka相同的功能 – 尽管采用了更简单易用的软件包 – 它的功能与Kafka的表面大不相同，并为Fabric引入了许多新概念或扭曲现有的概念。</p><p><strong>Log entry</strong>. The primary unit of work in a Raft ordering service is a “log entry”, with the full sequence of such entries known as the “log”. We consider the log consistent if a majority (a quorum, in other words) of members agree on the entries and their order, making the logs on the various orderers replicated.</p><p>Raft排序服务的主要工作单元是 “log entry”，这些条目的完整序列称为“log”。如果多数成员（换言之，为法定人数）同意条目及其顺序，则我们认为日志是一致的，使日志复制到各个排序者上。</p><p><strong>Consenter set</strong>. The ordering nodes actively participating in the consensus mechanism for a given channel and receiving replicated logs for the channel. This can be all of the nodes available (either in a single cluster or in multiple clusters contributing to the system channel), or a subset of those nodes.</p><p><strong>同意者集</strong>。排序节点积极参与给定通道的共识机制，并接收该通道的复制日志。这可以是所有可用节点（在单个群集中或在组成系统通道的多个群集中），也可以是那些节点的子集。</p><p><strong>Finite-State Machine (FSM)</strong>. Every ordering node in Raft has an FSM and collectively they’re used to ensure that the sequence of logs in the various ordering nodes is deterministic (written in the same sequence).</p><p><strong>有限状态机</strong>。Raft中的每个排序节点都有一个FSM，并共同使用它们来确保各个排序节点中的日志顺序是确定的（以相同的顺序写入）。</p><p><strong>Quorum</strong>. Describes the minimum number of consenters that need to affirm a proposal so that transactions can be ordered. For every consenter set, this is a <strong>majority</strong> of nodes. In a cluster with five nodes, three must be available for there to be a quorum. If a quorum of nodes is unavailable for any reason, the ordering service cluster becomes unavailable for both read and write operations on the channel, and no new logs can be committed.</p><p><strong>法定人数</strong>。描述需要确认提议以便可以排序交易的同意者的最小数量。对于每个同意集，这是大多数节点。在一个由五个节点组成的集群中，必须有三个节点可用才能达到法定人数。如果由于任何原因无法达到法定数量的节点，排序服务群集将无法用于通道上的读取和写入操作，并且无法提交任何新日志。</p><p><strong>Leader</strong>. This is not a new concept — Kafka also uses leaders, as we’ve said — but it’s critical to understand that at any given time, a channel’s consenter set elects a single node to be the leader (we’ll describe how this happens in Raft later). The leader is responsible for ingesting new log entries, replicating them to follower ordering nodes, and managing when an entry is considered committed. This is not a special <strong>type</strong> of orderer. It is only a role that an orderer may have at certain times, and then not others, as circumstances determine.</p><p><strong>领导者</strong>。 这不是一个新概念 – 正如我们所说的，Kafka也使用领导者 – 但至关重要的是要了解，在任何给定时间，通道的同意者集会选举一个节点作为领导者（我们稍后将描述在Raft中如何发生）。领导者负责获取新的日志条目，将它们复制到跟随者排序节点，并管理何时将条目视为已提交。这不是排序者的特殊类型。这只是排序者可能在某些时候扮演的角色，***。</p><p><strong>Follower</strong>. Again, not a new concept, but what’s critical to understand about followers is that the followers receive the logs from the leader and replicate them deterministically, ensuring that logs remain consistent. As we’ll see in our section on leader election, the followers also receive “heartbeat” messages from the leader. In the event that the leader stops sending those message for a configurable amount of time, the followers will initiate a leader election and one of them will be elected the new leader.</p><p><strong>追随者</strong>。了解追随者的关键是追随者从领导者那里接收日志并确定性地复制它们，以确保日志保持一致。正如我们在领导者选举部分中所看到的那样，追随者还会从领导者那里接收“心跳”消息。如果领导者在可配置的时间内停止发送这些消息，则跟随者将发起领导者选举，其中一个将被选举为新领导者。</p><h3 id="Raft-in-a-transaction-flow">Raft in a transaction flow</h3><p>Every channel runs on a <strong>separate</strong> instance of the Raft protocol, which allows each instance to elect a different leader. This configuration also allows further decentralization of the service in use cases where clusters are made up of ordering nodes controlled by different organizations. While all Raft nodes must be part of the system channel, they do not necessarily have to be part of all application channels. Channel creators (and channel admins) have the ability to pick a subset of the available orderers and to add or remove ordering nodes as needed (as long as only a single node is added or removed at a time).</p><p>每个通道都运行一个单独的Raft协议实例，这允许每个实例选择不同的领导者。在由不同组织控制的排序节点组成的群集用例中，此配置还允许进一步分散服务。尽管所有Raft节点都必须是系统通道的一部分，但不一定必须是所有应用程序通道的一部分。通道创建者（和通道管理员）可以选择可用订购者的子集，并根据需要添加或删除订购节点（只要一次仅添加或删除一个节点）。</p><p>While this configuration creates more overhead in the form of redundant heartbeat messages and goroutines, it lays necessary groundwork for BFT.</p><p>虽然此配置以冗余心跳消息和goroutine的形式创建了更多开销，但为BFT奠定了必要的基础。</p><p>In Raft, transactions (in the form of proposals or configuration updates) are automatically routed by the ordering node that receives the transaction to the current leader of that channel. This means that peers and applications do not need to know who the leader node is at any particular time. Only the ordering nodes need to know.</p><p>在Raft中，交易（以建议书或配置更新的形式）由接收交易的排序节点自动路由到该通道的当前leader节点。这意味着peer节点和应用程序节点不需要知道当前时间谁是leader节点。只有排序服务节点需要知道。</p><p>When the orderer validation checks have been completed, the transactions are ordered, packaged into blocks, consented on, and distributed, as described in phase two of our transaction flow.</p><h3 id="Architectural-notes">Architectural notes</h3><h4 id="How-leader-election-works-in-Raft">How leader election works in Raft</h4><p>Although the process of electing a leader happens within the orderer’s internal processes, it’s worth noting how the process works.</p><p>Raft nodes are always in one of three states: follower, candidate, or leader. All nodes initially start out as a <strong>follower</strong>. In this state, they can accept log entries from a leader (if one has been elected), or cast votes for leader. If no log entries or heartbeats are received for a set amount of time (for example, five seconds), nodes self-promote to the <strong>candidate</strong> state. In the candidate state, nodes request votes from other nodes. If a candidate receives a quorum of votes, then it is promoted to a <strong>leader</strong>. The leader must accept new log entries and replicate them to the followers.</p><p>Raft的节点一直处于三种状态之一：follower，candidate（候选），或leader。所有的节点的最初状态都是<strong>follower</strong>。在这种状态下，他们可以从leader接收日志条目，或者投票选举leader。如果在设置的时间段内（例如，五秒钟）未接收到日志条目或心跳，则节点会自动升级为 <strong>candidate</strong> 状态。在候选状态下，节点会向其他节点请求投票。如果候选人获得法定人数的选票，则将其晋升为 <strong>leader</strong>。leader节点必须接受新的日志条目并且将其复制到followers。</p><p>For a visual representation of how the leader election process works, check out <a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">The Secret Lives of Data</a>.</p><h4 id="Snapshots">Snapshots</h4><p>If an ordering node goes down, how does it get the logs it missed when it is restarted?</p><p>如果一个排序节点宕机了，它如何在重新启动时获取丢失的日志信息呢？</p><p>While it’s possible to keep all logs indefinitely, in order to save disk space, Raft uses a process called “snapshotting”, in which users can define how many bytes of data will be kept in the log. This amount of data will conform to a certain number of blocks (which depends on the amount of data in the blocks. Note that only full blocks are stored in a snapshot).</p><p>尽管可以无限期保留所有日志，但是为了节省磁盘空间，Raft使用了一种称为“snapshotting”的程序，用户可以在其中定义将在日志中保留多少字节的数据。此数据量将符合一定数量的区块（这取决于块中的数据量，请注意，快照中仅存储完整块）。</p><p>For example, let’s say lagging replica <code>R1</code> was just reconnected to the network. Its latest block is <code>100</code>. Leader <code>L</code> is at block <code>196</code>, and is configured to snapshot at amount of data that in this case represents 20 blocks. <code>R1</code> would therefore receive block <code>180</code> from <code>L</code> and then make a <code>Deliver</code> request for blocks <code>101</code> to <code>180</code>. Blocks <code>180</code> to <code>196</code> would then be replicated to <code>R1</code> through the normal Raft protocol.</p><p>举个例子，假设滞后的副本<code>R1</code>刚刚重新连接到网络。它的最后一个区块是<code>100</code>.Leader节点<code>L</code>最后一个区块是<code>196</code>，并且设置快照的数量代表20个区块。因此，<code>R1</code>将从<code>L</code>接收区块<code>180</code>个，然后对区块<code>101</code>到<code>180</code>发出 <code>Deliver</code> 请求。<code>180</code>到<code>196</code>之间的区块会使用常规的Raft协议复制到<code>R1</code>。</p><h3 id="Kafka-deprecated-in-v2-x">Kafka (deprecated in v2.x)</h3><p>The other crash fault tolerant ordering service supported by Fabric is an adaptation of a Kafka distributed streaming platform for use as a cluster of ordering nodes. You can read more about Kafka at the <a href="https://kafka.apache.org/intro" target="_blank" rel="noopener">Apache Kafka Web site</a>, but at a high level, Kafka uses the same conceptual “leader and follower” configuration used by Raft, in which transactions (which Kafka calls “messages”) are replicated from the leader node to the follower nodes. In the event the leader node goes down, one of the followers becomes the leader and ordering can continue, ensuring fault tolerance, just as with Raft.</p><p>The management of the Kafka cluster, including the coordination of tasks, cluster membership, access control, and controller election, among others, is handled by a ZooKeeper ensemble and its related APIs.</p><p>Kafka clusters and ZooKeeper ensembles are notoriously tricky to set up, so our documentation assumes a working knowledge of Kafka and ZooKeeper. If you decide to use Kafka without having this expertise, you should complete, <em>at a minimum</em>, the first six steps of the <a href="https://kafka.apache.org/quickstart" target="_blank" rel="noopener">Kafka Quickstart guide</a> before experimenting with the Kafka-based ordering service. You can also consult <a href="https://github.com/hyperledger/fabric/blob/release-1.1/bddtests/dc-orderer-kafka.yml" target="_blank" rel="noopener">this sample configuration file</a> for a brief explanation of the sensible defaults for Kafka and ZooKeeper.</p><p>To learn how to bring up a Kafka-based ordering service, check out <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/kafka.html" target="_blank" rel="noopener">our documentation on Kafka</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文档来自&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/release-2.2/orderer/ordering_service.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The </summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="Key Concepts" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/Key-Concepts/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="Ordering Service" scheme="https://guozhe001.github.io/tags/Ordering-Service/"/>
    
  </entry>
  
  <entry>
    <title>Ledger(账本)</title>
    <link href="https://guozhe001.github.io/2021/01/19/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Ledger/"/>
    <id>https://guozhe001.github.io/2021/01/19/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Ledger/</id>
    <published>2021-01-19T09:03:51.855Z</published>
    <updated>2021-01-21T02:56:44.326Z</updated>
    
    <content type="html"><![CDATA[<p>本文档来自于<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/ledger/ledger.html" target="_blank" rel="noopener">Ledger</a>，为了提高学习效率而做了简化。</p><h2 id="The-Ledger">The Ledger</h2><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/ledger.diagram.1.png" alt="ledger.diagram.1"></p><ul><li>Ledger：由World State和Blockchain组成</li><li>World State：是保存账本state的当前状态的数据库（个人理解：可以类比比特币的UTXO）</li><li>Blockchain：记录所有导致当前World State发生的更改的事务日志（个人理解：与比特币的区块链基本一致）</li></ul><h2 id="World-State">World State</h2><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/ledger.diagram.3.png" alt="ledger.diagram.3"></p><ul><li>世界状态是一些事实的键值对</li><li>世界状态是通过数据库实现的</li><li>应用程序提交改变世界状态的交易，这些交易最终被提交到账本的区块链</li><li>世界状态记录的事实都有版本，供Hyperledger Fabric内部使用，并且每次状态更改时都会递增</li><li>当首次创建分类帐时，世界状态为空</li></ul><h2 id="Blockchain">Blockchain</h2><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/ledger.diagram.2.png" alt="ledger.diagram.2"></p><ul><li>Blockchain是有关世界状态中的state是如何到达其当前状态的事实的历史记录</li><li>Fabric中的Blockchain是由文件实现</li><li>Blockchain由Block组成</li><li>Block包含Block header、Block data和Block metadata</li><li>Block header中包含Block data的hash值和上一个区块的hash值</li><li>Block data中包含交易列表</li></ul><h2 id="Blocks">Blocks</h2><ul><li><strong>Block Header</strong><ul><li><strong>Block number</strong>: 从零开始的数字，创世区块是0，每次追加一个新的区块这个Block number自增1</li><li><strong>Current Block Hash</strong>: 当前区块包含的所有的交易的hash值</li><li><strong>Previous Block Header Hash</strong>: 上一个区块的Block Header中的hash值</li></ul></li></ul><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/ledger.diagram.4.png" alt="ledger.diagram.4"></p><ul><li><p><strong>Block Data</strong></p><p>Block Data包含已经排好序的交易列表，这些交易在排序服务创建区块时写入到Block Data</p></li><li><p><strong>Block Metadata</strong></p><ul><li>Block Metadata包含区块创建者的证书和签名，用于通过网络节点验证块。</li><li>区块提交者将每个交易的有效/无效指示符添加到Block Metadata的bitmap中</li><li>直到（包括）该块为止的累积状态的哈希值，以便检测状态派生（这是为了在提交之前验证状态有没有被其他的交易更改）</li></ul></li></ul><h2 id="Transactions">Transactions</h2><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/ledger.diagram.5.png" alt="ledger.diagram.5"></p><p>每个交易都包含以下四部分：</p><ul><li><p><strong>Header</strong></p><p>取得有关交易的一些基本元数据-例如相关链码的名称及其版本。</p></li><li><p><strong>Signature</strong></p><p>包含客户端应用程序的签名；此字段用于检查交易明细是否未被篡改，因为它需要应用程序的私钥来生成。</p></li><li><p><strong>Proposal</strong></p><p>保存编码后的应用程序提供给智能合约的输入参数，使用这些参数来创建更新账本的提议。当智能合约运行时，该提议提供了一组输入参数，这些输入参数与当前的世界状态一起确定了新的世界状态。</p></li><li><p><strong>Response</strong></p><p>获取世界状态的前后值，作为读写集（RW-set）。它是智能合约的输出，如果交易成功通过验证，它将应用于账本来更新世界状态。</p></li><li><p><strong>Endorsements</strong></p><p>这是满足背书策略的组织的签名列表。交易响应包含了背书列表，并且只有满足交易背书策略的背书列表才会存在在此，如果不满足背书策略则不在此记录，因为也不会更新世界状态。</p></li></ul><h2 id="World-State-database-options">World State database options</h2><p>The world state is physically implemented as a database, to provide simple and efficient storage and retrieval of ledger states. As we’ve seen, ledger states can have simple or compound values, and to accommodate this, the world state database implementation can vary, allowing these values to be efficiently implemented. Options for the world state database currently include LevelDB and CouchDB.</p><p>世界状态在物理上是使用数据库实现的，以提供简单有效的存储和账本状态检索。如我们所见，账本状态可以具有简单值或复合值，为了适应这种情况，世界状态数据库的实现方式可能会有所不同，从而可以有效地实现这些情况。世界状态数据库的选项当前包括LevelDB和CouchDB。</p><p>LevelDB is the default and is particularly appropriate when ledger states are simple key-value pairs. A LevelDB database is co-located with the peer node – it is embedded within the same operating system process.</p><p>LevelDB是默认值，当账本状态为简单键/值对时尤其适用。LevelDB数据库与peer节点位于同一位置都嵌入在同一操作系统进程中。</p><p>CouchDB is a particularly appropriate choice when ledger states are structured as JSON documents because CouchDB supports the rich queries and update of richer data types often found in business transactions. Implementation-wise, CouchDB runs in a separate operating system process, but there is still a 1:1 relation between a peer node and a CouchDB instance. All of this is invisible to a smart contract. See <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/couchdb_as_state_database.html" target="_blank" rel="noopener">CouchDB as the StateDatabase</a> for more information on CouchDB.</p><p>当账本状态被构造为JSON格式的文档时，CouchDB是一个特别合适的选择，因为CouchDB支持丰富的查询和业务交易中经常发生的丰富数据类型的更新。在实现方面，CouchDB在单独的操作系统进程中运行，但是peer节点和CouchDB实例之间仍然存在1比1的关系。</p><p>In LevelDB and CouchDB, we see an important aspect of Hyperledger Fabric – it is <em>pluggable</em>. The world state database could be a relational data store, or a graph store, or a temporal database. This provides great flexibility in the types of ledger states that can be efficiently accessed, allowing Hyperledger Fabric to address many different types of problems.</p><p>在LevelDB和CouchDB中，我们看到了Hyperledger Fabric的重要方面–它是插件化的。世界状态数据库可以是关系数据存储，图形存储或时态数据库。这为可以有效访问的账本状态类型提供了极大的灵活性，从而使Hyperledger Fabric可以解决许多不同类型的问题。</p><h2 id="Example-Ledger-Basic-Asset-Transfer">Example Ledger: Basic Asset Transfer</h2><p>使用同一个身份创建四个资产，账本会变成下面这样：</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/ledger.diagram.6.png" alt="ledger.diagram.6"></p><h2 id="Namespaces">Namespaces</h2><p>Even though we have presented the ledger as though it were a single world state and single blockchain, that’s a little bit of an over-simplification. In reality, each chaincode has its own world state that is separate from all other chaincodes. World states are in a namespace so that only smart contracts within the same chaincode can access a given namespace.</p><p>即使我们已经将账本呈现为一个单一的世界状态和单个区块链，但这还是有点过分简化了。实际上，每个链码都有其自己的世界状态，该状态与所有其他链码分开。世界状态位于名称空间中，因此只有相同链码内的智能合约才能访问给定的名称空间。</p><p>A blockchain is not namespaced. It contains transactions from many different smart contract namespaces. You can read more about chaincode namespaces in this <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/developapps/chaincodenamespace.html" target="_blank" rel="noopener">topic</a>.</p><p>区块链没有命名空间。它包含来自许多不同的智能合约命名空间的交易。您可以在<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/developapps/chaincodenamespace.html" target="_blank" rel="noopener">Chaincode namespace</a>中阅读有关链码名称空间的更多信息。</p><h2 id="Channels">Channels</h2><p>In Hyperledger Fabric, each <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/channels.html" target="_blank" rel="noopener">channel</a> has a completely separate ledger. This means a completely separate blockchain, and completely separate world states, including namespaces. It is possible for applications and smart contracts to communicate between channels so that ledger information can be accessed between them.</p><p>在Hyperledger Fabric中，每个通道都有一个完全独立的账本。这意味着完全独立的区块链，以及完全独立的世界状态以及名称空间。应用程序和智能合约可以在通道之间进行通信，以便可以在它们之间访问分类帐信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文档来自于&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/release-2.2/ledger/ledger.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ledger&lt;/a&gt;，为了提</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="Key Concepts" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/Key-Concepts/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="Ledger" scheme="https://guozhe001.github.io/tags/Ledger/"/>
    
  </entry>
  
  <entry>
    <title>Policies(策略)</title>
    <link href="https://guozhe001.github.io/2021/01/19/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Policies/"/>
    <id>https://guozhe001.github.io/2021/01/19/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Policies/</id>
    <published>2021-01-19T02:20:39.254Z</published>
    <updated>2021-01-19T10:59:24.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-a-policy">What is a policy</h2><p>At its most basic level, a policy is a set of rules that define the structure for how decisions are made and specific outcomes are reached. To that end, policies typically describe a <strong>who</strong> and a <strong>what</strong>, such as the access or rights that an individual has over an <strong>asset</strong>. We can see that policies are used throughout our daily lives to protect assets of value to us, from car rentals, health, our homes, and many more.</p><p>在最基本的级别上，策略是一组规则，这些规则定义了如何制定决策和达到特定结果的结构。为此，策略通常描述<strong>WHO</strong>和<strong>WHAT</strong>，例如个人对<strong>ASSET</strong>的访问或权利。我们可以看到，策略在我们的日常生活中一直被用来保护对我们有价值的资产，使其免受汽车租赁，医疗，房屋等的侵害。</p><p>For example, an insurance policy defines the conditions, terms, limits, and expiration under which an insurance payout will be made. The policy is agreed to by the policy holder and the insurance company, and defines the rights and responsibilities of each party.</p><p>例如，保险单定义了将要支付保险金的条件，条款，限额和有效期。该保单经保单持有人和保险公司同意，并定义了双方的权利和责任。</p><p>Whereas an insurance policy is put in place for risk management, in Hyperledger Fabric, policies are the mechanism for infrastructure management. Fabric policies represent how members come to agreement on accepting or rejecting changes to the network, a channel, or a smart contract. Policies are agreed to by the consortium members when a network is originally configured, but they can also be modified as the network evolves. For example, they describe the criteria for adding or removing members from a channel, change how blocks are formed, or specify the number of organizations required to endorse a smart contract. All of these actions are described by a policy which defines who can perform the action. Simply put, everything you want to do on a Fabric network is controlled by a policy.</p><p>尽管已为风险管理制定了保险单，但在Hyperledger Fabric中，风险管理是基础架构管理的机制。Fabric的策略代表成员如何就接受或拒绝对网络，渠道或智能合约的更改达成协议。最初配置网络时，策略是由联盟成员同意的，但是也可以随着网络的发展而修改策略。例如，它们描述了在通道中添加或删除成员，更改区块的形成方式或指定认可智能合约所需的组织数量的标准。所有这些动作均由定义了谁可以执行该动作的策略来描述。简而言之，您要在Fabric网络上执行的所有操作均受策略控制。</p><h2 id="Why-are-policies-needed">Why are policies needed</h2><p>Policies are one of the things that make Hyperledger Fabric different from other blockchains like Ethereum or Bitcoin. In those systems, transactions can be generated and validated by any node in the network. The policies that govern the network are fixed at any point in time and can only be changed using the same process that governs the code. Because Fabric is a permissioned blockchain whose users are recognized by the underlying infrastructure, those users have the ability to decide on the governance of the network before it is launched, and change the governance of a running network.</p><p>策略是使Hyperledger Fabric与以太坊或比特币等其他区块链不同的原因之一。在比特币或以太坊系统中，交易可以由网络上的任意节点生成和验证。支配网络的策略在任何时间都是固定的，并且只能使用支配代码的相同过程进行更改。由于Fabric是许可的区块链，其用户被基础架构所识别，因此这些用户具有在启动网络之前决定网络治理的能力，并且也具有更改运行中网络的治理的能力。</p><p>Policies allow members to decide which organizations can access or update a Fabric network, and provide the mechanism to enforce those decisions. Policies contain the lists of organizations that have access to a given resource, such as a user or system chaincode. They also specify how many organizations need to agree on a proposal to update a resource, such as a channel or smart contracts. Once they are written, policies evaluate the collection of signatures attached to transactions and proposals and validate if the signatures fulfill the governance agreed to by the network.</p><p>策略允许成员决定哪些组织可以访问或更新一个Fabric网络，并提供执行这些决定的机制。策略包含对给定的资源的有访问权限的组织的列表，比如一个用户或者系统链码。策略还指定有多少组织需要就更新资源（例如通道或智能合约）的提案达成协议。一旦写入，策略将评估附加在交易和提议中的签名的集合，并验证签名是否满足网络所同意的治理。</p><h2 id="How-are-policies-implemented-throughout-Fabric">How are policies implemented throughout Fabric</h2><p>Policies are implemented at different levels of a Fabric network. Each policy domain governs different aspects of how a network operates.</p><p>策略是在Fabric网络的不同级别上实现的。每个策略域管理网络运行的不同方面。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/FabricPolicyHierarchy-2.png" alt="FabricPolicyHierarchy-2"></p><p><em>A visual representation of the Fabric policy hierarchy.</em></p><p><em>Fabric策略层次结构的直观表示。</em></p><h3 id="System-channel-configuration">System channel configuration</h3><p>Every network begins with an ordering <strong>system channel</strong>. There must be exactly one ordering system channel for an ordering service, and it is the first channel to be created. The system channel also contains the organizations who are the members of the ordering service (ordering organizations) and those that are on the networks to transact (consortium organizations).</p><p>每个网络都从一个排序系统通道开始。对排序服来说，必须有一个确定的排序系统通道，并且他是第一个需要创建的通道。系统通道还包含作为排序服务成员的组织（排序组织）和在网络上进行交易的组织（联盟组织）。</p><p>The policies in the ordering system channel configuration blocks govern the consensus used by the ordering service and define how new blocks are created. The system channel also governs which members of the consortium are allowed to create new channels.</p><p>排序系统通道配置区块中的策略控制排序服务使用的共识，并定义如何创建新区块。系统通道也控制联盟中的哪些成员允许创建新的通道。</p><h3 id="Application-channel-configuration">Application channel configuration</h3><p>Application <em>channels</em> are used to provide a private communication mechanism between organizations in the consortium.</p><p>应用程序通道用于在联盟中的组织之间提供专用的通信机制。</p><p>The policies in an application channel govern the ability to add or remove members from the channel. Application channels also govern which organizations are required to approve a chaincode before the chaincode is defined and committed to a channel using the Fabric chaincode lifecycle. When an application channel is initially created, it inherits all the ordering service parameters from the orderer system channel by default. However, those parameters (and the policies governing them) can be customized in each channel.</p><p>应用程序通道中的策略控制了从通道中添加或者移除成员的能力。应用程序通道也控制了在使用Fabric链码生命周期定义链码并将其提交给通道之前，需要哪些成员需要。最初创建应用程序通道时，默认情况下它将从排序系统通道继承所有排序服务参数。但是，可以在每个通道中自定义这些参数（以及控制它们的策略）。</p><h3 id="Access-control-lists-ACLs">Access control lists (ACLs)</h3><p>Network administrators will be especially interested in the Fabric use of ACLs, which provide the ability to configure access to resources by associating those resources with existing policies. These “resources” could be functions on system chaincode (e.g., “GetBlockByNumber” on the “qscc” system chaincode) or other resources (e.g.,who can receive Block events). ACLs refer to policies defined in an application channel configuration and extends them to control additional resources. The default set of Fabric ACLs is visible in the <code>configtx.yaml</code> file under the <code>Application: &amp;ApplicationDefaults</code> section but they can and should be overridden in a production environment. The list of resources named in <code>configtx.yaml</code> is the complete set of all internal resources currently defined by Fabric.</p><p>网络管理员可能对Fabric使用的AC特别感兴趣，ACL可以通过将资源与现有策略相关联来配置对资源的访问。这些“资源”可以是系统链码上的功能（如，在“ qscc”系统链码上的“ GetBlockByNumber”）或其他资源（如谁可以接收Block事件）。ACL引用在应用程序通道配置中定义的策略，并将其扩展以控制其他资源。默认的Fabric ACL集在<code>configtx.yaml</code>文件里的 <code>Application: &amp;ApplicationDefaults</code> 部分下的可见，但是可以并且应该在生产环境中覆盖它们。<code>configtx.yaml</code>中命名的资源列表是Fabric当前定义的所有内部资源的完整集合。</p><p>In that file, ACLs are expressed using the following format:</p><p>在该文件中，ACL使用以下格式表示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ACL policy for chaincode to chaincode invocation</span></span><br><span class="line"><span class="attr">peer/ChaincodeToChaincode:</span> <span class="string">/Channel/Application/Readers</span></span><br></pre></td></tr></table></figure><p>Where <code>peer/ChaincodeToChaincode</code> represents the resource being secured and <code>/Channel/Application/Readers</code> refers to the policy which must be satisfied for the associated transaction to be considered valid.</p><p>其中 <code>peer/ChaincodeToChaincode</code> 表示受保护的资源， <code>/Channel/Application/Readers</code>是指必须满足的策略，关联交易才被视为有效。</p><p>For a deeper dive into ACLS, refer to the topic in the Operations Guide on <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/access_control.html" target="_blank" rel="noopener">ACLs</a>.</p><p>要深入了解ACLS，请参阅<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/access_control.html" target="_blank" rel="noopener">ACLs</a>的操作指南中的主题。</p><h3 id="Smart-contract-endorsement-policies（智能合约的背书策略）">Smart contract endorsement policies（智能合约的背书策略）</h3><p>Every smart contract inside a chaincode package has an endorsement policy that specifies how many peers belonging to different channel members need to execute and validate a transaction against a given smart contract in order for the transaction to be considered valid. Hence, the endorsement policies define the organizations (through their peers) who must “endorse” (i.e., approve of) the execution of a proposal.</p><p>链码包里面的每个智能合约都有一个背书策略，这个背书策略指定了需要多少个来自不同通道成员的peer节点需要针对给定的智能合约执行和验证交易，以便该交易被视为有效。因此，背书政策定义了必须“背书”（即批准）提案执行的组织（通过其peer）。</p><h3 id="Modification-policies（修改政策）">Modification policies（修改政策）</h3><p>There is one last type of policy that is crucial to how policies work in Fabric, the <code>Modification policy</code>. Modification policies specify the group of identities required to sign (approve) any configuration <em>update</em>. It is the policy that defines how the policy is updated. Thus, each channel configuration element includes a reference to a policy which governs its modification.</p><p>最后一种策略对于Fabric中的策略工作至关重要，即<code>Modification policy</code>。修改策略指定了任何配置更新时需要签名（批准）的一组身份。该策略定义了如何更新策略。因此，每个通道配置元素都包含一个对管理其修改的策略的引用。</p><h2 id="The-Fabric-policy-domains">The Fabric policy domains</h2><p>While Fabric policies are flexible and can be configured to meet the needs of a network, the policy structure naturally leads to a division between the domains governed by either the Ordering Service organizations or the members of the consortium. In the following diagram you can see how the default policies implement control over the Fabric policy domains below.</p><p>虽然Fabric的策略是灵活的，可以配置为满足网络需求，但是策略结构自然会导致由排序服务组织或联盟成员管理的域之间的划分。在下图中你会看到默认策略是如何实现对结构策略域的控制。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/FabricPolicyHierarchy-4.png" alt="FabricPolicyHierarchy-4"></p><p><em>A more detailed look at the policy domains governed by the Orderer organizations and consortium organizations.</em></p><p><em>更详细地了解由订购者组织和财团组织管理的策略域。</em></p><p>A fully functional Fabric network can feature many organizations with different responsibilities. The domains provide the ability to extend different privileges and roles to different organizations by allowing the founders of the ordering service the ability to establish the initial rules and membership of the consortium. They also allow the organizations that join the consortium to create private application channels, govern their own business logic, and restrict access to the data that is put on the network.</p><p>功能齐全的Fabric网络可以使许多个组织承担不同的职责。域通过允许排序服务的创建者建立联盟的初始规则和成员资格的能力来提供将不同的特权和角色扩展到不同组织的能力。域还允许加入该联盟的组织创建私有应用程序通道，管理他们自己的业务逻辑，并限制对网络上放置的数据的访问。</p><p>The system channel configuration and a portion of each application channel configuration provides the ordering organizations control over which organizations are members of the consortium, how blocks are delivered to channels, and the consensus mechanism used by the nodes of the ordering service.</p><p>系统通道配置和每个应用程序通道配置的一部分为排序组织提供了控制，这些组织可以控制哪些组织是联盟的成员，如何将区块交付到渠道以及排序服务的节点所使用的共识机制。</p><p>The system channel configuration provides members of the consortium the ability to create channels. Application channels and ACLs are the mechanism that consortium organizations use to add or remove members from a channel and restrict access to data and smart contracts on a channel.</p><p>系统通道提供了哪些联盟的成员有能力创建通道。系统通道和ACL是联盟组织用于在通道中添加或删除成员并限制对通道上数据和智能合约的访问的机制。</p><h2 id="How-do-you-write-a-policy-in-Fabric">How do you write a policy in Fabric</h2><p>If you want to change anything in Fabric, the policy associated with the resource describes <strong>who</strong> needs to approve it, either with an explicit sign off from individuals, or an implicit sign off by a group. In the insurance domain, an explicit sign off could be a single member of the homeowners insurance agents group. And an implicit sign off would be analogous to requiring approval from a majority of the managerial members of the homeowners insurance group. This is particularly useful because the members of that group can change over time without requiring that the policy be updated. In Hyperledger Fabric, explicit sign offs in policies are expressed using the <code>Signature</code> syntax and implicit sign offs use the <code>ImplicitMeta</code> syntax.</p><p>如果要更改Fabric中的任何内容，则与资源相关联的策略描述了谁需要批准它，可以是个人的显示签名，也可以是组的隐式签名。在保险领域，显示签名可以是房主保险代理人组的单个成员。隐式签名类似于要求房主保险集团的大多数管理人员批准。这特别有用，因为该组的成员可以随时间变化而无需更新策略。在Hyperledger Fabric中，策略中的显式签名使用<code>Signature</code>语法表示，而隐式签名使用<code>ImplicitMeta</code>语法。</p><h3 id="Signature-policies">Signature policies</h3><p><code>Signature</code> policies define specific types of users who must sign in order for a policy to be satisfied such as <code>OR('Org1.peer', 'Org2.peer')</code>. These policies are considered the most versatile because they allow for the construction of extremely specific rules like: “An admin of org A and 2 other admins, or 5 of 6 organization admins”. The syntax supports arbitrary combinations of <code>AND</code>, <code>OR</code> and <code>NOutOf</code>. For example, a policy can be easily expressed by using <code>AND('Org1.member', 'Org2.member')</code> which means that a signature from at least one member in Org1 AND one member in Org2 is required for the policy to be satisfied.</p><p><code>Signature</code> 策略定义了必须由指定类型的用户签名才能满足策略，例如 <code>OR('Org1.peer', 'Org2.peer')</code>。这些策略被认为是最通用的，因为它们允许构建极其特定的规则，例如：“组织A的一个管理员和2个其他管理员，或6个组织中的5个管理员”。</p><h3 id="ImplicitMeta-policies">ImplicitMeta policies</h3><p><code>ImplicitMeta</code> policies are only valid in the context of channel configuration which is based on a tiered hierarchy of policies in a configuration tree. ImplicitMeta policies aggregate the result of policies deeper in the configuration tree that are ultimately defined by Signature policies. They are <code>Implicit</code> because they are constructed implicitly based on the current organizations in the channel configuration, and they are <code>Meta</code> because their evaluation is not against specific MSP principals, but rather against other sub-policies below them in the configuration tree.</p><p><code>ImplicitMeta</code> 策略仅在通道配置的上下文中有效，该配置基于配置树中策略的分层层次结构。<code> ImplicitMeta</code>策略将在配置树中更深的策略的结果汇总在一起，这些策略最终由签名策略定义。它们是<code>Implicit</code>的，因为它们是基于渠道配置中的当前组织隐式构造的，之所以称为<code>Meta</code>，是因为它们的评估不是针对特定的MSP主体，而是针对配置树中位于其下方的其他子策略。</p><p>The following diagram illustrates the tiered policy structure for an application channel and shows how the <code>ImplicitMeta</code> channel configuration admins policy, named <code>/Channel/Admins</code>, is resolved when the sub-policies named <code>Admins</code> below it in the configuration hierarchy are satisfied where each check mark represents that the conditions of the sub-policy were satisfied.</p><p>下图说明了应用程序通道的分层策略结构,并显示名为 <code>/Channel/Admins</code>的 <code>ImplicitMeta</code> 通道配置管理员策略，当满足配置层次结构中位于其下方的名为<code>Admins</code>的子策略时，将解决此问题，其中每个复选标记表示已满足该子策略的条件。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/FabricPolicyHierarchy-6.png" alt="FabricPolicyHierarchy-6"></p><p>As you can see in the diagram above, <code>ImplicitMeta</code> policies, Type = 3, use a different syntax, <code>&quot;&lt;ANY|ALL|MAJORITY&gt; &lt;SubPolicyName&gt;&quot;</code>, for example:</p><p>如上图所示，<code>ImplicitMeta</code> 策略， Type = 3，使用不同的语法<code>&quot;&lt;ANY|ALL|MAJORITY&gt; &lt;SubPolicyName&gt;&quot;</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;MAJORITY sub policy: Admins&#96;</span><br></pre></td></tr></table></figure><p>The diagram shows a sub-policy <code>Admins</code>, which refers to all the <code>Admins</code> policy below it in the configuration tree. You can create your own sub-policies and name them whatever you want and then define them in each of your organizations.</p><p>该图显示了一个子策略<code>Admins</code>，它引用配置树中其下方的所有<code>Admins</code>策略。您可以创建自己的子策略，并根据需要命名它们，然后在你的每个组织中对其进行定义。</p><p>As mentioned above, a key benefit of an <code>ImplicitMeta</code> policy such as <code>MAJORITY Admins</code> is that when you add a new admin organization to the channel, you do not have to update the channel policy. Therefore <code>ImplicitMeta</code> policies are considered to be more flexible as the consortium members change. The consortium on the orderer can change as new members are added or an existing member leaves with the consortium members agreeing to the changes, but no policy updates are required. Recall that <code>ImplicitMeta</code> policies ultimately resolve the <code>Signature</code> sub-policies underneath them in the configuration tree as the diagram shows.</p><p>如上所述，<code>ImplicitMeta</code>策略（例如<code>MAJORITY Admins</code>）的主要优势在于，当您向通道添加新的管理员组织时，不必更新频道策略。因此，随着联盟成员的变化，<code>ImplicitMeta</code>策略被认为更加灵活。当添加新成员或现有成员离开时，排序者上的联盟可以更改，联盟成员同意更改，但是不需要更新策略。回想一下，<code>ImplicitMeta</code>策略最终在配置树中解决了其下方的<code>Signature</code>子策略，如图所示。</p><p>You can also define an application level implicit policy to operate across organizations, in a channel for example, and either require that ANY of them are satisfied, that ALL are satisfied, or that a MAJORITY are satisfied. This format lends itself to much better, more natural defaults, so that each organization can decide what it means for a valid endorsement.</p><p>您还可以定义一个应用程序级别的隐式策略，以在组织中（例如，在一个通道中）进行操作，并要求满足它们中的任何一个，满足所有条件或满足大多数条件。这种格式适合于更好，更自然的默认设置，以便每个组织可以决定对有效背书的含义。</p><p>Further granularity and control can be achieved if you include <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/policies/msp.html#organizational-units" target="_blank" rel="noopener"><code>NodeOUs</code></a> in your organization definition. Organization Units (OUs) are defined in the Fabric CA client configuration file and can be associated with an identity when it is created. In Fabric, <code>NodeOUs</code> provide a way to classify identities in a digital certificate hierarchy. For instance, an organization having specific <code>NodeOUs</code> enabled could require that a ‘peer’ sign for it to be a valid endorsement, whereas an organization without any might simply require that any member can sign.</p><p>如果在组织定义中包含<code>NodeOU</code>，则可以实现进一步的粒度和控制。组织单位（OU）在Fabric CA客户端配置文件中定义，并且在创建时可以与身份相关联。NodeOU提供了一种在数字证书层次结构中对身份进行分类的方法。例如，启用了特定<code>NodeOU</code>的组织可能要求“peer”标志才能有效地背书，而只有组织而不包含任何其他可能只要求任何成员都可以签名。</p><h2 id="An-example-channel-configuration-policy">An example: channel configuration policy</h2><p>Understanding policies begins with examining the <code>configtx.yaml</code> where the channel policies are defined. We can use the <code>configtx.yaml</code> file in the Fabric test network to see examples of both policy syntax types. We are going to examine the configtx.yaml file used by the <a href="https://github.com/hyperledger/fabric-samples/blob/release-2.2/test-network/configtx/configtx.yaml" target="_blank" rel="noopener">fabric-samples/test-network</a> sample.</p><p>The first section of the file defines the organizations of the network. Inside each organization definition are the default policies for that organization, <code>Readers</code>, <code>Writers</code>, <code>Admins</code>, and <code>Endorsement</code>, although you can name your policies anything you want. Each policy has a <code>Type</code> which describes how the policy is expressed (<code>Signature</code> or <code>ImplicitMeta</code>) and a <code>Rule</code>.</p><p>The test network example below shows the Org1 organization definition in the system channel, where the policy <code>Type</code> is <code>Signature</code> and the endorsement policy rule is defined as <code>&quot;OR('Org1MSP.peer')&quot;</code>. This policy specifies that a peer that is a member of <code>Org1MSP</code> is required to sign. It is these signature policies that become the sub-policies that the ImplicitMeta policies point to.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   SECTION: Application</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   - This section defines the values to encode into a config transaction or</span></span><br><span class="line"><span class="comment">#   genesis block for application related parameters</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="attr">Application:</span> <span class="meta">&amp;ApplicationDefaults</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Organizations is the list of orgs which are defined as participants on</span></span><br><span class="line">    <span class="comment"># the application side of the network</span></span><br><span class="line">    <span class="attr">Organizations:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Policies defines the set of policies at this level of the config tree</span></span><br><span class="line">    <span class="comment"># For Application policies, their canonical path is</span></span><br><span class="line">    <span class="comment">#   /Channel/Application/&lt;PolicyName&gt;</span></span><br><span class="line">    <span class="attr">Policies:</span></span><br><span class="line">        <span class="attr">Readers:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"ANY Readers"</span></span><br><span class="line">        <span class="attr">Writers:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"ANY Writers"</span></span><br><span class="line">        <span class="attr">Admins:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"MAJORITY Admins"</span></span><br><span class="line">        <span class="attr">LifecycleEndorsement:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"MAJORITY Endorsement"</span></span><br><span class="line">        <span class="attr">Endorsement:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"MAJORITY Endorsement"</span></span><br></pre></td></tr></table></figure><p>The next example shows the <code>ImplicitMeta</code> policy type used in the <code>Application</code> section of the <code>configtx.yaml</code>. These set of policies lie on the <code>/Channel/Application/</code> path. If you use the default set of Fabric ACLs, these policies define the behavior of many important features of application channels, such as who can query the channel ledger, invoke a chaincode, or update a channel config. These policies point to the sub-policies defined for each organization. The Org1 defined in the section above contains <code>Reader</code>, <code>Writer</code>, and <code>Admin</code> sub-policies that are evaluated by the <code>Reader</code>, <code>Writer</code>, and <code>Admin</code> <code>ImplicitMeta</code> policies in the <code>Application</code> section. Because the test network is built with the default policies, you can use the example Org1 to query the channel ledger, invoke a chaincode, and approve channel updates for any test network channel that you create.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   SECTION: Application</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   - This section defines the values to encode into a config transaction or</span></span><br><span class="line"><span class="comment">#   genesis block for application related parameters</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="attr">Application:</span> <span class="meta">&amp;ApplicationDefaults</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Organizations is the list of orgs which are defined as participants on</span></span><br><span class="line">    <span class="comment"># the application side of the network</span></span><br><span class="line">    <span class="attr">Organizations:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Policies defines the set of policies at this level of the config tree</span></span><br><span class="line">    <span class="comment"># For Application policies, their canonical path is</span></span><br><span class="line">    <span class="comment">#   /Channel/Application/&lt;PolicyName&gt;</span></span><br><span class="line">    <span class="attr">Policies:</span></span><br><span class="line">        <span class="attr">Readers:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"ANY Readers"</span></span><br><span class="line">        <span class="attr">Writers:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"ANY Writers"</span></span><br><span class="line">        <span class="attr">Admins:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"MAJORITY Admins"</span></span><br><span class="line">        <span class="attr">LifecycleEndorsement:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"MAJORITY Endorsement"</span></span><br><span class="line">        <span class="attr">Endorsement:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"MAJORITY Endorsement"</span></span><br></pre></td></tr></table></figure><h2 id="Fabric-chaincode-lifecycle">Fabric chaincode lifecycle</h2><p>In the Fabric 2.0 release, a new chaincode lifecycle process was introduced, whereby a more democratic process is used to govern chaincode on the network. The new process allows multiple organizations to vote on how a chaincode will be operated before it can be used on a channel. This is significant because it is the combination of this new lifecycle process and the policies that are specified during that process that dictate the security across the network. More details on the flow are available in the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/chaincode_lifecycle.html" target="_blank" rel="noopener">Fabric chaincode lifecycle</a> concept topic, but for purposes of this topic you should understand how policies are used in this flow. The new flow includes two steps where policies are specified: when chaincode is <strong>approved</strong> by organization members, and when it is <strong>committed</strong> to the channel.</p><p>The <code>Application</code> section of the <code>configtx.yaml</code> file includes the default chaincode lifecycle endorsement policy. In a production environment you would customize this definition for your own use case.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   SECTION: Application</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   - This section defines the values to encode into a config transaction or</span></span><br><span class="line"><span class="comment">#   genesis block for application related parameters</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="attr">Application:</span> <span class="meta">&amp;ApplicationDefaults</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Organizations is the list of orgs which are defined as participants on</span></span><br><span class="line">    <span class="comment"># the application side of the network</span></span><br><span class="line">    <span class="attr">Organizations:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Policies defines the set of policies at this level of the config tree</span></span><br><span class="line">    <span class="comment"># For Application policies, their canonical path is</span></span><br><span class="line">    <span class="comment">#   /Channel/Application/&lt;PolicyName&gt;</span></span><br><span class="line">    <span class="attr">Policies:</span></span><br><span class="line">        <span class="attr">Readers:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"ANY Readers"</span></span><br><span class="line">        <span class="attr">Writers:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"ANY Writers"</span></span><br><span class="line">        <span class="attr">Admins:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"MAJORITY Admins"</span></span><br><span class="line">        <span class="attr">LifecycleEndorsement:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"MAJORITY Endorsement"</span></span><br><span class="line">        <span class="attr">Endorsement:</span></span><br><span class="line">            <span class="attr">Type:</span> <span class="string">ImplicitMeta</span></span><br><span class="line">            <span class="attr">Rule:</span> <span class="string">"MAJORITY Endorsement"</span></span><br></pre></td></tr></table></figure><ul><li><p>The <code>LifecycleEndorsement</code> policy governs who needs to <em>approve a chaincode definition</em>.</p><p><code>LifecycleEndorsement</code> 策略管理谁需要批准链码定义</p></li><li><p>The <code>Endorsement</code> policy is the <em>default endorsement policy for a chaincode</em>. More on this below.</p><p><code>Endorsement</code>策略是链码的默认背书策略，详情在下面。</p></li></ul><h2 id="Chaincode-endorsement-policies">Chaincode endorsement policies</h2><p>The endorsement policy is specified for a <strong>chaincode</strong> when it is approved and committed to the channel using the Fabric chaincode lifecycle (that is, one endorsement policy covers all of the state associated with a chaincode). The endorsement policy can be specified either by reference to an endorsement policy defined in the channel configuration or by explicitly specifying a Signature policy.</p><p>在使用Fabric链码生命周期批准链码并将其提交给通道时便指定了链码的背书策略（即，一种背书策略涵盖了与链码相关联的所有状态）。可以通过参考在通道配置中定义的背书策略来指定背书策略，也可以通过显式指定签名策略来指定背书策略。</p><p>If an endorsement policy is not explicitly specified during the approval step, the default <code>Endorsement</code> policy <code>&quot;MAJORITY Endorsement&quot;</code> is used which means that a majority of the peers belonging to the different channel members (organizations) need to execute and validate a transaction against the chaincode in order for the transaction to be considered valid. This default policy allows organizations that join the channel to become automatically added to the chaincode endorsement policy. If you don’t want to use the default endorsement policy, use the Signature policy format to specify a more complex endorsement policy (such as requiring that a chaincode be endorsed by one organization, and then one of the other organizations on the channel).</p><p>Signature policies also allow you to include <code>principals</code> which are simply a way of matching an identity to a role. Principals are just like user IDs or group IDs, but they are more versatile because they can include a wide range of properties of an actor’s identity, such as the actor’s organization, organizational unit, role or even the actor’s specific identity. When we talk about principals, they are the properties which determine their permissions. Principals are described as ‘MSP.ROLE’, where <code>MSP</code> represents the required MSP ID (the organization), and <code>ROLE</code> represents one of the four accepted roles: Member, Admin, Client, and Peer. A role is associated to an identity when a user enrolls with a CA. You can customize the list of roles available on your Fabric CA.</p><p>Some examples of valid principals are:</p><ul><li>‘Org0.Admin’: an administrator of the Org0 MSP</li><li>‘Org1.Member’: a member of the Org1 MSP</li><li>‘Org1.Client’: a client of the Org1 MSP</li><li>‘Org1.Peer’: a peer of the Org1 MSP</li><li>‘OrdererOrg.Orderer’: an orderer in the OrdererOrg MSP</li></ul><p>There are cases where it may be necessary for a particular state (a particular key-value pair, in other words) to have a different endorsement policy. This <strong>state-based endorsement</strong> allows the default chaincode-level endorsement policies to be overridden by a different policy for the specified keys.</p><p>For a deeper dive on how to write an endorsement policy refer to the topic on <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/endorsement-policies.html" target="_blank" rel="noopener">Endorsement policies</a> in the Operations Guide.</p><p><strong>Note:</strong> Policies work differently depending on which version of Fabric you are using:</p><ul><li>In Fabric releases prior to 2.0, chaincode endorsement policies can be updated during chaincode instantiation or by using the chaincode lifecycle commands. If not specified at instantiation time, the endorsement policy defaults to “any member of the organizations in the channel”. For example, a channel with “Org1” and “Org2” would have a default endorsement policy of “OR(‘Org1.member’, ‘Org2.member’)”.</li><li>Starting with Fabric 2.0, Fabric introduced a new chaincode lifecycle process that allows multiple organizations to agree on how a chaincode will be operated before it can be used on a channel. The new process requires that organizations agree to the parameters that define a chaincode, such as name, version, and the chaincode endorsement policy.</li></ul><h2 id="Overriding-policy-definitions">Overriding policy definitions</h2><p>Hyperledger Fabric includes default policies which are useful for getting started, developing, and testing your blockchain, but they are meant to be customized in a production environment. You should be aware of the default policies in the <code>configtx.yaml</code> file. Channel configuration policies can be extended with arbitrary verbs, beyond the default <code>Readers, Writers, Admins</code> in <code>configtx.yaml</code>. The orderer system and application channels are overridden by issuing a config update when you override the default policies by editing the <code>configtx.yaml</code> for the orderer system channel or the <code>configtx.yaml</code> for a specific channel.</p><p>See the topic on <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#updating-a-channel-configuration" target="_blank" rel="noopener">Updating a channel configuration</a> for more information.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;What-is-a-policy&quot;&gt;What is a policy&lt;/h2&gt;
&lt;p&gt;At its most basic level, a policy is a set of rules that define the structure for how dec</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="Key Concepts" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/Key-Concepts/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="Policies" scheme="https://guozhe001.github.io/tags/Policies/"/>
    
  </entry>
  
  <entry>
    <title>Membership Service Provider (MSP)</title>
    <link href="https://guozhe001.github.io/2021/01/18/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/MSP/"/>
    <id>https://guozhe001.github.io/2021/01/18/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/MSP/</id>
    <published>2021-01-18T06:49:51.734Z</published>
    <updated>2021-01-19T10:59:19.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why-do-I-need-an-MSP-（为什么我需要MSP）">Why do I need an MSP?（为什么我需要MSP）</h2><p>Because Fabric is a permissioned network, blockchain participants need a way to prove their identity to the rest of the network in order to transact on the network. If you’ve read through the documentation on <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/identity/identity.html" target="_blank" rel="noopener">Identity</a> you’ve seen how a Public Key Infrastructure (PKI) can provide verifiable identities through a chain of trust. How is that chain of trust used by the blockchain network?</p><p>因为Fabric是一个许可形式的网络，区块链参与者需要一种向网络其他成员证明自己身份的方法，以便在网络上进行交易。如果你已经阅读了 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/identity/identity.html" target="_blank" rel="noopener">Identity</a> 文档，你已经看到PKI如何通过信任链提供可验证的身份。区块链网络如何使用该信任链？</p><p>Certificate Authorities issue identities by generating a public and private key which forms a key-pair that can be used to prove identity. Because a private key can never be shared publicly, a mechanism is required to enable that proof which is where the MSP comes in. For example, a peer uses its private key to digitally sign, or endorse, a transaction. The MSP on the ordering service contains the peer’s public key which is then used to verify that the signature attached to the transaction is valid. The private key is used to produce a signature on a transaction that only the corresponding public key, that is part of an MSP, can match. Thus, the MSP is the mechanism that allows that identity to be trusted and recognized by the rest of the network without ever revealing the member’s private key.</p><p>证书颁发机构通过生成公钥和私钥来颁发身份，该公钥和私钥形成可用于证明身份的密钥对。由于永远不能公开共享私钥，因此需要一种机制来证明他是谁，然后MSP就是做这件事的。例如一个peer节点是用他自己的私钥来签名或者背书一个交易。排序服务的MSP包含了peer节点的公钥，该公钥随后用于验证附加到交易的签名是否有效。私钥用于在交易上产生签名，只有相应的公钥（MSP的一部分）才能匹配该签名。因此，MSP是一种允许身份由网络的其余部分信任和识别，而无需透露成员的私钥的机制。</p><p>Recall from the credit card scenario in the Identity topic that the Certificate Authority is like a card provider — it dispenses many different types of verifiable identities. An MSP, on the other hand, determines which credit card providers are accepted at the store. In this way, the MSP turns an identity (the credit card) into a role (the ability to buy things at the store).</p><p>从“身份”主题中的信用卡业务情景中回想起，证书颁发机构就像发卡组织一样-它分配了许多不同类型的可验证身份。另一方面，MSP确定商店接受哪些信用卡发卡组织。这样，MSP将身份（信用卡）转变为角色（在商店购买商品的能力）。</p><p>This ability to turn verifiable identities into roles is fundamental to the way Fabric networks function, since it allows organizations, nodes, and channels the ability establish MSPs that determine who is allowed to do what at the organization, node, and channel level.</p><p>这种将可验证身份转换为角色的能力是Fabric网络运行方式的基础，因为它允许组织，节点和渠道具备建立MSP的能力，从而确定允许谁在组织，节点和渠道级别上做什么。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/membership.msp.diagram.png" alt="membership.msp.diagram"></p><p><em>Identities are similar to your credit cards that are used to prove you can pay. The MSP is similar to the list of accepted credit cards.</em></p><p>Consider a consortium of banks that operate a blockchain network. Each bank operates peer and ordering nodes, and the peers endorse transactions submitted to the network. However, each bank would also have departments and account holders. The account holders would belong to each organization, but would not run nodes on the network. They would only interact with the system from their mobile or web application. So how does the network recognize and differentiate these identities? A CA was used to create the identities, but like the card example, those identities can’t just be issued, they need to be recognized by the network. MSPs are used to define the organizations that are trusted by the network members. MSPs are also the mechanism that provide members with a set of roles and permissions within the network. Because the MSPs defining these organizations are known to the members of a network, they can then be used to validate that network entities that attempt to perform actions are allowed to.</p><p>考虑一个经营区块链网络的银行联盟。每个银行都操作peer节点和排序节点，并且peer节点认可提交给网络的交易。但是每个银行也同样有部门和账户持有者。帐户持有者将属于各自的组织，但不会在网络上运行节点。他们只能通过其移动或Web应用程序与系统进行交互。那么网络如何识别和区分这些身份呢？可以使用CA来创建身份，但是就像卡片示例一样，不能仅仅是颁发了身份，还必须由网络来识别这些身份。MSP用于定义网络成员信任的组织。MSP还是一个机制，这个机制为成员提供网络中的一组角色和权限。由于MSP定义的这些组织对网络成员而言是已知的，因此它们可以用于验证允许尝试执行操作的网络实体。</p><p>Finally, consider if you want to join an <em>existing</em> network, you need a way to turn your identity into something that is recognized by the network. The MSP is the mechanism that enables you to participate on a permissioned blockchain network. To transact on a Fabric network a member needs to:</p><ol><li>Have an identity issued by a CA that is trusted by the network.</li><li>Become a member of an <em>organization</em> that is recognized and approved by the network members. The MSP is how the identity is linked to the membership of an organization. Membership is achieved by adding the member’s public key (also known as certificate, signing cert, or signcert) to the organization’s MSP.</li><li>Add the MSP to either a <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#consortium" target="_blank" rel="noopener">consortium</a> on the network or a channel.</li><li>Ensure the MSP is included in the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/policies/policies.html" target="_blank" rel="noopener">policy</a> definitions on the network.</li></ol><p>最后，考虑如果你想要加入一个现有网络，你需要一个方法来将你的身份转换为网络可识别的内容。MSP是使您能够参与许可的区块链网络的机制。为了在Fabric的网络上进行交易，一个成员需要：</p><ol><li>具有由网络信任的CA颁发的身份。</li><li>成为由网络成员认可并批准的组织的成员。MSP是将身份链接到组织成员的方式。成员资格是通过将成员的公钥（也称为证书，签名证书或signcert）添加到组织的MSP中来实现的。</li><li>将MSP添加到网络上的联盟或通道上。</li><li>确保MSP包含在网络上定义的策略。</li></ol><h2 id="What-is-an-MSP">What is an MSP?</h2><p>Despite its name, the Membership Service Provider does not actually provide anything. Rather, the implementation of the MSP requirement is a set of folders that are added to the configuration of the network and is used to define an organization both inwardly (organizations decide who its admins are) and outwardly (by allowing other organizations to validate that entities have the authority to do what they are attempting to do). Whereas Certificate Authorities generate the certificates that represent identities, the MSP contains a list of permissioned identities.</p><p>The MSP identifies which Root CAs and Intermediate CAs are accepted to define the members of a trust domain by listing the identities of their members, or by identifying which CAs are authorized to issue valid identities for their members.</p><p>But the power of an MSP goes beyond simply listing who is a network participant or member of a channel. It is the MSP that turns an identity into a <strong>role</strong> by identifying specific privileges an actor has on a node or channel. Note that when a user is registered with a Fabric CA, a role of admin, peer, client, orderer, or member must be associated with the user. For example, identities registered with the “peer” role should, naturally, be given to a peer. Similarly, identities registered with the “admin” role should be given to organization admins. We’ll delve more into the significance of these roles later in the topic.</p><p>In addition, an MSP can allow for the identification of a list of identities that have been revoked — as discussed in the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/identity/identity.html" target="_blank" rel="noopener">Identity</a> documentation — but we will talk about how that process also extends to an MSP.</p><h2 id="MSP-domains">MSP domains</h2><p>MSPs occur in two domains in a blockchain network:</p><ul><li>Locally on an actor’s node (<strong>local MSP</strong>)</li><li>In channel configuration (<strong>channel MSP</strong>)</li></ul><p>The key difference between local and channel MSPs is not how they function – both turn identities into roles – but their <strong>scope</strong>. Each MSP lists roles and permissions at a particular level of administration.</p><p>本地MSP和通道MSP之间的主要区别不是它们的功能（两者都将身份转换为角色），而是它们的范围。每个MSP都列出特定管理级别的角色和权限。</p><h3 id="Local-MSPs">Local MSPs</h3><p><strong>Local MSPs are defined for clients and for nodes (peers and orderers)</strong>. Local MSPs define the permissions for a node (who are the peer admins who can operate the node, for example). The local MSPs of clients (the account holders in the banking scenario above), allow the user to authenticate itself in its transactions as a member of a channel (e.g. in chaincode transactions), or as the owner of a specific role into the system such as an organization admin, for example, in configuration transactions.</p><p><strong>Local MSPs</strong>是为客户端和节点（peers和订orderers）定义的。本地MSP定义了一个节点的权限（例如谁是peer的管理员，谁可以操作这个节点）。客户端的本地MSP（上述银行业务场景中的帐户持有人）允许用户在自身交易中作为通道成员进行身份验证（例如在链码中交易中），或者作为系统中特定角色（例如组织管理员）的所有者，例如，在配置事务中。</p><p><strong>Every node must have a local MSP defined</strong>, as it defines who has administrative or participatory rights at that level (peer admins will not necessarily be channel admins, and vice versa). This allows for authenticating member messages outside the context of a channel and to define the permissions over a particular node (who has the ability to install chaincode on a peer, for example). Note that one or more nodes can be owned by an organization. An MSP defines the organization admins. And the organization, the admin of the organization, the admin of the node, and the node itself should all have the same root of trust.</p><p><strong>每个节点都需要定义一个本地的MSP</strong>，因为它定义了在该级别具有管理或参与权的人（peer管理员不一定是通道管理员，反之亦然）。这允许在通道上下文之外对成员消息进行身份验证，并定义对特定节点的权限（如谁有能力在peer上安装链码）。请注意，一个组织可以拥有一个或多个节点。MSP定义组织管理员。组织、组织的管理员、节点的管理员以及节点本身都应具有相同的根CA。</p><p>An orderer local MSP is also defined on the file system of the node and only applies to that node. Like peer nodes, orderers are also owned by a single organization and therefore have a single MSP to list the actors or nodes it trusts.</p><p>在排序者节点的文件系统上也定义了本地MSP，它仅适用于该节点。就像peer节点一样，排序者由单个组织拥有，因此有一个MSP列出其信任的参与者或节点。</p><h3 id="Channel-MSPs">Channel MSPs</h3><p>In contrast, <strong>channel MSPs define administrative and participatory rights at the channel level</strong>. Peers and ordering nodes on an application channel share the same view of channel MSPs, and will therefore be able to correctly authenticate the channel participants. This means that if an organization wishes to join the channel, an MSP incorporating the chain of trust for the organization’s members would need to be included in the channel configuration. Otherwise transactions originating from this organization’s identities will be rejected. Whereas local MSPs are represented as a folder structure on the file system, channel MSPs are described in a channel configuration.</p><p>相反，<strong>通道MSP在通道级别定义了管理权和参与权</strong>。应用程序通道上的peer节点和排序节点共享通道MSP的相同视图，因此将能够正确地验证通道参与者。这意味着如果组织希望加入通道，则需要在通道配置中包含一个包含组织成员信任链的MSP。否则，来自该组织身份的交易将被拒绝。本地MSP在文件系统上表示为文件夹结构，而通道MSP则在通道配置中描述。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/ChannelMSP.png" alt="ChannelMSP"></p><p><em>Snippet from a channel config.json file that includes two organization MSPs.</em></p><p><strong>Channel MSPs identify who has authorities at a channel level</strong>. The channel MSP defines the <em>relationship</em> between the identities of channel members (which themselves are MSPs) and the enforcement of channel level policies. Channel MSPs contain the MSPs of the organizations of the channel members.</p><p>**通道MSP识别谁拥有通道级别的权限。**通道MSP定义了通道成员身份（本身就是MSP）和通道级策略执行之间的关系。通道MSP包含通道成员组织的MSP。</p><p><strong>Every organization participating in a channel must have an MSP defined for it</strong>. In fact, it is recommended that there is a one-to-one mapping between organizations and MSPs. The MSP defines which members are empowered to act on behalf of the organization. This includes configuration of the MSP itself as well as approving administrative tasks that the organization has role, such as adding new members to a channel. If all network members were part of a single organization or MSP, data privacy is sacrificed. Multiple organizations facilitate privacy by segregating ledger data to only channel members. If more granularity is required within an organization, the organization can be further divided into organizational units (OUs) which we describe in more detail later in this topic.</p><p>**每个参与渠道的组织都必须为其定义MSP。**实际上，建议组织与MSP之间存在一对一的映射。MSP定义了哪些成员有权代表组织行事。这包括MSP本身的配置以及批准组织所扮演的管理任务，例如将新成员添加到渠道。如果所有网络成员都是单个组织或MSP的一部分，则会牺牲数据隐私。多个组织通过将账本数据仅隔离到通道成员来促成隐私。如果在组织内需要更多的粒度，则可以将组织进一步划分为组织单位（OU），我们将在本主题的后面部分对此进行详细介绍。</p><p><strong>The system channel MSP includes the MSPs of all the organizations that participate in an ordering service.</strong> An ordering service will likely include ordering nodes from multiple organizations and collectively these organizations run the ordering service, most importantly managing the consortium of organizations and the default policies that are inherited by the application channels.</p><p>**系统通道MSP包括加入排序服务的所有组织的MSP。**排序服务可能会包括来自多个组织的排序节点，并且这些组织共同运行排序服务，最重要的是管理组织联盟和应用程序通道继承的默认策略。</p><p><strong>Local MSPs are only defined on the file system of the node or user</strong> to which they apply. Therefore, physically and logically there is only one local MSP per node. However, as channel MSPs are available to all nodes in the channel, they are logically defined once in the channel configuration. However, <strong>a channel MSP is also instantiated on the file system of every node in the channel and kept synchronized via consensus</strong>. So while there is a copy of each channel MSP on the local file system of every node, logically a channel MSP resides on and is maintained by the channel or the network.</p><p>**本地MSP仅在它们应用到的节点或用户的文件系统上定义。**因此，在物理上和逻辑上每个节点只有一个本地MSP。但是，由于通道MSP可用于通道中的所有节点，因此它们在通道配置中被逻辑定义一次。但是，<strong>通道MSP也会在该通道中每个节点的文件系统上实例化，并通过共识保持同步</strong>。因此，尽管每个节点的本地文件系统上都有每个通道MSP的副本，但从逻辑上讲，通道MSP驻留在通道或网络上并由通道或网络维护。</p><p>The following diagram illustrates how local and channel MSPs coexist on the network:</p><p>下图说明了本地和通道MSP在网络上如何共存：</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/membership.diagram.2.png" alt="membership.diagram.2"></p><p><em>The MSPs for the peer and orderer are local, whereas the MSPs for a channel (including the network configuration channel, also known as the system channel) are global, shared across all participants of that channel. In this figure, the network system channel is administered by ORG1, but another application channel can be managed by ORG1 and ORG2. The peer is a member of and managed by ORG2, whereas ORG1 manages the orderer of the figure. ORG1 trusts identities from RCA1, whereas ORG2 trusts identities from RCA2. It is important to note that these are administration identities, reflecting who can administer these components. So while ORG1 administers the network, ORG2.MSP does exist in the network definition.</em></p><h2 id="What-role-does-an-organization-play-in-an-MSP-（组织在MSP中扮演什么角色？）">What role does an organization play in an MSP?（组织在MSP中扮演什么角色？）</h2><p>An <strong>organization</strong> is a logical managed group of members. This can be something as big as a multinational corporation or a small as a flower shop. What’s most important about organizations (or <strong>orgs</strong>) is that they manage their members under a single MSP. The MSP allows an identity to be linked to an organization. Note that this is different from the organization concept defined in an X.509 certificate, which we mentioned above.</p><p>组织是成员的逻辑托管组。它可以像跨国公司一样大，也可以像花店一样小。对于组织而言最重要的是他们在单个MSP下管理成员。MSP允许将身份链接到组织。请注意，这与我们上面提到的X.509证书中定义的组织概念不同。</p><p>The exclusive relationship between an organization and its MSP makes it sensible to name the MSP after the organization, a convention you’ll find adopted in most policy configurations. For example, organization <code>ORG1</code> would likely have an MSP called something like <code>ORG1-MSP</code>. In some cases an organization may require multiple membership groups — for example, where channels are used to perform very different business functions between organizations. In these cases it makes sense to have multiple MSPs and name them accordingly, e.g., <code>ORG2-MSP-NATIONAL</code> and <code>ORG2-MSP-GOVERNMENT</code>, reflecting the different membership roots of trust within <code>ORG2</code> in the <code>NATIONAL</code> sales channel compared to the <code>GOVERNMENT</code> regulatory channel.</p><p>由于组织及其MSP之间的排他关系，因此用组织名称来命名MSP是很明智的，这是大多数策略配置中都会采用的约定。例如组织<code>ORG1</code> 会有一个名为<code>ORG1-MSP</code>的MSP。 在某些情况下组织可能需要多个成员组；例如，在组织之间使用通道执行非常不同的业务功能的情况。在这些情况下，拥有多个MSP并相应地命名它们是很有意义的，，例如<code>ORG2-MSP-NATIONAL</code>和<code>ORG2-MSP-GOVERNMENT</code>，体现出<code>ORG2</code>内部在交易通道和监管通道的两个不同的信任根源。</p><h3 id="Organizational-Units-OUs-and-MSPs（组织单位（OU）和MSP）">Organizational Units (OUs) and MSPs（组织单位（OU）和MSP）</h3><p>An organization can also be divided into multiple <strong>organizational units</strong>, each of which has a certain set of responsibilities, also referred to as <code>affiliations</code>. Think of an OU as a department inside an organization. For example, the <code>ORG1</code> organization might have both <code>ORG1.MANUFACTURING</code> and <code>ORG1.DISTRIBUTION</code> OUs to reflect these separate lines of business. When a CA issues X.509 certificates, the <code>OU</code> field in the certificate specifies the line of business to which the identity belongs. A benefit of using OUs like this is that these values can then be used in policy definitions in order to restrict access or in smart contracts for attribute-based access control. Otherwise, separate MSPs would need to be created for each organization.</p><p>一个组织也可以分为多个组织单位，每个组织单位都有一定的职责集，也称为从属关系。将OU视为组织内部的一个部门。例如，<code>ORG1</code>组织可能同时具有<code>ORG1.MANUFACTURING</code>和<code>ORG1.DISTRIBUTION</code> 两个组织单位，以反映这些单独的业务线。当CA颁发X.509证书时，证书中的<code>OU</code>字段会指定身份所属的业务范围。使用这样的OU的好处是，可将其用于策略定义中以限制访问，或用于基于属性的访问控制的智能合约中。否则，将需要为每个组织创建单独的MSP。</p><p>Specifying OUs is optional. If OUs are not used, all of the identities that are part of an MSP — as identified by the Root CA and Intermediate CA folders — will be considered members of the organization.</p><p>指定OU是可选的。如果不使用OU，则MSP部分的所有身份（由根CA和中级CA文件夹标识）将被视为组织的成员。</p><h3 id="Node-OU-Roles-and-MSPs">Node OU Roles and MSPs</h3><p>Additionally, there is a special kind of OU, sometimes referred to as a <code>Node OU</code>, that can be used to confer a role onto an identity. These Node OU roles are defined in the <code>$FABRIC_CFG_PATH/msp/config.yaml</code> file and contain a list of organizational units whose members are considered to be part of the organization represented by this MSP. This is particularly useful when you want to restrict the members of an organization to the ones holding an identity (signed by one of MSP designated CAs) with a specific Node OU role in it. For example, with node OU’s you can implement a more granular endorsement policy that requires Org1 peers to endorse a transaction, rather than any member of Org1.</p><p>此外，还有一种特殊的OU，有时也称为节点OU，可用于将角色赋予身份。这些节点OU角色在<code>$FABRIC_CFG_PATH/msp/config.yaml</code>文件中定义，并且包含一个组织单位列表，其成员被视为此MSP代表的组织的一部分。当您希望将组织的成员限制为持有具有特定Node OU角色的身份（由MSP指定的CA之一签名）的成员时，此功能特别有用。例如，通过节点OU，您可以实施更精细的认可政策，该政策要求Org1peer认可交易，而不是Org1的任何成员。</p><p>In order to use the Node OU roles, the “identity classification” feature must be enabled for the network. When using the folder-based MSP structure, this is accomplished by enabling “Node OUs” in the config.yaml file which resides in the root of the MSP folder:</p><p>为了使用节点OU角色，必须为网络启用“身份分类”功能。当使用基于文件夹的MSP结构时，可通过启用位于MSP文件夹根目录中的config.yaml文件中的 “Node OUs”来实现</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">NodeOUs:</span></span><br><span class="line">  <span class="attr">Enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ClientOUIdentifier:</span></span><br><span class="line">    <span class="attr">Certificate:</span> <span class="string">cacerts/ca.sampleorg-cert.pem</span></span><br><span class="line">    <span class="attr">OrganizationalUnitIdentifier:</span> <span class="string">client</span></span><br><span class="line">  <span class="attr">PeerOUIdentifier:</span></span><br><span class="line">    <span class="attr">Certificate:</span> <span class="string">cacerts/ca.sampleorg-cert.pem</span></span><br><span class="line">    <span class="attr">OrganizationalUnitIdentifier:</span> <span class="string">peer</span></span><br><span class="line">  <span class="attr">AdminOUIdentifier:</span></span><br><span class="line">    <span class="attr">Certificate:</span> <span class="string">cacerts/ca.sampleorg-cert.pem</span></span><br><span class="line">    <span class="attr">OrganizationalUnitIdentifier:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">OrdererOUIdentifier:</span></span><br><span class="line">    <span class="attr">Certificate:</span> <span class="string">cacerts/ca.sampleorg-cert.pem</span></span><br><span class="line">    <span class="attr">OrganizationalUnitIdentifier:</span> <span class="string">orderer</span></span><br></pre></td></tr></table></figure><p>In the example above, there are 4 possible Node OU <code>ROLES</code> for the MSP:</p><ul><li>client</li><li>peer</li><li>admin</li><li>orderer</li></ul><p>This convention allows you to distinguish MSP roles by the OU present in the CommonName attribute of the X509 certificate. The example above says that any certificate issued by cacerts/ca.sampleorg-cert.pem in which OU=client will identified as a client, OU=peer as a peer, etc. Starting with Fabric v1.4.3, there is also an OU for the orderer and for admins. The new admins role means that you no longer have to explicitly place certs in the admincerts folder of the MSP directory. Rather, the <code>admin</code> role present in the user’s signcert qualifies the identity as an admin user.</p><p>此约定允许您通过X509证书的CommonName属性中存在的OU区分MSP角色。上面的示例表明，由cacerts/ca.sampleorg-cert.pem颁发的证书中，OU=client 将被标识为客户端，OU=peer 将被标识为peer。从Fabric v1.4.3开始，排序者和管理员也有对应的OU。新的管理员角色意味着您不再需要将证书明确放置在MSP目录的admincerts文件夹中；而是用户签名证书中的管理员角色可以将身份标识为管理员用户。</p><p>These Role and OU attributes are assigned to an identity when the Fabric CA or SDK is used to <code>register</code> a user with the CA. It is the subsequent <code>enroll</code> user command that generates the certificates in the users’ <code>/msp</code> folder.</p><p>当使用Fabric的CA或SDK向CA注册用户时，这些角色和OU属性将分配给一个身份。随后使用用户命令<code>enroll</code> 在用户 <code>/msp</code> 文件夹中生成证书。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/ca-msp-visualization.png" alt="ca-msp-visualization"></p><p>The resulting ROLE and OU attributes are visible inside the X.509 signing certificate located in the <code>/signcerts</code> folder. The <code>ROLE</code> attribute is identified as <code>hf.Type</code> and refers to an actor’s role within its organization, (specifying, for example, that an actor is a <code>peer</code>). See the following snippet from a signing certificate shows how the Roles and OUs are represented in the certificate.</p><p>生成的ROLE和OU属性在<code>/signcerts</code> 文件夹中的X.509签名证书中可以看到。<code>ROLE</code>属性标识为<code>hf.Type</code>，是指参与者在其组织中的角色(例如指定是一个<code>peer</code>)。请参阅签名证书中的以下片段，以显示角色和OU如何在证书中表示。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/signcert.png" alt="signcert"></p><p><strong>Note:</strong> For Channel MSPs, just because an actor has the role of an administrator it doesn’t mean that they can administer particular resources. The actual power a given identity has with respect to administering the system is determined by the <em>policies</em> that manage system resources. For example, a channel policy might specify that <code>ORG1-MANUFACTURING</code> administrators, meaning identities with a role of <code>admin</code> and a Node OU of <code>ORG1-MANUFACTURING</code>, have the rights to add new organizations to the channel, whereas the <code>ORG1-DISTRIBUTION</code> administrators have no such rights.</p><p>**注意：**对于通道MSP，仅仅因为参与者具有管理员角色，并不意味着他们可以管理特定资源。给定身份在管理系统方面的实际能力由管理系统资源的策略确定。例如，渠道策略可能指定<code>ORG1-MANUFACTURING</code>管理员，即具有<code>admin</code>角色和<code>ORG1-MANUFACTURING</code>的节点OU的身份，有权向频道添加新组织，而<code>ORG1-DISTRIBUTION</code>管理员则无此权利。</p><p>Finally, OUs could be used by different organizations in a consortium to distinguish each other. But in such cases, the different organizations have to use the same Root CAs and Intermediate CAs for their chain of trust, and assign the OU field to identify members of each organization. When every organization has the same CA or chain of trust, this makes the system more centralized than what might be desirable and therefore deserves careful consideration on a blockchain network.</p><p>最后，联盟中的不同组织可以使用OU来区分彼此。但是在这种情况下，不同的组织必须为它们的信任链使用相同的根CA和中间CA，并分配OU字段以标识每个组织的成员。当每个组织都具有相同的CA或信任链时，这会使系统比可能需要的系统更加集中，因此在区块链网络上值得仔细考虑。</p><h2 id="MSP-Structure">MSP Structure</h2><p>Let’s explore the MSP elements that render the functionality we’ve described so far.</p><p>让我们探索MSP的元素呈现我们到目前为止所描述的功能。</p><p>A local MSP folder contains the following sub-folders:</p><p>本地MSP文件夹包含以下子文件夹：</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/membership.diagram.6.png" alt="membership.diagram.6"></p><p><em>The figure above shows the subfolders in a local MSP on the file system</em></p><p><em>上图显示了文件系统上本地MSP中的子文件夹</em></p><ul><li><p><strong>config.yaml:</strong> Used to configure the identity classification feature in Fabric by enabling “Node OUs” and defining the accepted roles.</p><p>用于通过启用“Node OUs”并定义接受的角色来在Fabric中配置身份分类功能。</p></li><li><p><strong>cacerts:</strong> This folder contains a list of self-signed X.509 certificates of the Root CAs trusted by the organization represented by this MSP. There must be at least one Root CA certificate in this MSP folder.</p><p>此文件夹包含由此MSP代表的组织信任的根CA的自签名X.509证书的列表。此MSP文件夹中至少必须有一个根CA证书。</p><p>This is the most important folder because it identifies the CAs from which all other certificates must be derived to be considered members of the corresponding organization to form the chain of trust.</p><p>这是最重要的文件夹，它标识了必须从中导出所有其他证书的CA，才能将其视为相应组织的成员以形成信任链。</p></li><li><p><strong>intermediatecerts:</strong> This folder contains a list of X.509 certificates of the Intermediate CAs trusted by this organization. Each certificate must be signed by one of the Root CAs in the MSP or by any Intermediate CA whose issuing CA chain ultimately leads back to a trusted Root CA.</p><p>此文件夹包含此组织信任的中间CA的X.509证书的列表。每个证书必须由MSP中的一个根CA签名，或由其发行CA链最终引回到受信任的根CA的任何中间CA。</p><p>An intermediate CA may represent a different subdivision of the organization (like <code>ORG1-MANUFACTURING</code> and <code>ORG1-DISTRIBUTION</code> do for <code>ORG1</code>), or the organization itself (as may be the case if a commercial CA is leveraged for the organization’s identity management). In the latter case intermediate CAs can be used to represent organization subdivisions. <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/msp.html" target="_blank" rel="noopener">Here</a> you may find more information on best practices for MSP configuration. Notice, that it is possible to have a functioning network that does not have an Intermediate CA, in which case this folder would be empty.</p><p>中间CA可能代表组织的不同部门（例如<code>ORG1</code>的<code>ORG1-MANUFACTURING</code>和<code>ORG1-DISTRIBUTION</code>），或者是组织本身（如果利用商业CA来进行组织的身份管理，可能就是这种情况）。在后一种情况下，中间CA可以用来表示组织细分。请注意，一个正常运行的网络可能没有中间，在这种情况下，此文件夹将为空。</p><p>Like the Root CA folder, this folder defines the CAs from which certificates must be issued to be considered members of the organization.</p><p>与“根CA”文件夹类似，此文件夹定义的证书必须是由当前组织的成员所颁发的。</p></li><li><p><strong>admincerts (Deprecated from Fabric v1.4.3 and higher):</strong> This folder contains a list of identities that define the actors who have the role of administrators for this organization. In general, there should be one or more X.509 certificates in this list.</p><p>该文件夹包含一个身份列表，这些身份定义了哪些参与者具有该组织的管理员角色。通常，此列表中应该有一个或多个X.509证书。</p><p><strong>Note:</strong> Prior to Fabric v1.4.3, admins were defined by explicitly putting certs in the <code>admincerts</code> folder in the local MSP directory of your peer. <strong>With Fabric v1.4.3 or higher, certificates in this folder are no longer required.</strong> Instead, it is recommended that when the user is registered with the CA, that the <code>admin</code> role is used to designate the node administrator. Then, the identity is recognized as an <code>admin</code> by the Node OU role value in their signcert. As a reminder, in order to leverage the admin role, the “identity classification” feature must be enabled in the config.yaml above by setting “Node OUs” to <code>Enable: true</code>. We’ll explore this more later.</p><p><strong>注意：</strong> 在Fabric v1.4.3之前，通过显式将证书放入peer的本地MSP目录下的<code>admincerts</code>文件夹中来定义管理员。对于Fabric v1.4.3或更高版本，不再需要此文件夹中的证书。相反，建议在向CA注册用户后，使用admin角色指定节点管理员。然后通过其签名证书中的节点OU角色值将身份识别为管理员。提醒一下，为了利用管理员角色，必须在上面的config.yaml中通过将“Node OUs”设置为<code>Enable：true</code>来启用“身份分类”功能。我们将在以后进行探讨。</p><p>And as a reminder, for Channel MSPs, just because an actor has the role of an administrator it doesn’t mean that they can administer particular resources. The actual power a given identity has with respect to administering the system is determined by the <em>policies</em> that manage system resources. For example, a channel policy might specify that <code>ORG1-MANUFACTURING</code> administrators have the rights to add new organizations to the channel, whereas the <code>ORG1-DISTRIBUTION</code> administrators have no such rights.</p><p>提醒一下，对于通道MSP，仅仅因为参与者具有管理员角色，并不意味着他们可以管理特定资源。给定身份在管理系统方面的实际能力由管理系统资源的策略确定。例如，通道政策可能指定<code>ORG1-MANUFACTURING</code>管理员有权向该渠道添加新组织，而<code>ORG1-DISTRIBUTION</code>管理员没有这种权利。</p></li><li><p><strong>keystore: (private Key)</strong> This folder is defined for the local MSP of a peer or orderer node (or in a client’s local MSP), and contains the node’s private key. This key is used to sign data — for example to sign a transaction proposal response, as part of the endorsement phase.</p><p>此文件夹是为peer节点或orderer节点的本地MSP（或在客户端的本地MSP中）定义的，它包含节点的私钥。这个私钥用于签名数据 - 例如在背书阶段签署交易建议响应。</p><p>This folder is mandatory for local MSPs, and must contain exactly one private key. Obviously, access to this folder must be limited only to the identities of users who have administrative responsibility on the peer.</p><p>对于本地MSP，此文件夹是必需的，并且必须仅包含一个私钥。显然，对此文件夹的访问必须仅限于对peer具有管理责任的用户的身份。</p><p>The <strong>channel MSP</strong> configuration does not include this folder, because channel MSPs solely aim to offer identity validation functionalities and not signing abilities.</p><p>通道MSP配置不包括此文件夹，因为通道MSP仅旨在提供身份验证功能而不是签名功能。</p><p><strong>Note:</strong> If you are using a <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/hsm.html" target="_blank" rel="noopener">Hardware Security Module(HSM)</a> for key management, this folder is empty because the private key is generated by and stored in the HSM.</p><p><strong>注意：</strong> 如果你使用<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/hsm.html" target="_blank" rel="noopener">硬件级别的安全模块(HSM)</a> 来管理key，这个文件夹是空的因为私钥已经被生成并存储在HSM。</p></li><li><p><strong>signcert:</strong> For a peer or orderer node (or in a client’s local MSP) this folder contains the node’s certificate issued by CA. The certificate represents the node’s identity, and this certificate’s corresponding <strong>private key</strong> can be used to generate signatures which may be verified by anyone with a copy of this certificate.</p><p>对于peer节点ordered节点（或在客户端的本地MSP中），此文件夹包含CA颁发的节点的证书。该证书代表节点的身份，并且该证书的相应私钥可用于生成签名，任何拥有此证书副本的人都可以对其进行验证。</p><p>This folder is mandatory for local MSPs, and must contain exactly one <strong>public key</strong>. Obviously, access to this folder must be limited only to the identities of users who have administrative responsibility on the peer.</p><p>此文件夹对于本地MSP是必需的，并且必须仅包含一个公共密钥。显然，对此文件夹的访问必须仅限于对peer具有管理责任的用户的身份。</p><p>Configuration of a <strong>channel MSP</strong> does not include this folder, as channel MSPs solely aim to offer identity validation functionalities and not signing abilities.</p><p>通道MSP的配置不包括此文件夹，因为通道MSP仅旨在提供身份验证功能而不是签名功能。</p></li><li><p><strong>tlscacerts:</strong> This folder contains a list of self-signed X.509 certificates of the Root CAs trusted by this organization <strong>for secure communications between nodes using TLS</strong>. An example of a TLS communication would be when a peer needs to connect to an orderer so that it can receive ledger updates.</p><p>此文件夹包含此组织信任的根CA的自签名X.509证书列表，以使用TLS在节点之间进行安全通信。TLS通信的一个示例是peer需要连接到ordered以便接收账本更新。</p><p>MSP TLS information relates to the nodes inside the network — the peers and the orderers, in other words, rather than the applications and administrations that consume the network.</p><p>MSP TLS信息与网络内部的节点有关（peers和orderers），换句话说，而不是消耗网络的应用程序和管理。</p><p>There must be at least one TLS Root CA certificate in this folder. For more information about TLS, see <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/enable_tls.html" target="_blank" rel="noopener">Securing Communication with Transport Layer Security (TLS)</a>.</p><p>此文件夹中至少必须有一个TLS根CA证书， 有关TLS的更多信息请查看 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/enable_tls.html" target="_blank" rel="noopener">Securing Communication with Transport Layer Security (TLS)</a>。</p></li><li><p><strong>tlsintermediatecacerts:</strong> This folder contains a list intermediate CA certificates CAs trusted by the organization represented by this MSP <strong>for secure communications between nodes using TLS</strong>. This folder is specifically useful when commercial CAs are used for TLS certificates of an organization. Similar to membership intermediate CAs, specifying intermediate TLS CAs is optional.</p><p>此文件夹包含此MSP代表的组织信任的中间CA证书CA列表，<strong>用于使用TLS的节点之间的安全通信</strong>。当组织使用商业CA作为TLS证书时，此文件夹特别有用。与成员资格中间CA相似，指定中间TLS CA是可选的。</p></li><li><p><strong>operationscerts:</strong> This folder contains the certificates required to communicate with the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/operations_service.html" target="_blank" rel="noopener">Fabric Operations Service</a> API.</p><p>该文件夹包含与 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/operations_service.html" target="_blank" rel="noopener">Fabric Operations Service</a> API通信所需的证书。</p></li></ul><p>A channel MSP includes the following additional folder:</p><p>通道MSP包括以下额外的文件夹：</p><ul><li><p><strong>Revoked Certificates:</strong> If the identity of an actor has been revoked, identifying information about the identity — not the identity itself — is held in this folder. For X.509-based identities, these identifiers are pairs of strings known as Subject Key Identifier (SKI) and Authority Access Identifier (AKI), and are checked whenever the certificate is being used to make sure the certificate has not been revoked.</p><p>如果参与者的身份已被撤销，则有关该身份的识别信息（而不是身份本身）将保存在此文件夹中。对于基于X.509的身份，这些标识符是称为Subject Key Identifier（SKI）和授权访问标识符（AKI）的字符串对，并在使用证书时进行检查，以确保证书未被吊销。</p><p>This list is conceptually the same as a CA’s Certificate Revocation List (CRL), but it also relates to revocation of membership from the organization. As a result, the administrator of a channel MSP can quickly revoke an actor or node from an organization by advertising the updated CRL of the CA. This “list of lists” is optional. It will only become populated as certificates are revoked.</p><p>此列表在概念上与CA的证书吊销列表（CRL）相同，但也与组织的成员资格吊销有关。结果，通道MSP的管理员可以通过发布CA的更新的CRL来快速从组织撤消参与者或节点。此“列表”是可选的。仅当证书被吊销时，它才会被填充。</p></li></ul><p>If you’ve read this doc as well as our doc on <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/identity/identity.html" target="_blank" rel="noopener">Identity</a>, you should now have a pretty good grasp of how identities and MSPs work in Hyperledger Fabric. You’ve seen how a PKI and MSPs are used to identify the actors collaborating in a blockchain network. You’ve learned how certificates, public/private keys, and roots of trust work, in addition to how MSPs are physically and logically structured.</p><p>如果你已经阅读过我们的<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/identity/identity.html" target="_blank" rel="noopener">Identity</a>文档，您现在应该对身份和MSP在Hyperledger Fabric中的工作方式有了很好的了解。您已经了解了如何使用PKI和MSP来识别在区块链网络中进行协作的参与者。您已经了解了证书、公钥/私钥和信任根的工作原理，以及MSP的物理和逻辑结构。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Why-do-I-need-an-MSP-（为什么我需要MSP）&quot;&gt;Why do I need an MSP?（为什么我需要MSP）&lt;/h2&gt;
&lt;p&gt;Because Fabric is a permissioned network, blockchain part</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="Key Concepts" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/Key-Concepts/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="MSP" scheme="https://guozhe001.github.io/tags/MSP/"/>
    
    <category term="Membership Service Provider" scheme="https://guozhe001.github.io/tags/Membership-Service-Provider/"/>
    
  </entry>
  
  <entry>
    <title>身份识别</title>
    <link href="https://guozhe001.github.io/2021/01/18/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/%E8%BA%AB%E5%88%86%E8%AF%86%E5%88%AB/"/>
    <id>https://guozhe001.github.io/2021/01/18/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/%E8%BA%AB%E5%88%86%E8%AF%86%E5%88%AB/</id>
    <published>2021-01-18T03:31:49.096Z</published>
    <updated>2021-01-19T10:59:02.781Z</updated>
    
    <content type="html"><![CDATA[<p>官方文档<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/identity/identity.html" target="_blank" rel="noopener">Identity</a></p><h2 id="What-is-an-Identity-（什么是身份识别）">What is an Identity?（什么是身份识别）</h2><p>The different actors in a blockchain network include peers, orderers, client applications, administrators and more. Each of these actors — active elements inside or outside a network able to consume services — has a digital identity encapsulated in an X.509 digital certificate. These identities really matter because they <strong>determine the exact permissions over resources and access to information that actors have in a blockchain network.</strong></p><p>区块链网络中包含不同的成员，包括peers、orderers、client applications、administrators等。这些参与者（网络内部或外部能够使用服务的活动元素）中的每一个都有封装在X.509数字证书中的数字身份。这些身份确实很重要，因为它们<strong>确定了对资源的确切权限以及对参与者在区块链网络中拥有的访问信息的权限</strong>。</p><p>A digital identity furthermore has some additional attributes that Fabric uses to determine permissions, and it gives the union of an identity and the associated attributes a special name — <strong>principal</strong>. Principals are just like userIDs or groupIDs, but a little more flexible because they can include a wide range of properties of an actor’s identity, such as the actor’s organization, organizational unit, role or even the actor’s specific identity. When we talk about principals, they are the properties which determine their permissions.</p><p>此外，数字身份还具有Fabric用来确定权限的其他一些属性，它为身份和相关属性的并集提供了一个特殊名称-<strong>主体</strong>。主体就像是userIDs或groupIDs，但更加灵活，因为它们可以包含成员身份的各种属性，例如成员的组织，组织单位，角色，甚至成员的特定身份。当我们谈论主体时，它们是确定其权限的属性。</p><p>For an identity to be <strong>verifiable</strong>, it must come from a <strong>trusted</strong> authority. A <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/membership/membership.html" target="_blank" rel="noopener">membership service provider</a> (MSP) is that trusted authority in Fabric. More specifically, an MSP is a component that defines the rules that govern the valid identities for this organization. The default MSP implementation in Fabric uses X.509 certificates as identities, adopting a traditional Public Key Infrastructure (PKI) hierarchical model (more on PKI later).</p><p>为了使身份可验证，它必须来自受信任的权威。 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/membership/membership.html" target="_blank" rel="noopener">membership service provider</a> (MSP)就是一个在Fabric中的受信任的权威。更具体地说，MSP是定义用于管理该组织角色的有效身份的组件。。 Fabric中的默认MSP实现是使用X.509证书作为身份，并采用传统的公共密钥基础结构（PKI）层次模型（稍后将在PKI上进行介绍）。</p><h2 id="A-Simple-Scenario-to-Explain-the-Use-of-an-Identity（通过一个简单的方案来解释身份识别的用法）">A Simple Scenario to Explain the Use of an Identity（通过一个简单的方案来解释身份识别的用法）</h2><p>Imagine that you visit a supermarket to buy some groceries. At the checkout you see a sign that says that only Visa, Mastercard and AMEX cards are accepted. If you try to pay with a different card — let’s call it an “ImagineCard” — it doesn’t matter whether the card is authentic and you have sufficient funds in your account. It will be not be accepted.</p><p>想象一下你去一个超级市场去买一些杂货。在结账时你看到一个标志说只支持Visa、Mastercard和AMEX银行卡。如果你尝试使用其他银行卡-让我们叫它“想象的卡片”-银行卡是否真实和帐户中是否有足够的资金都没关系。它将不被接受。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/identity.diagram.6.png" alt="identity.diagram.6"></p><p><em>Having a valid credit card is not enough — it must also be accepted by the store! PKIs and MSPs work together in the same way — a PKI provides a list of identities, and an MSP says which of these are members of a given organization that participates in the network.</em></p><p><em>拥有一个合法的信用卡还不够，他还必须被商店接受！PKIs和MSPs以相同的方式一起工作-PKI提供了身份识别的列表，MSP指出其中的哪些是参与该网络的给定组织的成员。</em></p><p>PKI certificate authorities and MSPs provide a similar combination of functionalities. A PKI is like a card provider — it dispenses many different types of verifiable identities. An MSP, on the other hand, is like the list of card providers accepted by the store, determining which identities are the trusted members (actors) of the store payment network. <strong>MSPs turn verifiable identities into the members of a blockchain network</strong>.</p><p>PKI证书颁发机构和MSP提供了类似的功能组合。PKI就像银行卡发卡组织一样，它分配许多不同类型的可验证身份。另一方面，MSP就像商店接受的发卡组织列表一样，确定哪些身份是商店支付网络的受信任成员（参与者）。<strong>MSP将可验证身份转换为区块链网络的成员。</strong></p><p>Let’s drill into these concepts in a little more detail.</p><p>让我们更详细地研究这些概念。</p><h2 id="What-are-PKIs-（什么是PKIs？）">What are PKIs?（什么是PKIs？）</h2><p><strong>A public key infrastructure (PKI) is a collection of internet technologies that provides secure communications in a network.</strong> It’s PKI that puts the <strong>S</strong> in <strong>HTTPS</strong> — and if you’re reading this documentation on a web browser, you’re probably using a PKI to make sure it comes from a verified source.</p><p>公钥基础结构（PKI）是网络技术的集合，这些技术在网络中提供安全的通信。是PKI将S置于HTTPS中-如果您正在网络浏览器上阅读此文档，您可能正在使用PKI来确保它来自经过验证的来源。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/identity.diagram.7.png" alt="identity.diagram.7"></p><p><em>The elements of Public Key Infrastructure (PKI). A PKI is comprised of Certificate Authorities who issue digital certificates to parties (e.g., users of a service, service provider), who then use them to authenticate themselves in the messages they exchange in their environment. A CA’s Certificate Revocation List (CRL) constitutes a reference for the certificates that are no longer valid. Revocation of a certificate can happen for a number of reasons. For example, a certificate may be revoked because the cryptographic private material associated to the certificate has been exposed.</em></p><p><em>公钥基础结构（PKI）的元素。PKI由证书颁发机构组成，证书颁发机构向各方颁发数字证书，然后他们使用它们在环境中交换的消息中对自己进行身份验证。CA的证书吊销列表（CRL）构成了不再有效的证书的参考。吊销证书的原因有很多。例如，由于与证书关联的加密私有材料已被暴露，因此证书可能被吊销。</em></p><p>Although a blockchain network is more than a communications network, it relies on the PKI standard to ensure secure communication between various network participants, and to ensure that messages posted on the blockchain are properly authenticated. It’s therefore important to understand the basics of PKI and then why MSPs are so important.</p><p>尽管区块链网络不仅仅是通信网络，但它依赖于PKI标准来确保各种网络参与者之间的安全通信，并确保正确验证发布在区块链上的消息。因此，重要的是要了解PKI的基础知识，然后理解MSP为何如此重要。</p><p>There are four key elements to PKI，PKI有四个关键元素:</p><ul><li><strong>Digital Certificates</strong>（数字证书）</li><li><strong>Public and Private Keys</strong>（公私钥对）</li><li><strong>Certificate Authorities</strong>（证书颁发机构）</li><li><strong>Certificate Revocation Lists</strong>（证书吊销列表）</li></ul><p>Let’s quickly describe these PKI basics, and if you want to know more details, <a href="https://en.wikipedia.org/wiki/Public_key_infrastructure" target="_blank" rel="noopener">Wikipedia</a> is a good place to start.</p><p>让我们快速介绍一下这些PKI基础知识，如果您想了解更多详细信息，那么<a href="https://en.wikipedia.org/wiki/Public_key_infrastructure" target="_blank" rel="noopener">Public_key_infrastructure</a>是一个不错的起点。</p><h2 id="Digital-Certificates-数字证书">Digital Certificates(数字证书)</h2><p>A digital certificate is a document which holds a set of attributes relating to the holder of the certificate. The most common type of certificate is the one compliant with the <a href="https://en.wikipedia.org/wiki/X.509" target="_blank" rel="noopener">X.509 standard</a>, which allows the encoding of a party’s identifying details in its structure.</p><p>数字证书是一种文档，其中包含与证书持有者有关的一组属性。最常见的证书类型是符合<a href="https://en.wikipedia.org/wiki/X.509" target="_blank" rel="noopener">X.509标准</a>的证书，该证书允许在其结构中对参与方的标识详细信息进行编码。</p><p>For example, Mary Morris in the Manufacturing Division of Mitchell Cars in Detroit, Michigan might have a digital certificate with a <code>SUBJECT</code> attribute of <code>C=US</code>, <code>ST=Michigan</code>, <code>L=Detroit</code>, <code>O=Mitchell Cars</code>, <code>OU=Manufacturing</code>, <code>CN=Mary Morris /UID=123456</code>. Mary’s certificate is similar to her government identity card — it provides information about Mary which she can use to prove key facts about her. There are many other attributes in an X.509 certificate, but let’s concentrate on just these for now.</p><p>例如，底特律Mitchell汽车制造部门的Mary Morris，密歇根州可能有一个数字证书，其<code>SUBJECT</code>属性为<code>C = US</code>，<code>ST = Michigan</code>，<code>L = Detroit</code>，<code>O = Mitchell Cars</code>，<code>OU = Manufacturing</code>，<code>CN = Mary Morris / UID = 123456</code>。Mary的证书类似于她的政府身份证，它提供了有关玛丽的信息，她可以用来证明有关她的关键事实。X.509证书中还有许多其他属性，但现在让我们仅关注这些属性。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/identity.diagram.8.png" alt="identity.diagram.8"></p><p><em>A digital certificate describing a party called Mary Morris. Mary is the <code>SUBJECT</code> of the certificate, and the highlighted <code>SUBJECT</code> text shows key facts about Mary. The certificate also holds many more pieces of information, as you can see. Most importantly, Mary’s public key is distributed within her certificate, whereas her private signing key is not. This signing key must be kept private.</em></p><p><em>数字证书描述了一个叫做Mary Morris的当事人，Mary是证书的<code>SUBJECT</code> ，突出显示的<code>SUBJECT</code> 文本显示了有关Mary的关键事实。如您所见，该证书还包含更多信息。最重要的是，Mary的公钥在证书中描述，但是私钥没有在证书中。签名用的私钥必须保密。</em></p><p>What is important is that all of Mary’s attributes can be recorded using a mathematical technique called cryptography (literally, “<em>secret writing</em>”) so that tampering will invalidate the certificate. Cryptography allows Mary to present her certificate to others to prove her identity so long as the other party trusts the certificate issuer, known as a <strong>Certificate Authority</strong> (CA). As long as the CA keeps certain cryptographic information securely (meaning, its own <strong>private signing key</strong>), anyone reading the certificate can be sure that the information about Mary has not been tampered with — it will always have those particular attributes for Mary Morris. Think of Mary’s X.509 certificate as a digital identity card that is impossible to change.</p><p>重要的是，可以使用称为加密的数学技术来记录Mary的所有属性，以免篡改证书。只要对方信任证书颁发者（<strong>Certificate Authority</strong> (CA)），密码学就可以允许Mary向他人出示她的证书以证明自己的身份。只要CA安全地保存某些加密信息（即其自己的专用签名密钥），任何阅读证书的人都可以确保有关Mary的信息未被篡改-它始终具有Mary Morris的那些特定属性。将Mary的X.509证书视为无法更改的数字身份证。</p><h2 id="Authentication-Public-keys-and-Private-Keys（认证方式，公钥和私钥）">Authentication, Public keys, and Private Keys（认证方式，公钥和私钥）</h2><p>Authentication and message integrity are important concepts in secure communications. Authentication requires that parties who exchange messages are assured of the identity that created a specific message. For a message to have “integrity” means that cannot have been modified during its transmission. For example, you might want to be sure you’re communicating with the real Mary Morris rather than an impersonator. Or if Mary has sent you a message, you might want to be sure that it hasn’t been tampered with by anyone else during transmission.</p><p>身份验证和消息完整性是安全通信中的重要概念。身份验证要求交换消息的各方确保创建了特定消息的身份。消息具有“完整性”意味着不能在其传输过程中对其进行修改。例如，您可能要确保与真实的玛丽·莫里斯（Mary Morris）而非模仿者进行交流。或者如果Mary已经给你发送了一个消息，你可能想要确保在传输过程中没有被其他任何人篡改过该消息。</p><p>Traditional authentication mechanisms rely on <strong>digital signatures</strong> that, as the name suggests, allow a party to digitally <strong>sign</strong> its messages. Digital signatures also provide guarantees on the integrity of the signed message.</p><p>Technically speaking, digital signature mechanisms require each party to hold two cryptographically connected keys: a public key that is made widely available and acts as authentication anchor, and a private key that is used to produce <strong>digital signatures</strong> on messages. Recipients of digitally signed messages can verify the origin and integrity of a received message by checking that the attached signature is valid under the public key of the expected sender.</p><p><strong>The unique relationship between a private key and the respective public key is the cryptographic magic that makes secure communications possible</strong>. The unique mathematical relationship between the keys is such that the private key can be used to produce a signature on a message that only the corresponding public key can match, and only on the same message.</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/identity.diagram.9.png" alt="identity.diagram.9"></p><p>In the example above, Mary uses her private key to sign the message. The signature can be verified by anyone who sees the signed message using her public key.</p><h2 id="Certificate-Authorities（证书颁发机构）">Certificate Authorities（证书颁发机构）</h2><p>As you’ve seen, an actor or a node is able to participate in the blockchain network, via the means of a <strong>digital identity</strong> issued for it by an authority trusted by the system. In the most common case, digital identities (or simply <strong>identities</strong>) have the form of cryptographically validated digital certificates that comply with X.509 standard and are issued by a Certificate Authority (CA).</p><p>CAs are a common part of internet security protocols, and you’ve probably heard of some of the more popular ones: Symantec (originally Verisign), GeoTrust, DigiCert, GoDaddy, and Comodo, among others.</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/identity.diagram.11.png" alt="identity.diagram.11"></p><p><em>A Certificate Authority dispenses certificates to different actors. These certificates are digitally signed by the CA and bind together the actor with the actor’s public key (and optionally with a comprehensive list of properties). As a result, if one trusts the CA (and knows its public key), it can trust that the specific actor is bound to the public key included in the certificate, and owns the included attributes, by validating the CA’s signature on the actor’s certificate.</em></p><p>Certificates can be widely disseminated, as they do not include either the actors’ nor the CA’s private keys. As such they can be used as anchor of trusts for authenticating messages coming from different actors.</p><p>CAs also have a certificate, which they make widely available. This allows the consumers of identities issued by a given CA to verify them by checking that the certificate could only have been generated by the holder of the corresponding private key (the CA).</p><p>In a blockchain setting, every actor who wishes to interact with the network needs an identity. In this setting, you might say that <strong>one or more CAs</strong> can be used to <strong>define the members of an organization’s from a digital perspective</strong>. It’s the CA that provides the basis for an organization’s actors to have a verifiable digital identity.</p><h3 id="Root-CAs-Intermediate-CAs-and-Chains-of-Trust（根CA、中级CA和信任链）">Root CAs, Intermediate CAs and Chains of Trust（根CA、中级CA和信任链）</h3><p>CAs come in two flavors: <strong>Root CAs</strong> and <strong>Intermediate CAs</strong>. Because Root CAs (Symantec, Geotrust, etc) have to <strong>securely distribute</strong> hundreds of millions of certificates to internet users, it makes sense to spread this process out across what are called <em>Intermediate CAs</em>. These Intermediate CAs have their certificates issued by the root CA or another intermediate authority, allowing the establishment of a “chain of trust” for any certificate that is issued by any CA in the chain. This ability to track back to the Root CA not only allows the function of CAs to scale while still providing security — allowing organizations that consume certificates to use Intermediate CAs with confidence — it limits the exposure of the Root CA, which, if compromised, would endanger the entire chain of trust. If an Intermediate CA is compromised, on the other hand, there will be a much smaller exposure.</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/identity.diagram.1.png" alt="identity.diagram.1"></p><p><em>A chain of trust is established between a Root CA and a set of Intermediate CAs as long as the issuing CA for the certificate of each of these Intermediate CAs is either the Root CA itself or has a chain of trust to the Root CA.</em></p><p>Intermediate CAs provide a huge amount of flexibility when it comes to the issuance of certificates across multiple organizations, and that’s very helpful in a permissioned blockchain system (like Fabric). For example, you’ll see that different organizations may use different Root CAs, or the same Root CA with different Intermediate CAs — it really does depend on the needs of the network.</p><h3 id="Fabric-CA">Fabric CA</h3><p>It’s because CAs are so important that Fabric provides a built-in CA component to allow you to create CAs in the blockchain networks you form. This component — known as <strong>Fabric CA</strong> is a private root CA provider capable of managing digital identities of Fabric participants that have the form of X.509 certificates. Because Fabric CA is a custom CA targeting the Root CA needs of Fabric, it is inherently not capable of providing SSL certificates for general/automatic use in browsers. However, because <strong>some</strong> CA must be used to manage identity (even in a test environment), Fabric CA can be used to provide and manage certificates. It is also possible — and fully appropriate — to use a public/commercial root or intermediate CA to provide identification.</p><p>因为CA非常重要，所以Fabric提供了内置的CA组件，可让您在形成的区块链网络中创建CA。该组件（称为<strong>Fabric CA</strong>）是私有的根CA提供者，能够管理具有X.509证书形式的Fabric参与者的数字身份。由于Fabric CA是针对Fabric的根CA需求的自定义CA，因此它固有地无法提供SSL证书供浏览器中的常规/自动使用。但是，由于必须使用某些CA来管理身份（即使在测试环境中也是如此），因此可以将Fabric CA用于提供和管理证书。使用公共/商业根或中间CA进行标识也是可能的，并且是完全合适的。</p><p>If you’re interested, you can read a lot more about Fabric CA <a href="http://hyperledger-fabric-ca.readthedocs.io/" target="_blank" rel="noopener">in the CA documentation section</a>.</p><p>如果你感兴趣，你可以 在<a href="http://hyperledger-fabric-ca.readthedocs.io/" target="_blank" rel="noopener">the CA documentation section</a>文档中阅读更多的关于 Fabric CA的内容。</p><h2 id="Certificate-Revocation-Lists（证书吊销列表）">Certificate Revocation Lists（证书吊销列表）</h2><p>A Certificate Revocation List (CRL) is easy to understand — it’s just a list of references to certificates that a CA knows to be revoked for one reason or another. If you recall the store scenario, a CRL would be like a list of stolen credit cards.</p><p>When a third party wants to verify another party’s identity, it first checks the issuing CA’s CRL to make sure that the certificate has not been revoked. A verifier doesn’t have to check the CRL, but if they don’t they run the risk of accepting a compromised identity.</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/identity.diagram.12.png" alt="identity.diagram.12"></p><p><em>Using a CRL to check that a certificate is still valid. If an impersonator tries to pass a compromised digital certificate to a validating party, it can be first checked against the issuing CA’s CRL to make sure it’s not listed as no longer valid.</em></p><p>Note that a certificate being revoked is very different from a certificate expiring. Revoked certificates have not expired — they are, by every other measure, a fully valid certificate. For more in-depth information about CRLs, click <a href="https://hyperledger-fabric-ca.readthedocs.io/en/latest/users-guide.html#generating-a-crl-certificate-revocation-list" target="_blank" rel="noopener">here</a>.</p><p>Now that you’ve seen how a PKI can provide verifiable identities through a chain of trust, the next step is to see how these identities can be used to represent the trusted members of a blockchain network. That’s where a Membership Service Provider (MSP) comes into play — <strong>it identifies the parties who are the members of a given organization in the blockchain network</strong>.</p><p>To learn more about membership, check out the conceptual documentation on <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/membership/membership.html" target="_blank" rel="noopener">MSPs</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官方文档&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/release-2.2/identity/identity.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Identity&lt;/a&gt;</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="Key Concepts" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/Key-Concepts/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="Identity" scheme="https://guozhe001.github.io/tags/Identity/"/>
    
  </entry>
  
  <entry>
    <title>Fabric的网络</title>
    <link href="https://guozhe001.github.io/2021/01/15/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Fabric%E7%9A%84%E7%BD%91%E7%BB%9C/"/>
    <id>https://guozhe001.github.io/2021/01/15/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Fabric%E7%9A%84%E7%BD%91%E7%BB%9C/</id>
    <published>2021-01-15T02:53:52.972Z</published>
    <updated>2021-01-19T10:59:07.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blockchain-network-Fabric的网络">Blockchain network(Fabric的网络)</h2><p>原始官方文档：<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/network/network.html" target="_blank" rel="noopener">https://hyperledger-fabric.readthedocs.io/en/release-2.2/network/network.html</a></p><h3 id="Creating-the-Network">Creating the Network</h3><p>从创建基础网络开始：<br><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/network.diagram.2.png" alt="network.diagram.2."><br><em>在orderer启动之后网络就形成了，在我们的示例网络N中，包括单个节点O4的ordered service是根据网络配置NC4配置的，该网络配置向组织R4提供管理权限。在网络级别，证书颁发机构CA4用于向R4组织的管理员和网络节点分配身份。</em></p><p>我们可以看到定义网络N的第一件事就是ordering service ，O4。将订购服务视为网络的初始管理点很有帮助。将ordering service视为网络的初始管理点很有帮助。按照事先约定，O4最初由组织R4中的管理员配置和启动，并托管在R4中。配置NC4包含描述网络管理功能的初始的策略集合。最初，将其设置为仅通过网络授予R4权限。这将改变，我们将在后面看到，但目前R4是网络的唯一成员。</p><h3 id="Certificate-Authorities（证书颁发机构）">Certificate Authorities（证书颁发机构）</h3><p>您还可以看到证书颁发机构CA4，用于向管理员和网络节点颁发证书。CA4在我们的网络中起着关键作用，因为它颁发X.509证书，该证书可用于将组件标识为属于组织R4。由CA颁发的证书也可以用于签署交易，以表明组织认可交易结果–这是允许交易提交到分类帐的前提。让我们更详细地研究CA的这两个方面。</p><p>首先，区块链网络的不同组件使用证书将自己标识为来自特定组织。这就是为什么通常有不止一个CA支持一个区块链网络-不同的组织经常使用不同的CA。<br>证书到成员组织的映射是通过称为Membership Services Provider (MSP)的结构实现的。网络配置NC4使用MSP来标识由CA4分配的证书的属性，该证书将证书持有者与组织R4相关联。然后，NC4可以在策略中使用此MSP向R4的参与者授予对网络资源的特定权限。这种策略的一个示例是R4中的管理员可以向网络添加的新成员。</p><p>其次，稍后我们将看到CA颁发的证书如何成为交易生成和验证过程的核心。具体来说，X.509证书用于客户端应用程序交易建议和智能合约交易响应中以进行数字签名交易。随后，托管账本的网络节点在接受交易记录到账本之前会验证交易的签名是否有效。</p><p>让我们回顾一下示例区块链网络的基本结构：证书颁发机构CA4定义了一组用户，可以访问网络N；这些用户对网络N中资源的权限被网络配置NC4中包含的策略所描述。在我们配置并启动ordering service节点O4时，所有这些都变为现实。</p><h3 id="Adding-Network-Administrators（添加网络管理员）">Adding Network Administrators（添加网络管理员）</h3><p>NC4只配置了R4的用户在网络上的权限。在下一个阶段，我们将允许组织R1用户管理网络。让我们看看网络如何发展：<br><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/network.diagram.2.1.png" alt="network.diagram.2.1"><br><em>组织R4更新网络配置以使组织R1也成为管理员。此后，R1和R4在网络配置上享有同等的权利。</em></p><p>尽管订购者节点O4在R4的基础结构上运行，但R1拥有共享的管理权限，只要它可以访问网络即可。这意味着R1或R4可以更新网络配置NC4，以允许R2组织进行网络操作的子集。这样，即使R4在运行订购服务，R1也对其拥有完全的管理权限，并且R2具有创建新联合体的部分权限。</p><p>你在示例中看到的ordering service是网络中的单个节点，这是最简单的形式。ordering service通常是多节点的，可以配置为在不同组织的不同节点。例如，我们可能在R4中运行O4并将其连接到组织R1中单独的订购者节点O2。这样，我们将拥有一个多站点，多组织的管理结构。</p><p>我们将在本主题的稍后部分讨论ordering service，但是现在，仅将ordering service视为一个可为不同组织提供对网络受控访问的管理点。</p><h3 id="Defining-a-Consortium-定义一个联盟">Defining a Consortium(定义一个联盟)</h3><p>尽管现在可以通过R1和R4管理网络，但是几乎没有什么事情可做。我们需要做的第一件事是定义一个联盟。这个词的字面意思是“拥有共同命运的团体”，因此对于区块链网络中的一组组织来说是一个合适的选择。</p><p>让我们看看联盟的定义：<br><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/network.diagram.3.png" alt="network.diagram.3"><br><em>网络管理员定义了一个联盟X1，该联盟包含两个成员，组织R1和R2。该联盟的定义存储在网络配置NC4中，并将在网络开发的下一阶段使用。CA1和CA2是这些组织的各自的证书颁发机构。</em></p><p>因为NC4配置的是只允许R1或R4可以创建新的联盟。该图显示了添加的新联盟X1，该联盟将R1和R2定义为其组成组织。我们还可以看到已经添加了CA2用以认证R2的用户。请注意，一个联盟可以有任意数量的组织成员–我们刚刚显示了两个，因为它是最简单的配置。</p><p>为什么联盟如此重要？我们可以看到一个联盟定义了网络中彼此需要共享交易的组织集合，在本例中R1和 R2。如果组织有共同的目标，将它们组合在一起真的很有意义，而这正上面的联盟定义。</p><p>该网络虽然由单个组织启动，但现在由较大的一组组织控制。现在，我们将使用联盟X1创建Hyperledger Fabric区块链的一个非常重要的部分-一个通道。</p><h3 id="Creating-a-channel-for-a-consortium-为联盟创建一个通道">Creating a channel for a consortium(为联盟创建一个通道)</h3><p>channel是主要的通信机制，联盟的成员可以通过channel相互通信。网络中可以有多个通道，我们先从一个渠道开始。<br>让我们看看如何将第一个channel添加到网络中：<br><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/network.diagram.4.png" alt="network.diagram.4"><br><em>使用联盟定义X1为R1和R2创建了通道C1。通道由通道配置CC1进行治理，完全独立于网络配置。CC1由对C1拥有同等权利的R1和R2管理。 R4在CC1中没有任何权利。</em></p><p>通道C1为财团X1提供了专用的通信机制。我们可以看到通道C1已连接到ordersing service(O4)，但没有附加任何内容。在网络开发的下一阶段，我们将连接组件，例如客户端应用程序和peer节点。但是，渠道代表着未来连接的潜力。</p><p>即使通道C1是网络N的一部分，但也可以与它完全区分开。注意组织R3和R4不在此通道中，C1只用于R1和R2之间的交易处理。在上一步中，我们了解了R4如何授予R1创建新联盟的权限。值得一提的是R4还允许R1创建channel！在此图中，可能是组织R1或R4创建了通道C1。</p><p>再次注意通道C1对于网络配置NC4如何具有完全独立的配置CC1。CC1包含用于控制R1和R2在通道C1上的权限的策略-正如我们所看到的，R3和R4在此通道上没有权限。R3和R4只能在R1或R2将其添加适当策略到通道配置CC1中，才可以与C1交互。一个示例是定义谁可以向channel添加新组织。特别要注意的是，R4不能将自身添加到通道C1中-它必须并且只能由R1或R2授权。</p><p>为什么channel如此重要？channels之所以有用，是因为它们为联盟成员之间的私有通信和私有数据提供了一种机制。channel提供了隐私性保护，对于其他的channels和整个网络。Hyperledger Fabric在这方面很强大，因为它允许组织共享基础结构并同时保持私有状态。这里没有矛盾-网络中的不同联盟需要适当共享不同的信息和流程，而渠道则提供了一种有效的机制来做到这一点。通道可有效共享基础架构，同时保持数据和通信的隐私。</p><p>我们还可以看到，一旦创建了一个channel，它实际上就是“脱离网络”。从创建开始到未来，只有在channel配置中明确指定的组织才能对其进行控制。同样，从此时开始对网络配置NC4的任何更新都不会直接影响channel配置CC1；例如，如果联盟定义X1更改，它将不会影响通道C1的成员。通道之所以有用，是因为它们允许构成通道的组织之间进行私人通信。此外，通道中的数据与网络的其余部分（包括其他通道）完全隔离。</p><p>顺便说一句，还有一个特殊的系统通道（<strong>system channel</strong>）的定义，是为了给排序服务（ordering service）使用的。它的行为与常规channel完全相同，因此，有时也称为应用程序通道（<strong>application channels</strong>）。</p><h3 id="Peers-and-Ledgers（节点与账单）">Peers and Ledgers（节点与账单）</h3><p>现在开始使用渠道将区块链网络和组织组件连接在一起。在网络开发的下一阶段，我们可以看到我们的网络N刚刚获得了两个新组件，即peer节点P1和账本实例L1。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/network.diagram.5.png" alt="network.diagram.5"><br><em>peer节点P1已加入通道C1。 P1物理上存储账本L1的副本。 P1和O4可以使用通道C1相互通信。</em></p><p>peer节点是托管区块链账本副本的网络组件，最后，我们开始看到一些可识别的区块链组件。P1在网络中的目的纯粹是托管账本L1的副本，以供其他人访问。我们可以认为L1物理上托管在P1上，但逻辑上托管在通道C1上。当我们向channel添加更多peer时，我们会更清楚地看到这个想法。</p><p>P1配置的关键部分是CA1发出的X.509身份，该身份将P1与组织R1相关联。当R1组织的管理员将peer节点P1加入通道C1并且P1开始从排序节点O4拉取数据块的时候，O4使用通道配置CC1来确定P1在该通道上的权限。例如，CC1中的策略确定P1（或组织R1）是否可以在通道C1上读取（和/或）写入。</p><p>注意拥有peer的组织是如何将peer加入渠道的，尽管我们仅添加了一个peer，但我们将看到网络中的多个渠道上如何有多个peer节点。稍后我们将看到peer可以扮演的不同角色。</p><h3 id="Applications-and-Smart-Contract-chaincode（应用程序和智能合约联链码）">Applications and Smart Contract chaincode（应用程序和智能合约联链码）</h3><p>现在，通道C1上有一个账本L1，我们可以开始连接客户端应用程序，以使用为操作账本提供服务的peer。</p><p>请注意网络已经增长了：<br><img src="https://gitee.com/guozhe001/images/raw/master/network.diagram.6.png" alt="network.diagram.6"><br><em>已经智能合约S5已经被部署到了P1，属于组织R1的客户端应用程序A1可以使用S5通过P1来访问账本L1。A1、P1和O4都加入了通道C1，如图所示，A1、P1和O4都加入了通道C1，即它们都可以利用该通道提供的通信设施。</em></p><p>在网络开发的下一阶段，我们可以看到客户端应用程序A1可以使用通道C1连接到特定的网络资源–在这种情况下，A1可以同时连接到peer节点P1和ordered节点O4。让我们在此之前查看渠道是如何成为网络和组织组件之间通信核心的。就像对peer节点和ordered节点一样，客户端应用程序也具有一个可以将其与组织关联起来的身份。在我们的例子中，客户端应用程序A1与组织R1关联，尽管它在Fabric区块链网络之外，但仍然可以通过渠道C1访问到区块链。</p><p>现在看来，A1可以直接通过P1访问分类帐L1，但实际上，所有访问都是通过称为智能合约链码S5的特殊程序进行管理的。将S5定义为账本的所有常见访问模式； S5提供了一套明确定义的方式，可用来查询或更新账本L1。</p><p>每个组织的开发人员都可以创建智能合约，然后发起在联盟之间共享的业务流程。智能合约用于生成可以分配到网络中每个节点的交易。我们稍后再讨论这个想法；当网络更大时，将更容易理解。现在，需要了解的重要一点是，到此为止，必须在智能合约上执行两次操作。目前为止，需要了解的重要一点是必须在智能合约上执行两次操作：</p><ol><li>它必须已经安装（<strong>installed</strong>）在peer上</li><li>然后已经在通道上定义（<strong>defined</strong>）</li></ol><p>Hyperledger Fabric用户经常把术<strong>语智能合约（smart contract）<strong>和</strong>链码（chaincode）<strong>进行互换使用。通常，智能合约定义了</strong>交易逻辑（ transaction logic ）</strong>，这个交易逻辑控制了现实世界状态中包含业务对象的生命周期。然后将其打包成链码，然后将其部署到区块链网络。可以将智能合约视为支配交易，而链码则是控制如何打包智能合约以进行部署。</p><h3 id="Installing-a-chaincode-package（安装链码包）">Installing a chaincode package（安装链码包）</h3><p>开发了智能合约S5之后，组织R1中的管理员必须创建一个链码包并将其安装到peer节点P1上。这是一个简单的操作；一旦完成，P1就完全了解S5。具体来说，P1可以看到S5的**实现（implementation）<strong>逻辑-就是用于访问账本L1的代码。我们将此与S5的</strong>接口（interface）**进行对比，后者仅描述S5的输入和输出，而与它的实现无关。</p><p>当一个组织在一个渠道中有多个peer时，它可以选择在哪些peer节点安装智能合约。它不需要在每个peer节点上安装智能合约。</p><h3 id="Defining-a-chaincode（定义链码）">Defining a chaincode（定义链码）</h3><p>尽管链码已安装在各个组织的peer上，但它是在channel范围内管理和操作的。每个组织都需要批准<strong>链码定义（chaincode definition）</strong>，这是一组参数，用于确定如何在渠道上使用链码。组织必须批准链码定义，才能使用已安装的智能合约来查询账本并认可交易。在我们的只有一个peer节点P1的例子中，组织R1中的管理员必须批准S5的<strong>链码定义（chaincode definition）</strong>。</p><p>需要足够数量的组织批准<strong>链码定义（chaincode definition）</strong>（默认情况下，大多数情况下为批准），然后才能将<strong>链码定义</strong>提交给渠道并用于与渠道账本进行交互。由于例子中的通道C1只有一个成员，因此R1的管理员可以将S5的<strong>链码定义</strong>提交给通道C1。提交链码的定义后，便可以由客户端应用程序A1调用S5！</p><p>请注意，尽管通道上的每个组件现在都可以访问S5，但它们无法看到其程序逻辑。对于安装它的那些节点（我们的示例中是P1），它仍然是私有的。从概念上讲，这意味着已定义并提交给渠道的智能合约接口与已安装的智能合约实现相反。加强这个想法；安装智能合约我们可以将其视为物理托管（<strong>physically hosted</strong>）在peer上，而已在通道上定义的智能合约我们可以将其视为逻辑托管（ <strong>logically hosted</strong>）在通道上。</p><h3 id="Endorsement-policy（背书策略）">Endorsement policy（背书策略）</h3><p>链码定义中提供的最重要的信息是背书策略。它描述了哪些组织必须批准交易然后其他组织才能将其接受到其账本副本上。在我们的示例网络中，只有R1或R2认可交易，才能将交易接受到账本L1上。</p><p>将链码定义提交给渠道会将背书策略放在渠道的账本上；它使通道的任何成员都可以访问它。您可以在<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/txflow.html" target="_blank" rel="noopener">交易流</a>主题中阅读有关背书策略的更多信息。</p><h3 id="Invoking-a-smart-contract（调用智能合约）">Invoking a smart contract（调用智能合约）</h3><p>将智能合约安装在peer节点上并在channel上定义后，即可由客户端应用程序调用。</p><p>客户端应用程序通过向由智能合约背书策略指定的组织所拥有的节点发起交易提案；智能合约使用交易提案作为它的输入来生成认可的交易响应，该响应由peer节点返回到客户端应用程序。</p><p>这些交易响应与交易提议打包在一起，形成一个完全认可的交易，可以分散到整个网络。现在了解应用程序如何调用智能合约以生成认可的交易即可，稍后我们将对其进行更详细的介绍。</p><p>在网络开发的这一阶段，我们可以看到组织R1正在完全参与网络。它的应用程序-从A1开始-可以通过智能合约S5访问账本L1，以生成将由R1认可的交易，由于它们符合认可策略因此被接受到账本中。</p><h3 id="Network-completed（网络完成）">Network completed（网络完成）</h3><p>回想一下，我们的目标是为联盟X1（组织R1和R2）创建渠道。网络开发的下一阶段将看到组织R2将其基础结构添加到网络中。</p><p>让我们来看看网络进化成什么样了：<br><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/network.diagram.7.png" alt="network.diagram.7"><br><em>通过增加组织R2的基础结构，网络得到了发展。具体来说，R2添加了peer节点P2，该peer节点托管账本L1的副本和链码S5。R2批准与R1相同的链码定义。P2也与应用程序A2一样加入了通道C1，A2和P2通过CA2进行身份认证。所有这些意味着应用程序A1和A2都可以使用peer节点P1或P2在C1上调用S5。</em></p><p>我们可以看到组织R2在通道C1上添加了一个peer节点P2。 P2还托管账本L1的副本和智能合约S5。我们可以看到R2还添加了可以通过通道C1连接到网络的客户端应用程序A2。为此，组织R2中的管理员已创建peer节点P2，并将其用与R1中的管理员相同的方式加入到通道C1。管理员还必须批准与R1相同的链码定义。</p><p>我们已经建立了第一个运营网络！在网络开发的现阶段，我们拥有一个渠道，在此通道上组织R1和R2可以彼此进行交易。具体来说，这意味着应用程序A1和A2可以使用智能合约S5和通道C1上的账本L1生成交易。</p><h3 id="Generating-and-accepting-transactions（生成和接受交易）">Generating and accepting transactions（生成和接受交易）</h3><p>与始终托管着账本副本的peer节点相反，我们看到有两种不同的peer节点：拥有智能合约的peer和没有智能合约的peer。在我们的网络中，每个peer都托管着智能合约的副本，但是在较大的网络中，将有更多的peer节点不托管智能合约的副本。peer节点只能运行安装在其上的智能合约，但是它可以通过连接到通道来知道智能合约的接口。</p><p>您不应该将没有安装智能合约的peer节点视为劣等节点。具有智能合约的peer节点更具有特殊的功能-有助于**生成（generate ）<strong>交易。请注意，所有peer节点都可以</strong>验证（validate）<strong>并随后</strong>接受（accept）<strong>或</strong>拒绝（reject）<strong>交易到其账本L1的副本上。但是，只有安装了智能合约的peer节点才能参与交易</strong>认可（endorsement）**的过程，这对生成合法交易至关重要。</p><p>我们无需担心本主题中如何生成，分配和接受交易的确切细节–能够理解我们拥有一个区块链网络，组织R1和R2可以共享信息和流程作为账本接受（ledger-captured）的交易。我们将在其他主题中学习有关交易，账本，智能合约的更多信息。</p><h3 id="Types-of-peers（peer节点的类型）">Types of peers（peer节点的类型）</h3><p>在Hyperledger Fabric中，尽管所有peer都相同，但它们可以根据网络的配置方式承担多个角色。现在，我们对典型的网络拓扑有了足够的了解，可以描述这些角色。</p><ul><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#commitment" target="_blank" rel="noopener">Committing peer</a>：提交peer节点，通道中的每个peer节点都是提交peer节点。它接收包含已经生成的交易的块，随后将其验证，然后再将它们以追加的方式提交到peer节点的账本副本中。</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#endorsement" target="_blank" rel="noopener">Endorsing peer</a>：背书节点，每一个安装了智能合约的peer节点都可以成为背书节点。但是要真正成为背书节点，客户端应用程序必须使用peer的智能合约来生成数字签名的事务响应。背书对等方一词是对此事实的明确引用。<br>智能合约的背书策略确定组织的peer应先对生成的交易进行数字签名，然后才能将其接受到提交peer的账本副本中。</li></ul><p>上面是peer节点的的两种主要类型。peer还可以采用其他两种角色：</p><ul><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#leading-peer" target="_blank" rel="noopener">Leader peer</a>：领导节点，当一个组织在同一个channel中有多个peer节点时，领导节点负责将交易从排序节点分发到组织内的其他提交节点。一个peer可以选择参与静态或动态领导选择。</li></ul><p>因此，从领导者的角度考虑两组peer是有帮助的-那些具有静态领导者选择的peer和那些具有动态领导者选择的peer。对于静态节点，可以将零个或多个peer配置为领导节点。对于动态节点集合，将由该集合选出一个peer作为领导者。此外，在动态集合中，如果领导节点失败了，则其余peer将重新选举领导节点。</p><p>这意味着同一个组织的peers可以让一个或多个领导节点连接到排序服务。这可以帮助提高处理大量事务的大型网络的弹性和可伸缩性。</p><ul><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#anchor-peer" target="_blank" rel="noopener">Anchor peer</a>:锚节点，如果peer需要与另一个组织中的peer进行通信，则可以使用该组织在通道配置中定义的锚节点。一个组织可以为其定义零个或多个锚节点，并且锚节点可以帮助处理许多不同的跨组织通信场景。</li></ul><p>注意，一个peer可以同时是一个提交节点、背书节点、领导节点和锚节点！在一个组织中出于所有实际目的，仅锚节点是可选的，领导节点，背书节点和提交节点都至少有一个。</p><h3 id="Adding-organizations-and-peers-to-the-channel（将组织和节点添加到渠道）">Adding organizations and peers to the channel（将组织和节点添加到渠道）</h3><p>当组织R2加入通道时，它必须在其peer节点P2上安装智能合约S5。这很明显–如果应用程序A1或A2希望在peer节点P2上使用S5来生成交易，首先S5必须存在，安装智能合约可以做到让其存在。此时，peer节点P2具有智能合约和账本的物理副本；像P1一样，它可以在其账本L1的副本上生成和接受交易。</p><p>为了使用智能合约S5，R2必须批准与R1批准的相同的链码定义。由于链码定义已由组织R1提交给通道，因此R2组织批准链码定义并安装链码软件包后便可以使用链码了。提交交易只需发生一次。一个新的组织认可链码参数的行为被通道内的其他组织统一后便可以使用链码。由于链码定义的认可是在组织级别进行的，因此R2认可链码定义一次，然后将多个peer节点加入安装了链码包的渠道。然而，如果R2想要对链码定义进行修改的话，则R1和R2都需要在组织层面认可这个新的链码定义，然后需要其中一个组织将定义提交给渠道。</p><p>在我们的网络中，我们可以看到通道C1链接了两个客户端应用程序，两个peer节点和一个排序服务。由于只有一个通道，因此也只有一个逻辑账本可以与这些组件进行交互。节点P1和P2有相同的账本L1的副本。智能合约S5的副本通常使用相同的编程语言来实现，但如果不同，则他们在语义上必须等效。</p><p>我们可以看到，将对peer小心地添加到网络可以帮助支持增加的吞吐量，稳定性和弹性。例如，网络中更多的peer节点将允许更多的应用程序连接到它；在遇到计划内或计划外的停机时组织中的多个peer将提供额外的弹性。</p><p>这一切都意味着可以配置支持各种操作目标的复杂的拓扑网络，网络可以达到的规模不存在理论上的限制。此外，单个组织中的peer可以有效地发现并彼此通信的技术机制-<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/gossip.html#gossip-protocol" target="_blank" rel="noopener">gossip protocol</a>-将容纳大量peer节点以支持此类拓扑。</p><p>仔细使用网络和通道策略可以使大型网络得到良好管理。组织可以自由地将peer节点添加到网络，只要它们符合网络约定的策略即可。网络和渠道策略在自治和控制之间建立了平衡，这是去中心化网络的特征。</p><h2 id="Simplifying-the-visual-vocabulary（简化视觉词汇）">Simplifying the visual vocabulary（简化视觉词汇）</h2><p>We’re now going to simplify the visual vocabulary used to represent our sample blockchain network. As the size of the network grows, the lines initially used to help us understand channels will become cumbersome. Imagine how complicated our diagram would be if we added another peer or client application, or another channel?</p><p>现在，我们将简化用于表示示例区块链网络的视觉词汇。随着网络规模的扩大，最初用于帮助我们了解渠道的线路将变得很繁琐。想想一些如果我们添加另一个peer节点或者一个客户端或者另一个channel我们的图片有多复杂？</p><p>That’s what we’re going to do in a minute, so before we do, let’s simplify the visual vocabulary. Here’s a simplified representation of the network we’ve developed so far:</p><p>这就是我们紧接着要做的事情，因此在我们这样做之前，让我们简化视觉词汇。这是到目前为止我们开发的网络的简化表示：</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/network.diagram.8.png" alt="network.diagram.8"></p><p><em>The diagram shows the facts relating to channel C1 in the network N as follows: Client applications A1 and A2 can use channel C1 for communication with peers P1 and P2, and orderer O4. Peer nodes P1 and P2 can use the communication services of channel C1. Ordering service O4 can make use of the communication services of channel C1. Channel configuration CC1 applies to channel C1.</em></p><p><em>该图显示了与网络N中的通道C1有关的事实，如下所示：客户端程序A1和A2可以使用通道C1来与peer节点P1和P2和排序节点O4进行通信。peer节点P1和P2可以使用通道C1的通信服务。排序服务O4可以利用通道C1的通信服务。通道配置CC1适用于通道C1。</em></p><p>Note that the network diagram has been simplified by replacing channel lines with connection points, shown as blue circles which include the channel number. No information has been lost. This representation is more scalable because it eliminates crossing lines. This allows us to more clearly represent larger networks. We’ve achieved this simplification by focusing on the connection points between components and a channel, rather than the channel itself.</p><p>请注意，这个网络图已经通过用连接点替换通道线来简化了，显示为带有通道编号的蓝色圆圈。没有信息丢失。此表示形式更具伸缩性，因为它消除了交叉线。这使我们可以更清楚地表示更大的网络。通过专注于组件和通道之间的连接点，而不是通道本身，我们实现了这种简化。</p><h2 id="Adding-another-consortium-definition（添加另一个联盟定义）">Adding another consortium definition（添加另一个联盟定义）</h2><p>In this next phase of network development, we introduce organization R3. We’re going to give organizations R2 and R3 a separate application channel which allows them to transact with each other. This application channel will be completely separate to that previously defined, so that R2 and R3 transactions can be kept private to them.</p><p>在网络开发的下一阶段，我们介绍组织R3。我们将为组织R2和R3提供一个单独的应用程序渠道，使他们可以彼此进行交易。该应用程序通道将与先前定义的通道完全分开，因此可以使R2和R3的交易保持私有。</p><p>Let’s return to the network level and define a new consortium, X2, for R2 and R3:</p><p>让我们回到网络级别并且为R2和R3定义一个新的联盟X2：</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/network.diagram.9.png" alt="network.diagram.9"></p><p><em>A network administrator from organization R1 or R4 has added a new consortium definition, X2, which includes organizations R2 and R3. This will be used to define a new channel for X2.</em></p><p><em>R1或者R4的网络管理员已经添加了一个新的联盟定义X2，这个联盟定义包含了R2和R3两个组织。这将被用于为X2定义一个新的通道。</em></p><p>Notice that the network now has two consortia defined: X1 for organizations R1 and R2 and X2 for organizations R2 and R3. Consortium X2 has been introduced in order to be able to create a new channel for R2 and R3.</p><p>注意网络中现在已经有两个联盟定义，组织R1与R2的联盟X1和组织R2与R3的联盟X2。联盟X2已经被引进以便为R2和R3创建新的通道。</p><p>A new channel can only be created by those organizations specifically identified in the network configuration policy, NC4, as having the appropriate rights to do so, i.e. R1 or R4. This is an example of a policy which separates organizations that can manage resources at the network level versus those who can manage resources at the channel level. Seeing these policies at work helps us understand why Hyperledger Fabric has a sophisticated <strong>tiered</strong> policy structure.</p><p>新渠道只能由网络配置策略中明确标识的组织创建，网络中NC4具有适当权限的，即R1或R4。这是策略的示例，该策略将可以在网络级别管理资源的组织与可以在通道级别管理资源的组织区分开来。看到这些策略在起作用，有助于我们理解为什么Hyperledger Fabric具有复杂的分层策略结构。</p><p>In practice, consortium definition X2 has been added to the network configuration NC4. We discuss the exact mechanics of this operation elsewhere in the documentation.</p><p>实际上，联盟定义X2已添加到网络配置NC4。我们将在文档的其他地方讨论此操作的确切机制。</p><h2 id="Adding-a-new-channel（添加一个新的通道）">Adding a new channel（添加一个新的通道）</h2><p>Let’s now use this new consortium definition, X2, to create a new channel, C2. To help reinforce your understanding of the simpler channel notation, we’ve used both visual styles – channel C1 is represented with blue circular end points, whereas channel C2 is represented with red connecting lines:</p><p>让我们使用新的X2联盟定义来创建一个新的通道C2。为了帮助您进一步理解更简单的通道符号，我们使用了两种视觉样式-通道C1用蓝色圆形端点表示，而通道C2用红色连接线表示：</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/network.diagram.10.png" alt="network.diagram.10"></p><p><em>A new channel C2 has been created for R2 and R3 using consortium definition X2. The channel has a channel configuration CC2, completely separate to the network configuration NC4, and the channel configuration CC1. Channel C2 is managed by R2 and R3 who have equal rights over C2 as defined by a policy in CC2. R1 and R4 have no rights defined in CC2 whatsoever.</em></p><p><em>使用联盟定义X2为R2和R3创建了一个新的通道C2。这个通道有一个通道配置CC2，完全独立于网络配置NC4和通道配置CC1。通道C2由R2和R3管理，它们具有CC2中的策略所定义的对C2相同的权限。 R1和R4在CC2中均未定义任何权限。</em></p><p>The channel C2 provides a private communications mechanism for the consortium X2. Again, notice how organizations united in a consortium are what form channels. The channel configuration CC2 now contains the policies that govern channel resources, assigning management rights to organizations R2 and R3 over channel C2. It is managed exclusively by R2 and R3; R1 and R4 have no power in channel C2. For example, channel configuration CC2 can subsequently be updated to add organizations to support network growth, but this can only be done by R2 or R3.</p><p>通道C2为联盟X2提供了专用通信机制。再次注意，组织是如何通过通道被联合起来的。通道配置CC2现在包含控制通道资源的策略，通过通道C2向组织R2和R3分配管理权限。它仅由R2和R3管理； R1和R4在通道C2中没有权限。例如，通道配置CC2随后可以更新以添加组织来支持网络增长，但这只能由R2或R3完成。</p><p>Note how the channel configurations CC1 and CC2 remain completely separate from each other, and completely separate from the network configuration, NC4. Again we’re seeing the de-centralized nature of a Hyperledger Fabric network; once channel C2 has been created, it is managed by organizations R2 and R3 independently to other network elements. Channel policies always remain separate from each other and can only be changed by the organizations authorized to do so in the channel.</p><p>请注意，通道配置CC1和CC2如何保持彼此完全独立，并与网络配置NC4完全独立。再次，我们看到了Hyperledger Fabric网络的去中心化性质；创建通道C2后，组织R2和R3会独立于其他网络元素来管理它。渠道策略始终保持彼此独立，并且只能由有权在通道中更改的组织进行更改。</p><p>As the network and channels evolve, so will the network and channel configurations. There is a process by which this is accomplished in a controlled manner – involving configuration transactions which capture the change to these configurations. Every configuration change results in a new configuration block transaction being generated, and <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/network/network.html#the-ordering-serivce" target="_blank" rel="noopener">later in this topic</a>, we’ll see how these blocks are validated and accepted to create updated network and channel configurations respectively.</p><p>随着网络和通道的发展，网络和通道的配置也将随之发展。有一个过程可以通过受控的方式完成此过程-涉及配置事务，这些事务捕获对这些配置的更改。每次配置更改都会导致生成新的配置块事务，本主题后面的内容，我们将看到如何验证和接受这些区块，以分别创建更新的网络和通道配置。</p><h3 id="Network-and-channel-configurations（网络与通道配置）">Network and channel configurations（网络与通道配置）</h3><p>Throughout our sample network, we see the importance of network and channel configurations. These configurations are important because they encapsulate the <strong>policies</strong> agreed by the network members, which provide a shared reference for controlling access to network resources. Network and channel configurations also contain <strong>facts</strong> about the network and channel composition, such as the name of consortia and its organizations.</p><p>通过我们简单的网络，我们看到了网络和通道配置的重要性。这些配置之所以如此重要是因为他们封装了网络成员的认可策略，这些策略提供了对网络资源的共享的控制。网络和通道配置还包含有关网络和通道组成的事实，比如联盟以及组成联盟的组织。</p><p>For example, when the network is first formed using the ordering service node O4, its behaviour is governed by the network configuration NC4. The initial configuration of NC4 only contains policies that permit organization R4 to manage network resources. NC4 is subsequently updated to also allow R1 to manage network resources. Once this change is made, any administrator from organization R1 or R4 that connects to O4 will have network management rights because that is what the policy in the network configuration NC4 permits. Internally, each node in the ordering service records each channel in the network configuration, so that there is a record of each channel created, at the network level.</p><p>例如，当首先使用排序服务节点O4形成网络时，其行为由网络配置NC4控制。NC4的初始配置仅包含允许组织R4管理网络资源的策略。随后将NC4更新为还允许R1管理网络资源。一旦做了这个更新，组织R1和R4的管理员都拥有了网络管理权限了，因为这是在网络配置NC2的策略中指定的。在内部，排序服务中的每个节点都会记录网络配置中的每个通道，以便在网络级别上记录每个创建的通道。</p><p>It means that although ordering service node O4 is the actor that created consortia X1 and X2 and channels C1 and C2, the <strong>intelligence</strong> of the network is contained in the network configuration NC4 that O4 is obeying. As long as O4 behaves as a good actor, and correctly implements the policies defined in NC4 whenever it is dealing with network resources, our network will behave as all organizations have agreed. In many ways NC4 can be considered more important than O4 because, ultimately, it controls network access.</p><p>这意味着尽管排序服务节点O4是创建联盟X1和X2以及渠道C1和C2的参与者，网络的智能包含在O4遵循的网络配置NC4中。只要O4表现出色，并且在处理网络资源时正确执行NC4中定义的策略，我们的网络将按照所有组织的同意行事。在许多方面，NC4比O4更重要，因为它最终控制了网络访问。</p><p>The same principles apply for channel configurations with respect to peers. In our network, P1 and P2 are likewise good actors. When peer nodes P1 and P2 are interacting with client applications A1 or A2 they are each using the policies defined within channel configuration CC1 to control access to the channel C1 resources.</p><p>相同的原则适用于有关peer节点的通道配置。在我们的网络中，P1和P2同样是好角色。当peer节点P1和P2与客户端应用程序A1或A2交互时，它们每个都使用在通道配置CC1中定义的策略来控制对通道C1资源的访问。</p><p>For example, if A1 wants to access the smart contract chaincode S5 on peer nodes P1 or P2, each peer node uses its copy of CC1 to determine the operations that A1 can perform. For example, A1 may be permitted to read or write data from the ledger L1 according to policies defined in CC1. We’ll see later the same pattern for actors in channel and its channel configuration CC2. Again, we can see that while the peers and applications are critical actors in the network, their behaviour in a channel is dictated more by the channel configuration policy than any other factor.</p><p>例如，如果A1想要在peer节点P1或P2上访问智能合约S5，每个对等节点使用其CC1副本确定A1可以执行的操作。比如，根据CC1中的策略定义A1可以可能可以读写账本L1。稍后我们将在通道及其通道配置CC2中看到针对角色的相同模式。同样，我们可以看到，尽管peer节点和应用程序是网络中的关键角色，它们在通道中的行为受通道配置策略的支配，而不是其他任何因素。</p><p>Finally, it is helpful to understand how network and channel configurations are physically realized. We can see that network and channel configurations are logically singular – there is one for the network, and one for each channel. This is important; every component that accesses the network or the channel must have a shared understanding of the permissions granted to different organizations.</p><p>最后，了解物理上如何实现网络和通道配置将很有帮助。我们可以看到网络和通道配置在逻辑上是唯一的，网络有一个配置，每个通道也都有一个配置。这个很重要，访问网络或通道的每个组件都必须对授予不同组织的权限有共同的了解。</p><p>Even though there is logically a single configuration, it is actually replicated and kept consistent by every node that forms the network or channel. For example, in our network peer nodes P1 and P2 both have a copy of channel configuration CC1, and by the time the network is fully complete, peer nodes P2 and P3 will both have a copy of channel configuration CC2. Similarly ordering service node O4 has a copy of the network configuration, but in a <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/network/network.html#the-ordering-service" target="_blank" rel="noopener">multi-node configuration</a>, every ordering service node will have its own copy of the network configuration.</p><p>即使从逻辑上讲只有一个配置，但实际上它被构成网络或通道的每个节点复制并保持一致。例如，在我们的网络peer节点P1和P2中都有一个通道配置CC1的副本，到网络完全完成时，peer节点P2和P3都将拥有通道配置CC2的副本。类似的排序服务节点O4有一个网络配置的副本，但是在多节点配置中，每个订购服务节点都将拥有自己的网络配置副本。</p><p>Both network and channel configurations are kept consistent using the same blockchain technology that is used for user transactions – but for <strong>configuration</strong> transactions. To change a network or channel configuration, an administrator must submit a configuration transaction to change the network or channel configuration. It must be signed by the organizations identified in the appropriate policy as being responsible for configuration change. This policy is called the <strong>mod_policy</strong> and we’ll <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/network/network.html#changing-policy" target="_blank" rel="noopener">discuss it later</a>.</p><p>网络和通道配置使用与用户交易相同的区块链技术保持不可篡改，但是这里是用的是<strong>配置</strong>交易。要修改一个网络或者通道的配置，管理员必须提交一个配置交易来更改网络或者通道的配置。必须由适当策略中确定负责配置更改的组织签名。这项政策称为<strong>mod_policy</strong>，我们将在后面讨论。</p><p>Indeed, the ordering service nodes operate a mini-blockchain, connected via the <strong>system channel</strong> we mentioned earlier. Using the system channel ordering service nodes distribute network configuration transactions. These transactions are used to co-operatively maintain a consistent copy of the network configuration at each ordering service node. In a similar way, peer nodes in an <strong>application channel</strong> can distribute channel configuration transactions. Likewise, these transactions are used to maintain a consistent copy of the channel configuration at each peer node.</p><p>的确，排序服务节点运行着一个微型区块链，通过我们前面提到的系统通道连接。排序服务节点使用系统通道来分发网络配置交易。这些交易用于保持每个排序服务节点合作维护网络配置有一致的副本。以类似的方式，应用程序通道中的peer节点可以分发通道配置交易。同样，这些交易用于保持在每个peer节点上维护的通道配置的副本一致。</p><p>This balance between objects that are logically singular, by being physically distributed is a common pattern in Hyperledger Fabric. Objects like network configurations, that are logically single, turn out to be physically replicated among a set of ordering services nodes for example. We also see it with channel configurations, ledgers, and to some extent smart contracts which are installed in multiple places but whose interfaces exist logically at the channel level. It’s a pattern you see repeated time and again in Hyperledger Fabric, and enables Hyperledger Fabric to be both de-centralized and yet manageable at the same time.</p><p>物理是分布式的，逻辑上是单一的这种对象之间的平衡是Hyperledger Fabric中的常见模式。例如，逻辑上单一的对象（如网络配置）实际上是在一组排序服务节点之间进行物理复制的。我们会在通道配置、账本和在某种程度上安装在多个位置但逻辑上存在于通道级别的智能合约上看到相同的情况。您在Hyperledger Fabric中一次又一次地看到这种模式，并使Hyperledger Fabric既可以分散管理，又可以同时进行管理。</p><h2 id="Adding-another-peer（添加另一个peer节点）">Adding another peer（添加另一个peer节点）</h2><p>Now that organization R3 is able to fully participate in channel C2, let’s add its infrastructure components to the channel. Rather than do this one component at a time, we’re going to add a peer, its local copy of a ledger, a smart contract and a client application all at once!</p><p>现在组织R3可以完全参与渠道C2了，让我们将其基础结构组件添加到渠道中。我们不会一次添加一个组件，而是一次添加一个peer以及其账本的本地副本、智能合约和客户端应用程序！</p><p>Let’s see the network with organization R3’s components added:</p><p>让我们看一下添加了组织R3组件的网络：</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/network.diagram.11.png" alt="network.diagram.11"></p><p><em>The diagram shows the facts relating to channels C1 and C2 in the network N as follows: Client applications A1 and A2 can use channel C1 for communication with peers P1 and P2, and ordering service O4; client applications A3 can use channel C2 for communication with peer P3 and ordering service O4. Ordering service O4 can make use of the communication services of channels C1 and C2. Channel configuration CC1 applies to channel C1, CC2 applies to channel C2.</em></p><p><em>该图显示了与网络N中的通道C1和C2有关的事实，如下所示：客户端应用程序A1和A2可以使用通道C1来与peer节点P1和P2以及排序服务O4进行通信；客户端应用程序A3可以使用通道来与peer节点P3和排序服务O4进行通信。排序服务O4可以利用通道C1和C2的通信服务。通道配置CC1适用于通道C1，CC2适用于通道C2。</em></p><p>First of all, notice that because peer node P3 is connected to channel C2, it has a <strong>different</strong> ledger – L2 – to those peer nodes using channel C1. The ledger L2 is effectively scoped to channel C2. The ledger L1 is completely separate; it is scoped to channel C1. This makes sense – the purpose of the channel C2 is to provide private communications between the members of the consortium X2, and the ledger L2 is the private store for their transactions.</p><p>首先，请注意，由于peer节点P3连接到通道C2，他拥有一个与通道C1上的节点不一样的账本L2。账本L2的有效范围为通道C2。分类帐L1是完全独立的；它的作用域是通道C1。这是有道理的-通道C2的目的是在财团X2的成员之间提供私人通信，而分类帐L2是其交易的私人商店。</p><p>In a similar way, the smart contract S6, installed on peer node P3, and defined on channel C2, is used to provide controlled access to ledger L2. Application A3 can now use channel C2 to invoke the services provided by smart contract S6 to generate transactions that can be accepted onto every copy of the ledger L2 in the network.</p><p>以类似的方式，安装在peer节点P3上并定义在通道C2上的智能合约S6用于提供对账本L2的受控访问。应用程序A3现在可以使用通道C2来调用智能合约S6提供的服务来生成交易，以生成可以被接受到网络中账本L2的每个副本上的交易。</p><p>At this point in time, we have a single network that has two completely separate channels defined within it. These channels provide independently managed facilities for organizations to transact with each other. Again, this is de-centralization at work; we have a balance between control and autonomy. This is achieved through policies which are applied to channels which are controlled by, and affect, different organizations.</p><p>此时，我们有了一个网络，其中定义了两个完全独立的通道。这些通道为组织提供了相互独立管理的设施，以便彼此进行交易。同样，这是工作中的分权；我们在控制和自治之间取得平衡。这是通过将策略应用到受不同组织控制并影响不同组织的渠道来实现的。</p><h2 id="Joining-a-peer-to-multiple-channels（把一个peer节点加入到不同通道）">Joining a peer to multiple channels（把一个peer节点加入到不同通道）</h2><p>In this final stage of network development, let’s return our focus to organization R2. We can exploit the fact that R2 is a member of both consortia X1 and X2 by joining it to multiple channels:</p><p>在网络开发的最后阶段，让我们把重点放回到组织R2。我们可以利用R2是X1和X2联盟的成员这一事实来将R2加入多个渠道：</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/network.diagram.12.png" alt="network.diagram.12"></p><p><em>The diagram shows the facts relating to channels C1 and C2 in the network N as follows: Client applications A1 can use channel C1 for communication with peers P1 and P2, and ordering service O4; client application A2 can use channel C1 for communication with peers P1 and P2 and channel C2 for communication with peers P2 and P3 and ordering service O4; client application A3 can use channel C2 for communication with peer P3 and P2 and ordering service O4. Ordering service O4 can make use of the communication services of channels C1 and C2. Channel configuration CC1 applies to channel C1, CC2 applies to channel C2.</em></p><p><em>该图显示了与网络N中的通道C1和C2有关的下面的事实：客户端应用程序A1可以使用通道C1来与peer节点P1和P2以及排序服务O4进行通信；客户端应用程序A2可以使用通道C1来和peer节点P1和P2通信，并且使用C2来与peer节点P2和P3以及排序服务O4进行通信；客户端应用程序A3可以使用通道C2来与peer节点P3和P2以及排序服务O4进行通信。排序服务O4可以使用通道C1和C2上的通信服务。通道配置CC1服务于通道C1、CC2服务与通道C2。</em></p><p>We can see that R2 is a special organization in the network, because it is the only organization that is a member of two application channels! It is able to transact with organization R1 on channel C1, while at the same time it can also transact with organization R3 on a different channel, C2.</p><p>我们可以看到R2是网络上的一个特殊的组织，因为它是两个应用程序通道的成员的唯一组织！他可以在通道C1上与组织R1进行交易，同时它也可以在另一个不同的通道C2上与组织R3进行交易。</p><p>Notice how peer node P2 has smart contract S5 installed for channel C1 and smart contract S6 installed for channel C2. Peer node P2 is a full member of both channels at the same time via different smart contracts for different ledgers.</p><p>请注意，peer节点P2如何为通道C1安装了智能合约S5，并为通道C2安装了智能合约S6。peer节点P2通过不同账本的不同智能合约同时是两个渠道的正式成员。</p><p>This is a very powerful concept – channels provide both a mechanism for the separation of organizations, and a mechanism for collaboration between organizations. All the while, this infrastructure is provided by, and shared between, a set of independent organizations.</p><p>这是一个非常强大的概念-渠道既提供了组织分离的机制，也提供了组织之间协作的机制。一直以来，此基础结构（即通道）由一组独立的组织提供并在它们之间共享。</p><p>It is also important to note that peer node P2’s behaviour is controlled very differently depending upon the channel in which it is transacting. Specifically, the policies contained in channel configuration CC1 dictate the operations available to P2 when it is transacting in channel C1, whereas it is the policies in channel configuration CC2 that control P2’s behaviour in channel C2.</p><p>同样重要的是要注意，peer节点P2的行为受其进行交易的通道的控制非常不同。具体而言，通道配置CC1中包含的策略规定了P2在通道C1中进行交易时可使用的操作，而通道配置CC2中的策略控制渠道P2在渠道C2中的行为。</p><p>Again, this is desirable – R2 and R1 agreed the rules for channel C1, whereas R2 and R3 agreed the rules for channel C2. These rules were captured in the respective channel policies – they can and must be used by every component in a channel to enforce correct behaviour, as agreed.</p><p>同样，R2和R1同意通道C1的规则，而R2和R3同意了通道C2的规则是可取的。这些规则是在各自的通道的政策中获取的-渠道中的每个组件都可以并且必须使用它们来强制执行正确的行为，这已经达成共识。</p><p>Similarly, we can see that client application A2 is now able to transact on channels C1 and C2. And likewise, it too will be governed by the policies in the appropriate channel configurations. As an aside, note that client application A2 and peer node P2 are using a mixed visual vocabulary – both lines and connections. You can see that they are equivalent; they are visual synonyms.</p><p>同样，我们可以看到客户端应用程序A2现在能够在通道C1和C2上进行交易。同样，它也将由适当的通道配置中的策略控制。顺便提一句，请注意客户端应用程序A2和peer节点P2正在使用混合的可视词汇表（包括行和连接）。您可以看到它们是等效的。它们是视觉同义词。</p><h3 id="The-ordering-service（排序服务）">The ordering service（排序服务）</h3><p>The observant reader may notice that the ordering service node appears to be a centralized component; it was used to create the network initially, and connects to every channel in the network. Even though we added R1 and R4 to the network configuration policy NC4 which controls the orderer, the node was running on R4’s infrastructure. In a world of de-centralization, this looks wrong!</p><p>细心的读者可能会注意到排序服务节点似乎是一个集中式组件，他被用于创建初始化网络，并且链接网络中的所有的通道。即使我们在控制排序者的网络配置策略NC4中添加了R1和R4，该节点仍在R4的基础架构上运行。在去中心化的世界中，这看起来是错误的！</p><p>Don’t worry! Our example network showed the simplest ordering service configuration to help you understand the idea of a network administration point. In fact, the ordering service can itself too be completely de-centralized! We mentioned earlier that an ordering service could be comprised of many individual nodes owned by different organizations, so let’s see how that would be done in our sample network.</p><p>不要担心！我们的示例网络显示了最简单的排序服务配置，以帮助您了解网络管理点的概念。事实上，排序服务自己也是完全去中心化的。前面我们提到过，排序服务可以由不同组织拥有的许多单个节点组成，因此让我们看看如何在示例网络中完成该工作。</p><p>Let’s have a look at a more realistic ordering service node configuration:</p><p>让我们看一个更接近现实的排序服务节点配置：</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/network.diagram.15.png" alt="network.diagram.15"></p><p><em>A multi-organization ordering service. The ordering service comprises ordering service nodes O1 and O4. O1 is provided by organization R1 and node O4 is provided by organization R4. The network configuration NC4 defines network resource permissions for actors from both organizations R1 and R4.</em></p><p><em>多组织的排序服务。排序服务包含排序节点O1和O4。O1是由组织R1提供而节点O4是由组织R4提供。网络配置NC4为组织R1和R4的参与者定义了网络资源权限。</em></p><p>We can see that this ordering service completely de-centralized – it runs in organization R1 and it runs in organization R4. The network configuration policy, NC4, permits R1 and R4 equal rights over network resources. Client applications and peer nodes from organizations R1 and R4 can manage network resources by connecting to either node O1 or node O4, because both nodes behave the same way, as defined by the policies in network configuration NC4. In practice, actors from a particular organization <em>tend</em> to use infrastructure provided by their home organization, but that’s certainly not always the case.</p><p>我们看到排序服务已经是完全的去中心化了，他运行在组织R1和R4上。网络配置策略NC4，允许R1和R4在网络资源上享有同等的权利。组织R1和R4的客户端程序和peer节点可以通过O1和O4的任意一个来管理网络上的资源，因为两个节点的行为方式均与网络配置NC4中的策略所定义的方式相同。实际上，来自特定组织的参与者往往会使用其上级组织提供的基础架构，但这并非总是如此。</p><h3 id="De-centralized-transaction-distribution（去中心化的交易分发）">De-centralized transaction distribution（去中心化的交易分发）</h3><p>As well as being the management point for the network, the ordering service also provides another key facility – it is the distribution point for transactions. The ordering service is the component which gathers endorsed transactions from applications and orders them into transaction blocks, which are subsequently distributed to every peer node in the channel. At each of these committing peers, transactions are recorded, whether valid or invalid, and their local copy of the ledger updated appropriately.</p><p>排序服务不仅是网络的管理点，还提供了另一个关键功能–它是交易的分发点。排序服务是一个组件，这个组件从应用程序中收集认可交易并将其排序到交易块中，随后分发给通道中的每个peer节点。在每个提交节点中，交易会被记录（不论是成功还是失败），并在本地更新账本。</p><p>Notice how the ordering service node O4 performs a very different role for the channel C1 than it does for the network N. When acting at the channel level, O4’s role is to gather transactions and distribute blocks inside channel C1. It does this according to the policies defined in channel configuration CC1. In contrast, when acting at the network level, O4’s role is to provide a management point for network resources according to the policies defined in network configuration NC4. Notice again how these roles are defined by different policies within the channel and network configurations respectively. This should reinforce to you the importance of declarative policy based configuration in Hyperledger Fabric. Policies both define, and are used to control, the agreed behaviours by each and every member of a consortium.</p><p>请注意，排序服务节点O4如何对通道C1起到与对网络N完全不同的作用。在作用于通道级别时，O4的作用是在通道C1里面收集和分发区块的。它根据通道配置CC1中定义的策略执行此操作。作为对比，在网络级别执行操作时，O4的作用是根据网络配置NC4中定义的策略为网络资源提供管理点。再次注意，这些角色是如何分别由通道和网络配置中的不同策略定义的。这应该向您强调Hyperledger Fabric中基于声明策略的配置的重要性。策略既定义了联盟的每个成员，又用于控制联盟的每个成员的行为。</p><p>We can see that the ordering service, like the other components in Hyperledger Fabric, is a fully de-centralized component. Whether acting as a network management point, or as a distributor of blocks in a channel, its nodes can be distributed as required throughout the multiple organizations in a network.</p><p>我们看到像Hyperledger Fabric中的其他组件一样，排序服务是一个完全的去中心化的组件。无论是充当网络管理点，还是充当通道中的区块分配器，它的节点可以根据需要分布在网络中的多个组织中。</p><h3 id="Changing-policy（修改策略）">Changing policy（修改策略）</h3><p>Throughout our exploration of the sample network, we’ve seen the importance of the policies to control the behaviour of the actors in the system. We’ve only discussed a few of the available policies, but there are many that can be declaratively defined to control every aspect of behaviour. These individual policies are discussed elsewhere in the documentation.</p><p>在整个示例网络的探索过程中，我们已经了解了控制系统中参与者行为的策略的重要性。我们仅讨论了一些可用的策略，但是可以声明性地定义许多策略来控制行为的各个方面。这些单独的策略在文档的其他地方进行了讨论。</p><p>Most importantly of all, Hyperledger Fabric provides a uniquely powerful policy that allows network and channel administrators to manage policy change itself! The underlying philosophy is that policy change is a constant, whether it occurs within or between organizations, or whether it is imposed by external regulators. For example, new organizations may join a channel, or existing organizations may have their permissions increased or decreased. Let’s investigate a little more how change policy is implemented in Hyperledger Fabric.</p><p>最重要的是，Hyperledger Fabric 提供了独特而强大的策略，允许网络和通道管理员自行管理策略更改！基本理念是政策变化是一个持续不断的过程，不论它是在组织内部还是组织之间发生，还是由外部监管机构强加。例如，新组织可以加入通道，或者现有组织的权限可以增加或减少。让我们研究一下Hyperledger Fabric中更改策略的实现方式。</p><p>The key point of understanding is that policy change is managed by a policy within the policy itself. The <strong>modification policy</strong>, or <strong>mod_policy</strong> for short, is a first class policy within a network or channel configuration that manages change. Let’s give two brief examples of how we’ve <strong>already</strong> used mod_policy to manage change in our network!</p><p>理解的关键点是，策略更改由策略本身内的策略来管理。<strong>modification policy（修改策略）<strong>或者简称为</strong>mod_policy</strong>，是一个在网络或渠道配置中管理变更的头等仓的策略。让我们举两个简单的例子，说明我们是如何使用mod_policy来管理网络中的更改的！</p><p>The first example was when the network was initially set up. At this time, only organization R4 was allowed to manage the network. In practice, this was achieved by making R4 the only organization defined in the network configuration NC4 with permissions to network resources. Moreover, the mod_policy for NC4 only mentioned organization R4 – only R4 was allowed to change this configuration.</p><p>第一个示例是最初建立网络时。此时，只有组织R4允许管理网络。在实践中，这是通过使R4成为网络配置NC4中定义的唯一拥有网络资源权限的组织来实现的。此外，NC4的mod_policy仅提及组织R4 –仅允许R4更改此配置。</p><p>We then evolved the network N to also allow organization R1 to administer the network. R4 did this by adding R1 to the policies for channel creation and consortium creation. Because of this change, R1 was able to define the consortia X1 and X2, and create the channels C1 and C2. R1 had equal administrative rights over the channel and consortium policies in the network configuration.</p><p>然后，我们对网络N进行了演进，以也允许组织R1管理网络。R4通过将R1添加到用于通道创建和联盟创建的策略中来做到这一点。因为这个变更，R1可以定义联盟X1和X2，并且创建了通道C1和C2。网络配置中策略指明R1对通道和联盟具有同等的管理权限。</p><p>R4 however, could grant even more power over the network configuration to R1! R4 could add R1 to the mod_policy such that R1 would be able to manage change of the network policy too.</p><p>但是，R4可以通过网络配置向R1授予更多权利。R4可以将R1添加到mod_policy中，以便R1也能够管理网络策略的更改。</p><p>This second power is much more powerful than the first, because R1 now has <strong>full control</strong> over the network configuration NC4! This means that R1 can, in principle remove R4’s management rights from the network. In practice, R4 would configure the mod_policy such that R4 would need to also approve the change, or that all organizations in the mod_policy would have to approve the change. There’s lots of flexibility to make the mod_policy as sophisticated as it needs to be to support whatever change process is required.</p><p>第二个权利相比于第一个来说强大的多，因为R1现在可以完全控制网络配置NC4！这意味着R1原则上可以从网络中删除R4的管理权限。在实践中，R4将把mod_policy配置成为R4需要批准配置更改，或者mod_policy中的所有组织都必须批准更改。有足够的灵活性可以使mod_policy复杂到可以支持所需的任何更改过程。</p><p>This is mod_policy at work – it has allowed the graceful evolution of a basic configuration into a sophisticated one. All the time this has occurred with the agreement of all organization involved. The mod_policy behaves like every other policy inside a network or channel configuration; it defines a set of organizations that are allowed to change the mod_policy itself.</p><p>这就是mod_policy的作用，它使基本配置可以优雅地演变为复杂的配置。在所有相关组织达成一致之后，这种情况一直存在。mod_policy的行为与网络或通道配置中的所有其他策略相同；它定义了一组允许更改mod_policy本身的组织。</p><p>We’ve only scratched the surface of the power of policies and mod_policy in particular in this subsection. It is discussed at much more length in the policy topic, but for now let’s return to our finished network!</p><p>在本小节中，我们仅介绍了策略和mod_policy的功能。在策略主题中将对它进行更详细的讨论，但现在让我们回到完成的网络中！</p><h2 id="Network-fully-formed（网络全面形成）">Network fully formed（网络全面形成）</h2><p>Let’s recap what our network looks like using a consistent visual vocabulary. We’ve re-organized it slightly using our more compact visual syntax, because it better accommodates larger topologies:</p><p>让我们使用一致的视觉词汇来回顾一下我们的网络。我们使用更紧凑的视觉语法对其进行了稍微的重组，因为它可以更好地适应更大的拓扑：</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/network.diagram.14.png" alt="network.diagram.14"></p><p><em>In this diagram we see that the Fabric blockchain network consists of two application channels and one ordering channel. The organizations R1 and R4 are responsible for the ordering channel, R1 and R2 are responsible for the blue application channel while R2 and R3 are responsible for the red application channel. Client applications A1 is an element of organization R1, and CA1 is it’s certificate authority. Note that peer P2 of organization R2 can use the communication facilities of the blue and the red application channel. Each application channel has its own channel configuration, in this case CC1 and CC2. The channel configuration of the system channel is part of the network configuration, NC4.</em></p><p><em>在我们看到的这个图片中，Fabirc区块链网络包含两个应用程序通道和一个排序通道。组织R1和R4负责排序通道，R1和R2负责蓝色应用程序通道，而R2和R3负责红色应用程序通道。客户端应用程序A1是组织R1的元素，而CA1是组织的证书颁发机构。注意属于组织R2的Peer节点P2可以同时使用红色和蓝色的应用程序通道的通信设施。每个应用程序通道都有自己的通道配置，例如CC1和CC2。系统通道的通道配置是网络配置（NC4）的一部分。</em></p><p>We’re at the end of our conceptual journey to build a sample Hyperledger Fabric blockchain network. We’ve created a four organization network with two channels and three peer nodes, with two smart contracts and an ordering service. It is supported by four certificate authorities. It provides ledger and smart contract services to three client applications, who can interact with it via the two channels. Take a moment to look through the details of the network in the diagram, and feel free to read back through the topic to reinforce your knowledge, or go to a more detailed topic.</p><p>我们构建简单的Hyperledger Fabric区块链网络的概念之旅已结束。我们创建了一个具有两个通道和三个peer节点，两个智能合约和一个排序服务的四个组织的网络。这个网络由四个证书颁发机构支持。这个网络对三个客户端应用程序提供账本和智能合约服务，他们可以通过两个通道与之交互。花一点时间浏览图中的网络详细信息，并随时阅读本主题以增强您的知识，或者转到更详细的主题。</p><h3 id="Summary-of-network-components（网络组件的摘要）">Summary of network components（网络组件的摘要）</h3><p>Here’s a quick summary of the network components we’ve discussed（以下是我们讨论过的网络组件的简要摘要）：</p><ul><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#ledger" target="_blank" rel="noopener">Ledger</a>. One per channel. Comprised of the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#block" target="_blank" rel="noopener">Blockchain</a> and the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#world-state" target="_blank" rel="noopener">World state</a>（每个通道一个。由区块链和世界状态组成）</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#smart-contract" target="_blank" rel="noopener">Smart contract</a> (aka chaincode)（Also Known As智能合约）</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#peer" target="_blank" rel="noopener">Peer nodes</a>（peer节点）</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#ordering-service" target="_blank" rel="noopener">Ordering service</a>（排序服务）</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#channel" target="_blank" rel="noopener">Channel</a>（通道）</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#hyperledger-fabric-ca" target="_blank" rel="noopener">Certificate Authority</a>（证书颁发机构）</li></ul><h2 id="Network-summary（网络总结）">Network summary（网络总结）</h2><p>In this topic, we’ve seen how different organizations share their infrastructure to provide an integrated Hyperledger Fabric blockchain network. We’ve seen how the collective infrastructure can be organized into channels that provide private communications mechanisms that are independently managed. We’ve seen how actors such as client applications, administrators, peers and orderers are identified as being from different organizations by their use of certificates from their respective certificate authorities. And in turn, we’ve seen the importance of policy to define the agreed permissions that these organizational actors have over network and channel resources.</p><p>在本主题中，我们已经看到了不同的组织如何共享其基础架构以提供集成Hyperledger Fabric区块链网络。我们已经看到了如何将集体基础结构组织为提供独立管理的私有通信机制的通道。我们已经了解了如何通过使用来自各自证书颁发机构的证书将诸如客户端应用程序，管理员，peer节点和排序者之类的参与者识别为来自不同组织。反过来，我们已经看到了定义这些组织参与者对网络和通道资源拥有的同意权限的政策的重要性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Blockchain-network-Fabric的网络&quot;&gt;Blockchain network(Fabric的网络)&lt;/h2&gt;
&lt;p&gt;原始官方文档：&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/rel</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="Key Concepts" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/Key-Concepts/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="network" scheme="https://guozhe001.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Hyperledger-Fabric模型</title>
    <link href="https://guozhe001.github.io/2021/01/15/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Hyperledger-Fabric%E6%A8%A1%E5%9E%8B/"/>
    <id>https://guozhe001.github.io/2021/01/15/blockchain/fabric/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/Hyperledger-Fabric%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-01-15T02:53:13.529Z</published>
    <updated>2021-01-19T10:59:12.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hyperledger-Fabric模型">Hyperledger-Fabric模型</h1><p>This section outlines the key design features woven into Hyperledger Fabric that fulfill its promise of a comprehensive, yet customizable, enterprise blockchain solution:</p><p>本节概述了编织到Hyperledger Fabric中的关键设计功能，这些功能实现了其全面，可定制的企业区块链解决方案的承诺：</p><ul><li><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/fabric_model.html#assets" target="_blank" rel="noopener">Assets</a> — Asset definitions enable the exchange of almost anything with monetary value over the network, from whole foods to antique cars to currency futures.</p><p>资产定义了允许通过网络交换的几乎所有具有货币价值的东西，从食品到古董车再到货币期货。</p></li><li><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/fabric_model.html#chaincode" target="_blank" rel="noopener">Chaincode</a> — Chaincode execution is partitioned from transaction ordering, limiting the required levels of trust and verification across node types, and optimizing network scalability and performance.</p><p>链码执行从交易顺序中划分出来，从而限制了跨节点类型所需的信任和验证级别，并优化网络可伸缩和性能。</p></li><li><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/fabric_model.html#ledger-features" target="_blank" rel="noopener">Ledger Features</a> — The immutable, shared ledger encodes the entire transaction history for each channel, and includes SQL-like query capability for efficient auditing and dispute resolution.</p><p>不变的，共享的账本对每个通道的整个交易历史进行编码，并包括类似SQL的查询功能，以进行有效的审计和争议解决。</p></li><li><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/fabric_model.html#privacy" target="_blank" rel="noopener">Privacy</a> — Channels and private data collections enable private and confidential multi-lateral transactions that are usually required by competing businesses and regulated industries that exchange assets on a common network.</p><p>通道和隐私数据收集可实现私人和机密的多边交易，通常是在竞争企业和受管制的行业（在同一网络上交换资产）所需要。</p></li><li><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/fabric_model.html#security-membership-services" target="_blank" rel="noopener">Security &amp; Membership Services</a> — Permissioned membership provides a trusted blockchain network, where participants know that all transactions can be detected and traced by authorized regulators and auditors.</p><p>获得许可的成员资格提供了一个受信任的区块链网络，参与者知道所有交易都可以由授权的监管机构和审计师检测和追踪。</p></li><li><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/fabric_model.html#consensus" target="_blank" rel="noopener">Consensus</a> — A unique approach to consensus enables the flexibility and scalability needed for the enterprise.</p><p>一种唯一的共识方法可以实现企业所需的灵活性和可伸缩性。</p></li></ul><h2 id="Assets">Assets</h2><p>Assets can range from the tangible (real estate and hardware) to the intangible (contracts and intellectual property). Hyperledger Fabric provides the ability to modify assets using chaincode transactions.</p><p>资产范围从有形资产（房地产和硬件）到无形资产（合同和知识产权）。Hyperledger Fabric提供了使用链码交易修改资产的功能。</p><p>Assets are represented in Hyperledger Fabric as a collection of key-value pairs, with state changes recorded as transactions on a <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#channel" target="_blank" rel="noopener">Channel</a> ledger. Assets can be represented in binary and/or JSON form.</p><p>资产在Hyperledger Fabric中表示为键值对的集合，状态更改记录为通道账本中的交易。资产可以二进制和/或JSON形式表示。</p><h2 id="Chaincode">Chaincode</h2><p>Chaincode is software defining an asset or assets, and the transaction instructions for modifying the asset(s); in other words, it’s the business logic. Chaincode enforces the rules for reading or altering key-value pairs or other state database information. Chaincode functions execute against the ledger’s current state database and are initiated through a transaction proposal. Chaincode execution results in a set of key-value writes (write set) that can be submitted to the network and applied to the ledger on all peers.</p><p>链码是定义了一个或多个资产的软件，以及用于修改资产的交易指令；Chaincode强制执行用于读取或更改键值对或其他状态数据库信息的规则。链码功能针对账本的当前状态数据库执行，并通过交易提议启动。链码执行产生的一组键值写操作（写集），这些键值写操作可以提交给网络，并应用于所有peer的账本中。</p><h2 id="Ledger-Features">Ledger Features</h2><p>The ledger is the sequenced, tamper-resistant record of all state transitions in the fabric. State transitions are a result of chaincode invocations (‘transactions’) submitted by participating parties. Each transaction results in a set of asset key-value pairs that are committed to the ledger as creates, updates, or deletes.</p><p>账本是Fabric中所有有序的、防篡改的状态转换。状态转换是参与方提交的链码调用（“交易”）的结果。每个交易都会产生一组资产键值对，这些键值对会在创建，更新或删除时提交到账本中。</p><p>The ledger is comprised of a blockchain (‘chain’) to store the immutable, sequenced record in blocks, as well as a state database to maintain current fabric state. There is one ledger per channel. Each peer maintains a copy of the ledger for each channel of which they are a member.</p><p>账本由区块链组成，以区块形式存储不可变的、有序的记录，以及用于维护当前结构状态的状态数据库。每个通道有一个账本。每个peer都为其所属的每个通道维护一个账本的副本。</p><p>Some features of a Fabric ledger（Fabric账本的一些功能）:</p><ul><li><p>Query and update ledger using key-based lookups, range queries, and composite key queries</p><p>使用基于键的查找，范围查询和组合键查询来查询和更新分类帐</p></li><li><p>Read-only queries using a rich query language (if using CouchDB as state database)</p><p>使用丰富查询语言的只读查询（如果使用CouchDB作为状态数据库）</p></li><li><p>Read-only history queries — Query ledger history for a key, enabling data provenance scenarios</p><p>只读历史记录查询—为一个key查询史记录，从而启用数据出处场景</p></li><li><p>Transactions consist of the versions of keys/values that were read in chaincode (read set) and keys/values that were written in chaincode (write set)</p><p>交易由链码中读取的键/值的版本 (读取集)和用链码编写的键/值（写入集）所组成。</p></li><li><p>Transactions contain signatures of every endorsing peer and are submitted to ordering service</p><p>交易包含每个背书peer的签名，并提交给排序服务</p></li><li><p>Transactions are ordered into blocks and are “delivered” from an ordering service to peers on a channel</p><p>交易被排序并打包成区块，并从排序服务“交付”到通道上的peer节点</p></li><li><p>Peers validate transactions against endorsement policies and enforce the policies</p><p>Peer根据背书策略验证交易并执行政策</p></li><li><p>Prior to appending a block, a versioning check is performed to ensure that states for assets that were read have not changed since chaincode execution time</p><p>在追加区块之前，执行版本检查，以确保自链码执行以来，已读取资产的状态未发生变化</p></li><li><p>There is immutability once a transaction is validated and committed</p><p>交易一旦经过验证并提交，便具有不变性</p></li><li><p>A channel’s ledger contains a configuration block defining policies, access control lists, and other pertinent information</p><p>通道的账本包含一个配置块，用于定义策略、访问控制列表和其他相关信息</p></li><li><p>Channels contain <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#msp" target="_blank" rel="noopener">Membership Service Provider</a> instances allowing for crypto materials to be derived from different certificate authorities</p><p>通道包含MSP实例，允许从不同的证书颁发机构生成加密材料</p></li></ul><p>See the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/ledger.html" target="_blank" rel="noopener">Ledger</a> topic for a deeper dive on the databases, storage structure, and “query-ability.”</p><p>有关数据库，存储结构和“查询能力”的更深入了解，请参阅<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/ledger.html" target="_blank" rel="noopener">账本</a>主题。</p><h2 id="Privacy">Privacy</h2><p>Hyperledger Fabric employs an immutable ledger on a per-channel basis, as well as chaincode that can manipulate and modify the current state of assets (i.e. update key-value pairs). A ledger exists in the scope of a channel — it can be shared across the entire network (assuming every participant is operating on one common channel) — or it can be privatized to include only a specific set of participants.</p><p>Hyperledger Fabric在每个通道的基础上使用不变的账本，以及可以操纵和修改资产当前状态的链码。账本存在于通道范围内-可以在整个网络中共享（假设每个参与者都在一个公共频道上进行操作）也可以仅包括一组特定的参与者以将其私有化。</p><p>In the latter scenario, these participants would create a separate channel and thereby isolate/segregate their transactions and ledger. In order to solve scenarios that want to bridge the gap between total transparency and privacy, chaincode can be installed only on peers that need to access the asset states to perform reads and writes (in other words, if a chaincode is not installed on a peer, it will not be able to properly interface with the ledger).</p><p>在后一种情况下，这些参与者将创建一个单独的通道，从而隔离/分离他们的交易和账本。为了解决总体透明度和隐私之间存在间隙的场景，链码只能安装在需要访问资产状态以执行读写的peer节点上（换句话说，如果未在peer节点上安装链码，则它将无法与账本正确连接）。</p><p>When a subset of organizations on that channel need to keep their transaction data confidential, a private data collection (collection) is used to segregate this data in a private database, logically separate from the channel ledger, accessible only to the authorized subset of organizations.</p><p>当该渠道上的部分组织需要对其交易数据保密时，私有数据集合用于将这些数据隔离在私有数据库中，从逻辑上与通道账本隔离，并仅允许组织的授权子集访问。</p><p>Thus, channels keep transactions private from the broader network whereas collections keep data private between subsets of organizations on the channel.</p><p>因此，通道使交易对于更广泛的网络而言是不公开的，而集合则对通道上的组织子集之间的数据不公开。</p><p>To further obfuscate the data, values within chaincode can be encrypted (in part or in total) using common cryptographic algorithms such as AES before sending transactions to the ordering service and appending blocks to the ledger. Once encrypted data has been written to the ledger, it can be decrypted only by a user in possession of the corresponding key that was used to generate the cipher text.</p><p>为了进一步混淆数据，在将chaincode中的数据发送给排序服务和追加到账本区块上之前可以使用标准的加密算法（如AES）进行加密。加密数据一旦写入分类帐，则只有拥有用于生成密文的密钥的用户才能对其解密。</p><p>See the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private-data-arch.html" target="_blank" rel="noopener">Private Data</a> topic for more details on how to achieve privacy on your blockchain network.</p><p>有关如何在区块链网络上实现隐私的更多详细信息，请参阅<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private-data-arch.html" target="_blank" rel="noopener">私有数据</a>主题。</p><h2 id="Security-Membership-Services">Security &amp; Membership Services</h2><p>Hyperledger Fabric underpins a transactional network where all participants have known identities. Public Key Infrastructure is used to generate cryptographic certificates which are tied to organizations, network components, and end users or client applications. As a result, data access control can be manipulated and governed on the broader network and on channel levels. This “permissioned” notion of Hyperledger Fabric, coupled with the existence and capabilities of channels, helps address scenarios where privacy and confidentiality are paramount concerns.</p><p>Hyperledger Fabric支持所有参与者都具有已知身份的交易网络。公钥基础结构用于生成与组织，网络组件以及最终用户或客户端应用程序绑定的加密证书。结果，可以在更广泛的网络和通道级别上操纵和控制数据访问控制。Hyperledger Fabric的“许可”概念以及通道的存在和功能，帮助解决隐私和机密至关重要的情况。</p><p>See the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/msp.html" target="_blank" rel="noopener">Membership Service Providers (MSP)</a> topic to better understand cryptographic implementations, and the sign, verify, authenticate approach used in Hyperledger Fabric.</p><h2 id="Consensus">Consensus</h2><p>In distributed ledger technology, consensus has recently become synonymous with a specific algorithm, within a single function. However, consensus encompasses more than simply agreeing upon the order of transactions, and this differentiation is highlighted in Hyperledger Fabric through its fundamental role in the entire transaction flow, from proposal and endorsement, to ordering, validation and commitment. In a nutshell, consensus is defined as the full-circle verification of the correctness of a set of transactions comprising a block.</p><p>在分布式分类帐技术中，共识最近已成为单一功能内特定算法的同义词。但是，共识不只是简单地约定交易顺序，Hyperledger Fabric通过在整个交易流程（从提案和认可，到排序，验证和提交）中的基本作用，突显了这种差异。简而言之，共识被定义为对包含一个区块的一组交易的正确性的全面验证。</p><p>Consensus is achieved ultimately when the order and results of a block’s transactions have met the explicit policy criteria checks. These checks and balances take place during the lifecycle of a transaction, and include the usage of endorsement policies to dictate which specific members must endorse a certain transaction class, as well as system chaincodes to ensure that these policies are enforced and upheld. Prior to commitment, the peers will employ these system chaincodes to make sure that enough endorsements are present, and that they were derived from the appropriate entities. Moreover, a versioning check will take place during which the current state of the ledger is agreed or consented upon, before any blocks containing transactions are appended to the ledger. This final check provides protection against double spend operations and other threats that might compromise data integrity, and allows for functions to be executed against non-static variables.</p><p>区块交易的顺序和结果满足明确的策略标准检查后，才能最终达成共识。这些检查和平衡发生在交易的生命周期中，并包括使用背书策略规定哪些特定成员必须背书某个交易类别，以及系统链码确保这些策略得到实施和维护。在作出承诺之前，peer将使用这些系统链码来确保存在足够的背书，并且背书来自适当的实体。此外，在将包含交易的任何块追加到账本之前，将进行版本控制检查，在此期间将对账本的当前状态进行被同意或同意。最终检查可以防止重复使用操作和其他可能危害数据完整性的威胁，并允许针对非静态变量执行功能。</p><p>In addition to the multitude of endorsement, validity and versioning checks that take place, there are also ongoing identity verifications happening in all directions of the transaction flow. Access control lists are implemented on hierarchical layers of the network (ordering service down to channels), and payloads are repeatedly signed, verified and authenticated as a transaction proposal passes through the different architectural components. To conclude, consensus is not merely limited to the agreed upon order of a batch of transactions; rather, it is an overarching characterization that is achieved as a byproduct of the ongoing verifications that take place during a transaction’s journey from proposal to commitment.</p><p>除了进行大量的背书，有效性和版本检查外，还在交易流程的各个方向上都在进行身份验证。访问控制列表是在网络的分层的层面实现的，当交易提议通过不同的架构组件时，有效载荷将被反复签名，验证和认证。总而言之，共识不仅限于一批交易的商定顺序；它更是一项总体特征，它是交易从提案到承诺过程中不断进行的验证的副产品。</p><p>Check out the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/txflow.html" target="_blank" rel="noopener">Transaction Flow</a> diagram for a visual representation of consensus.</p><p>查看<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/txflow.html" target="_blank" rel="noopener">交易流程</a>图以直观表示共识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hyperledger-Fabric模型&quot;&gt;Hyperledger-Fabric模型&lt;/h1&gt;
&lt;p&gt;This section outlines the key design features woven into Hyperledger Fabric that </summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="Key Concepts" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/Key-Concepts/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="Model" scheme="https://guozhe001.github.io/tags/Model/"/>
    
  </entry>
  
  <entry>
    <title>Fabric智能合约API学习</title>
    <link href="https://guozhe001.github.io/2021/01/13/blockchain/fabric/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6API%E5%AD%A6%E4%B9%A0/Fabric%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6API%E5%AD%A6%E4%B9%A0/"/>
    <id>https://guozhe001.github.io/2021/01/13/blockchain/fabric/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6API%E5%AD%A6%E4%B9%A0/Fabric%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6API%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-01-13T08:47:19.637Z</published>
    <updated>2021-01-25T11:33:52.698Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文档通过学习之前写的chaincode来查看Fabric的智能合约相关的源码。并学习这些源码的功能。</p><h2 id="智能合约里面的方法如何定义的">智能合约里面的方法如何定义的</h2><p>智能合约中的每个导出的方法都必须有<code>contractapi.TransactionContextInterface</code>类型的参数，并且这个方法是被定义在<code>SmartContract</code>上的，如下面一个获取资产出价价格的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetAssetBidPrice returns the bid price</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">GetAssetBidPrice</span><span class="params">(ctx contractapi.TransactionContextInterface, assetID <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> getAssetPrice(ctx, assetID, typeAssetBid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>contractapi.TransactionContextInterface</code>的源码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionContextInterface defines the interface which TransactionContext</span></span><br><span class="line"><span class="comment">// meets. This can be taken by transacton functions on a contract which has not set</span></span><br><span class="line"><span class="comment">// a custom transaction context to allow transaction functions to take an interface</span></span><br><span class="line"><span class="comment">// to simplify unit testing.</span></span><br><span class="line"><span class="comment">// 交易上下文接口，为了方便测试</span></span><br><span class="line"><span class="keyword">type</span> TransactionContextInterface <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// GetStub should provide a way to access the stub set by Init/Invoke</span></span><br><span class="line">  <span class="comment">// 获取由Init/Invoke设置的存根</span></span><br><span class="line">GetStub() shim.ChaincodeStubInterface</span><br><span class="line"><span class="comment">// GetClientIdentity should provide a way to access the client identity set by Init/Invoke</span></span><br><span class="line">  <span class="comment">// 获取由Init/Invoke设置的客户端身份</span></span><br><span class="line">GetClientIdentity() cid.ClientIdentity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mock方式测试shim-ChaincodeStubInterface中的方法">mock方式测试<code>shim.ChaincodeStubInterface</code>中的方法</h3><p>接着看<code>shim.ChaincodeStubInterface</code>有哪些功能，源码在这里就不贴了，直接看测试用例,下面的测试用例的入口是<code>TestStart</code>，不包含尚未实现mock的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chaincode_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-chaincode-go/pkg/statebased"</span></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-contract-api-go/contractapi"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/guozhe001/learn-contractapi-go/chaincode"</span></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-chaincode-go/shim"</span></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-chaincode-go/shimtest"</span></span><br><span class="line"><span class="string">"github.com/stretchr/testify/require"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mockInitLedger</span><span class="params">(t *testing.T, stub *shimtest.MockStub)</span></span> &#123;</span><br><span class="line">assets := []chaincode.Asset&#123;</span><br><span class="line">&#123;ID: AssetId, Color: <span class="string">"blue"</span>, Size: <span class="number">5</span>, Owner: <span class="string">"Tomoko"</span>, AppraisedValue: <span class="number">300</span>&#125;,</span><br><span class="line">&#123;ID: <span class="string">"asset2"</span>, Color: <span class="string">"red"</span>, Size: <span class="number">5</span>, Owner: <span class="string">"Brad"</span>, AppraisedValue: <span class="number">400</span>&#125;,</span><br><span class="line">&#123;ID: <span class="string">"asset3"</span>, Color: <span class="string">"green"</span>, Size: <span class="number">10</span>, Owner: <span class="string">"Jin Soo"</span>, AppraisedValue: <span class="number">500</span>&#125;,</span><br><span class="line">&#123;ID: <span class="string">"asset4"</span>, Color: <span class="string">"yellow"</span>, Size: <span class="number">10</span>, Owner: <span class="string">"Max"</span>, AppraisedValue: <span class="number">600</span>&#125;,</span><br><span class="line">&#123;ID: <span class="string">"asset5"</span>, Color: <span class="string">"black"</span>, Size: <span class="number">15</span>, Owner: <span class="string">"Adriana"</span>, AppraisedValue: <span class="number">700</span>&#125;,</span><br><span class="line">&#123;ID: <span class="string">"asset6"</span>, Color: <span class="string">"white"</span>, Size: <span class="number">15</span>, Owner: <span class="string">"Michel"</span>, AppraisedValue: <span class="number">800</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">stub.MockTransactionStart(<span class="string">"test"</span>)</span><br><span class="line">putState(t, stub, assets...)</span><br><span class="line">id := stub.GetTxID()</span><br><span class="line">timestamp, err := stub.GetTxTimestamp()</span><br><span class="line">channelID := stub.GetChannelID()</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">require.NotNil(t, timestamp)</span><br><span class="line">log.Printf(<span class="string">"GetTxID()=%s, GetTxTimestamp()=%s, GetChannelID()=%s"</span>, id, timestamp, channelID)</span><br><span class="line">stub.MockTransactionEnd(<span class="string">"test"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">marshal</span><span class="params">(asset chaincode.Asset, t *testing.T)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">assetJSON, err := json.Marshal(asset)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line"><span class="keyword">return</span> assetJSON</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#PutState()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putState</span><span class="params">(t *testing.T, stub *shimtest.MockStub, assets ...chaincode.Asset)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, asset := <span class="keyword">range</span> assets &#123;</span><br><span class="line">log.Printf(<span class="string">"putState=%v"</span>, asset)</span><br><span class="line">require.NoError(t, stub.PutState(asset.ID, marshal(asset, t)))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetState()</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#PutState()</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#DelState()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getState</span><span class="params">(assetId <span class="keyword">string</span>, t *testing.T, stub *shimtest.MockStub)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取指定key的资产的世界状态</span></span><br><span class="line">state, err := stub.GetState(assetId)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">printAsset(t, state)</span><br><span class="line">newAssetID := <span class="string">"temp001"</span></span><br><span class="line">newAsset := chaincode.Asset&#123;ID: newAssetID, Color: <span class="string">"blue"</span>, Size: <span class="number">5</span>, Owner: <span class="string">"Tomoko"</span>, AppraisedValue: <span class="number">300</span>&#125;</span><br><span class="line"><span class="comment">// put一个新的资产</span></span><br><span class="line">putState(t, stub, newAsset)</span><br><span class="line"><span class="comment">// 查询新的资产</span></span><br><span class="line">newState, err := stub.GetState(newAssetID)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">require.NotNil(t, newState)</span><br><span class="line">printAsset(t, newState)</span><br><span class="line"><span class="comment">// 指定资产ID删除资产</span></span><br><span class="line">require.NoError(t, stub.DelState(newAssetID))</span><br><span class="line"><span class="comment">// 删除之后重新查询新的资产</span></span><br><span class="line">newStateAgain, err := stub.GetState(newAssetID)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">require.Nil(t, newStateAgain)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHistoryForKey</span><span class="params">(assetId <span class="keyword">string</span>, t *testing.T, stub *shimtest.MockStub)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取key的历史数据，目前mock还未实现</span></span><br><span class="line">history, err := stub.GetHistoryForKey(assetId)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line"><span class="keyword">if</span> history != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> history.HasNext() &#123;</span><br><span class="line">next, err := history.Next()</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">marshal, err := json.Marshal(next)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">log.Printf(<span class="string">"asset=%s history=%s"</span>, assetId, marshal)</span><br><span class="line">&#125;</span><br><span class="line">history.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printAsset</span><span class="params">(t *testing.T, state []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a chaincode.Asset</span><br><span class="line">require.NoError(t, json.Unmarshal(state, &amp;a))</span><br><span class="line">marshal, err := json.Marshal(a)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">log.Printf(<span class="string">"result state json value = %s"</span>, marshal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetArgs()</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetStringArgs()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getArgs</span><span class="params">(t *testing.T, stub *shimtest.MockStub)</span></span> &#123;</span><br><span class="line">args := stub.GetArgs()</span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">log.Print(<span class="keyword">string</span>(arg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stringArgs := stub.GetStringArgs()</span><br><span class="line"><span class="keyword">for</span> _, argString := <span class="keyword">range</span> stringArgs &#123;</span><br><span class="line">log.Print(argString)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error)</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetStateByRangeWithPagination(startKey, endKey string, pageSize int32, bookmark string) (StateQueryIteratorInterface, *pb.QueryResponseMetadata, error)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getStateByRange</span><span class="params">(t *testing.T, stub *shimtest.MockStub)</span></span> &#123;</span><br><span class="line"><span class="comment">// GetStateByRange不指定startKey和endKey，会返回全部的资产；谨慎使用</span></span><br><span class="line">states, err := stub.GetStateByRange(<span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">printStateQueryIteratorInterface(t, states)</span><br><span class="line"><span class="comment">// GetStateByRangeWithPagination 因为mockStub直接返回三个nil，所以无法在mock环境测试</span></span><br><span class="line">pagination, metadata, err := stub.GetStateByRangeWithPagination(<span class="string">""</span>, <span class="string">""</span>, <span class="number">5</span>, <span class="string">""</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">log.Print(<span class="string">"=========================================================================================="</span>)</span><br><span class="line">log.Printf(<span class="string">"GetStateByRangeWithPagination metadata=%v"</span>, metadata)</span><br><span class="line">printStateQueryIteratorInterface(t, pagination)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStateQueryIteratorInterface</span><span class="params">(t *testing.T, states shim.StateQueryIteratorInterface)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> states != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> states.HasNext() &#123;</span><br><span class="line">next, err := states.Next()</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">log.Print(next)</span><br><span class="line">&#125;</span><br><span class="line">states.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#CreateCompositeKey(objectType string, attributes []string) (string, error)</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#SplitCompositeKey(compositeKey string) (string, []string, error)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createCompositeKey</span><span class="params">(t *testing.T, stub *shimtest.MockStub)</span></span> &#123;</span><br><span class="line">objectType := <span class="string">"test"</span></span><br><span class="line">attributes := []<span class="keyword">string</span>&#123;<span class="string">"param1"</span>, <span class="string">"param2"</span>, <span class="string">"param3"</span>, <span class="string">"end"</span>&#125;</span><br><span class="line"><span class="comment">// 创建组合key，拼接了一下</span></span><br><span class="line">key, err := stub.CreateCompositeKey(objectType, attributes)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">log.Printf(<span class="string">"key=%s"</span>, key)</span><br><span class="line"><span class="comment">// 分割组合key，CreateCompositeKey的逆运算</span></span><br><span class="line">compositeKey, strings, err := stub.SplitCompositeKey(key)</span><br><span class="line">require.Equal(t, objectType, compositeKey)</span><br><span class="line">require.Equal(t, attributes, strings)</span><br><span class="line">newAsset := chaincode.Asset&#123;ID: key, Color: <span class="string">"blue"</span>, Size: <span class="number">5</span>, Owner: <span class="string">"Tomoko"</span>, AppraisedValue: <span class="number">300</span>&#125;</span><br><span class="line">putState(t, stub, newAsset)</span><br><span class="line">empty := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 根据创建组合key的参数查询，后面的参数可以是空，这样会全部匹配出来</span></span><br><span class="line">states, err := stub.GetStateByPartialCompositeKey(objectType, empty)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">require.NotNil(t, states)</span><br><span class="line">printStateQueryIteratorInterface(t, states)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">AssetId        <span class="keyword">string</span> = <span class="string">"asset1"</span></span><br><span class="line">TestMSP        <span class="keyword">string</span> = <span class="string">"TestMSP"</span></span><br><span class="line">TestCollection <span class="keyword">string</span> = <span class="string">"private_TestMSP"</span></span><br><span class="line">Blank          <span class="keyword">string</span> = <span class="string">""</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#SetStateValidationParameter(key string, ep []byte) error</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetStateValidationParameter(key string) ([]byte, error)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setStateValidationParameter</span><span class="params">(t *testing.T, stub *shimtest.MockStub)</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建一个基于状态的背书策略</span></span><br><span class="line">endorsementPolicy, err := statebased.NewStateEP(<span class="literal">nil</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line"><span class="comment">// 向背书策略添加需要背书的公司</span></span><br><span class="line">require.NoError(t, endorsementPolicy.AddOrgs(statebased.RoleTypeMember, TestMSP))</span><br><span class="line">policy, err := endorsementPolicy.Policy()</span><br><span class="line">require.NoError(t, err)</span><br><span class="line"><span class="comment">// SetStateValidationParameter设置基于状态的背书策略</span></span><br><span class="line">require.NoError(t, stub.SetStateValidationParameter(AssetId, policy))</span><br><span class="line"><span class="comment">// GetStateValidationParameter获取基于状态的背书策略</span></span><br><span class="line">parameter, err := stub.GetStateValidationParameter(AssetId)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">str := byteToString(parameter)</span><br><span class="line"><span class="comment">// 打印出来的StateValidationParameter有特殊字符，所以使用包含传入的字符的方式断言</span></span><br><span class="line">log.Printf(<span class="string">"ID=%s, StateValidationParameter=%s"</span>, AssetId, str)</span><br><span class="line">require.Contains(t, str, TestMSP)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetPrivateData(collection, key string) ([]byte, error)</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetPrivateDataHash(collection, key string) ([]byte, error) 获取私有数据的hash值，这个方法就算不是私有数据的所有者也可以调用，mock版本没有实现；</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#DelPrivateData(collection, key string) error 删除私有数据，mock版本没有实现；</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#SetPrivateDataValidationParameter(collection, key string, ep []byte) error 设置私有数据的</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetPrivateDataValidationParameter(collection, key string) ([]byte, error)</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetPrivateDataByRange(collection, startKey, endKey string) (StateQueryIteratorInterface, error) 根据范围查询私有数据</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetPrivateDataByPartialCompositeKey(collection, objectType string, keys []string) (StateQueryIteratorInterface, error)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPrivateData</span><span class="params">(t *testing.T, stub *shimtest.MockStub)</span></span> &#123;</span><br><span class="line">key := <span class="string">"private001"</span></span><br><span class="line">privateAsset := chaincode.Asset&#123;ID: key, Color: <span class="string">"blue"</span>, Size: <span class="number">5</span>, Owner: <span class="string">"Tomoko"</span>, AppraisedValue: <span class="number">300</span>&#125;</span><br><span class="line">bytes, err := json.Marshal(privateAsset)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line"><span class="comment">// 添加私有数据</span></span><br><span class="line">require.NoError(t, stub.PutPrivateData(TestCollection, key, bytes))</span><br><span class="line"><span class="comment">// 获取私有资产</span></span><br><span class="line">data, err := stub.GetPrivateData(TestCollection, key)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">require.NotNil(t, data)</span><br><span class="line">printAsset(t, data)</span><br><span class="line"><span class="comment">// 使用不存在的其他的collection获取私有资产，不会返回error，会返回nil数据</span></span><br><span class="line">data, err = stub.GetPrivateData(<span class="string">"test_collections"</span>, key)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">require.Nil(t, data)</span><br><span class="line"><span class="comment">// 使用其他的key获取不存在私有资产</span></span><br><span class="line">data, err = stub.GetPrivateData(TestCollection, AssetId)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">require.Nil(t, data)</span><br><span class="line"><span class="comment">// 查询公共资产数据,断言没有这个资产</span></span><br><span class="line">state, err := stub.GetState(key)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">require.Nil(t, state)</span><br><span class="line"></span><br><span class="line">endorsementPolicy, err := statebased.NewStateEP(<span class="literal">nil</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">require.NoError(t, endorsementPolicy.AddOrgs(statebased.RoleTypeMember, TestMSP))</span><br><span class="line">policy, err := endorsementPolicy.Policy()</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">require.NoError(t, stub.SetPrivateDataValidationParameter(TestCollection, key, policy))</span><br><span class="line">parameter, err := stub.GetPrivateDataValidationParameter(TestCollection, key)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">str := byteToString(parameter)</span><br><span class="line"><span class="comment">// 打印出来的StateValidationParameter有特殊字符，所以使用包含传入的字符的方式断言</span></span><br><span class="line">log.Printf(<span class="string">"ID=%s, StateValidationParameter=%s"</span>, AssetId, str)</span><br><span class="line">require.Contains(t, str, TestMSP)</span><br><span class="line"><span class="comment">// GetPrivateDataHash(collection, key string) ([]byte, error) 获取私有数据的hash值，这个方法就算不是私有数据的所有者也可以调用，mock版本没有实现；</span></span><br><span class="line"><span class="comment">// DelPrivateData(collection, key string) error 删除私有数据，mock版本没有实现；</span></span><br><span class="line"><span class="comment">//require.NoError(t, stub.DelPrivateData(TestCollection, key))</span></span><br><span class="line"><span class="comment">//// 删除之后再次查询，断言已经没有此资产</span></span><br><span class="line"><span class="comment">//data, err = stub.GetPrivateData(TestCollection, key)</span></span><br><span class="line"><span class="comment">//require.NoError(t, err)</span></span><br><span class="line"><span class="comment">//require.Nil(t, state)</span></span><br><span class="line"><span class="comment">// GetPrivateDataByRange没有实现</span></span><br><span class="line"><span class="comment">//byRange, err := stub.GetPrivateDataByRange(TestCollection, Blank, Blank)</span></span><br><span class="line"><span class="comment">//require.NoError(t, err)</span></span><br><span class="line"><span class="comment">//require.NotNil(t, byRange)</span></span><br><span class="line"><span class="comment">//for byRange.HasNext() &#123;</span></span><br><span class="line"><span class="comment">//next, err := byRange.Next()</span></span><br><span class="line"><span class="comment">//require.NotNil(t, err)</span></span><br><span class="line"><span class="comment">//log.Print(next)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">byteToString</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">str := (*<span class="keyword">string</span>)(unsafe.Pointer(&amp;data))</span><br><span class="line"><span class="keyword">return</span> *str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#ChaincodeStubInterface#GetCreator() ([]byte, error) 获取签约交易提议的人，签约提议的人也是这个交易的创建者; mockstub未实现</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetTransient() (map[string][]byte, error) 获取临时数据，这个方法只有设置了临时数据的peer才能查到数据，主要是为了做隐私保护的，详情参考隐秘的交易资产</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetBinding() ([]byte, error) TODO 待理解</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetDecorations() ([]byte, error) TODO 待理解,目前看是为了传递更多关于提议的的额外数据</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#GetSignedProposal() ([]byte, error) 获取提议</span></span><br><span class="line"><span class="comment">// ChaincodeStubInterface#SetEvent(name string, payload []byte) error  允许链码在提议的response设置一个事件。无论交易的有效性如何，事件都将在已提交的块中的交易内可用。一个交易只能包含一个事件，并且如果是链码调用另一个链码的情况，事件只能在最外层。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stubOthers</span><span class="params">(t *testing.T, stub *shimtest.MockStub)</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span><br><span class="line">tempAsset := chaincode.Asset&#123;ID: <span class="string">"temp001"</span>, Color: <span class="string">"blue"</span>, Size: <span class="number">5</span>, Owner: <span class="string">"Tomoko"</span>, AppraisedValue: <span class="number">300</span>&#125;</span><br><span class="line">m[<span class="string">"temp_asset"</span>], _ = json.Marshal(tempAsset)</span><br><span class="line">require.NoError(t, stub.SetTransient(m))</span><br><span class="line">transient, err := stub.GetTransient()</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">require.NotNil(t, transient)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> transient &#123;</span><br><span class="line">log.Printf(<span class="string">"k=%s, v=%s"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">decorations := stub.GetDecorations()</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> decorations &#123;</span><br><span class="line">log.Printf(<span class="string">"k=%s, v=%s"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试shim.ChaincodeStubInterface接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stubTest</span><span class="params">(t *testing.T, stub *shimtest.MockStub)</span></span> &#123;</span><br><span class="line">assetId := AssetId</span><br><span class="line">mockInitLedger(t, stub)</span><br><span class="line">stub.MockTransactionStart(<span class="string">"test1"</span>)</span><br><span class="line">getState(assetId, t, stub)</span><br><span class="line"><span class="comment">//getHistoryForKey(assetId, t, stub)</span></span><br><span class="line">getArgs(t, stub)</span><br><span class="line">stub.MockTransactionStart(<span class="string">"test1"</span>)</span><br><span class="line">getStateByRange(t, stub)</span><br><span class="line">createCompositeKey(t, stub)</span><br><span class="line">setStateValidationParameter(t, stub)</span><br><span class="line">getPrivateData(t, stub)</span><br><span class="line">stubOthers(t, stub)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试contractapi.Contract的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">contractTest</span><span class="params">(t *testing.T, ccc *contractapi.ContractChaincode, stub *shimtest.MockStub)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"DefaultContract=%s"</span>, ccc.DefaultContract)</span><br><span class="line">info := ccc.Info</span><br><span class="line">log.Printf(<span class="string">"info=%v"</span>, info)</span><br><span class="line">stub.MockTransactionStart(<span class="string">"contract_test"</span>)</span><br><span class="line"><span class="comment">// 如果调用一个不存在的方法，如果实现了GetUnknownTransaction接口，则会执行此接口返回的方法；否则不执行，并且也不会报错，但是如果有before方法是会执行的</span></span><br><span class="line">response := stub.MockInvoke(<span class="string">"uuid_002"</span>, [][]<span class="keyword">byte</span>&#123;[]<span class="keyword">byte</span>(<span class="string">"Unknow"</span>)&#125;)</span><br><span class="line">log.Printf(<span class="string">"response=%#v, response.Status=%d, response.Payload=%s"</span>, response, response.Status, byteToString(response.Payload))</span><br><span class="line"><span class="comment">// 调用一个被忽略的方法, 虽然IgnoredMe方法在智能合约中存在，但是因为合约满足IgnoreContractInterface接口然后把这个方法加入到了忽略列表中，所以最后还是调用的默认方法</span></span><br><span class="line">response = stub.MockInvoke(<span class="string">"uuid_002"</span>, [][]<span class="keyword">byte</span>&#123;[]<span class="keyword">byte</span>(<span class="string">"IgnoredMe"</span>)&#125;)</span><br><span class="line">log.Printf(<span class="string">"response=%#v, response.Status=%d, response.Payload=%s"</span>, response, response.Status, byteToString(response.Payload))</span><br><span class="line"><span class="comment">// 指定某个指定合约，调用一个不存在的方法，冒号前面的部分是智能合约名称，后面是方法名称</span></span><br><span class="line">response = stub.MockInvoke(<span class="string">"uuid_002"</span>, [][]<span class="keyword">byte</span>&#123;[]<span class="keyword">byte</span>(<span class="string">"TestSmartContract:Unknow"</span>)&#125;)</span><br><span class="line">log.Printf(<span class="string">"response=%#v, response.Status=%d, response.Payload=%s"</span>, response, response.Status, byteToString(response.Payload))</span><br><span class="line"><span class="comment">//invoke := ccc.Invoke(stub)</span></span><br><span class="line"><span class="comment">//log.Printf("response=%v", invoke)</span></span><br><span class="line">stub.MockTransactionEnd(<span class="string">"uuid_001"</span>)</span><br><span class="line">transactionSerializer := ccc.TransactionSerializer</span><br><span class="line">log.Printf(<span class="string">"transactionSerializer=%v"</span>, transactionSerializer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStart</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="comment">// 一个链码包中可以有多个智能合约</span></span><br><span class="line">assetChaincode, err := contractapi.NewChaincode(&amp;chaincode.SmartContract&#123;&#125;, &amp;TestSmartContract&#123;&#125;)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line"><span class="comment">// NewMockStub</span></span><br><span class="line">stub := shimtest.NewMockStub(<span class="string">"mockSub"</span>, assetChaincode)</span><br><span class="line">stubTest(t, stub)</span><br><span class="line">contractTest(t, assetChaincode, stub)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestSmartContract <span class="keyword">struct</span> &#123;</span><br><span class="line">contractapi.Contract</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetUnknownTransaction returns the current set unknownTransaction, may be nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TestSmartContract)</span> <span class="title">GetUnknownTransaction</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> t.UnknownTransaction</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default 如果不指定方法名称时指定的默认方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TestSmartContract)</span> <span class="title">UnknownTransaction</span><span class="params">(ctx contractapi.TransactionContextInterface)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"hello, i'm Default func in TestSmartContract！"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"i'm TestSmartContract, Bye!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在智能合约中添加了如下的一些方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// GetUnknownTransaction returns the current set unknownTransaction, may be nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">GetUnknownTransaction</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> s.UnknownTransaction</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default 如果不指定方法名称时指定的默认方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">UnknownTransaction</span><span class="params">(ctx contractapi.TransactionContextInterface)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"hello, i'm Default func！"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Bye!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetBeforeTransaction returns the current set beforeTransaction, may be nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">GetBeforeTransaction</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> s.BeforeTransaction</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">BeforeTransaction</span><span class="params">(ctx contractapi.TransactionContextInterface)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"i'm BeforeTransaction"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetAfterTransaction returns the current set afterTransaction, may be nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">GetAfterTransaction</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> s.AfterTransaction</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">AfterTransaction</span><span class="params">(ctx contractapi.TransactionContextInterface)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"i'm AfterTransaction"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">IgnoredMe</span><span class="params">(ctx contractapi.TransactionContextInterface)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Ignored Me!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">GetIgnoredFunctions</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">string</span>&#123;<span class="string">"IgnoredMe"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试无法mock测试的shim-ChaincodeStubInterface方法">测试无法mock测试的<code>shim.ChaincodeStubInterface</code>方法</h3><p>一些其他的无法使用<code>shimtests</code>做mock测试的<code>shim.ChaincodeStubInterface</code>方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// SomeStubMethod stub其他的无法通过mock方式测试的方法练习</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">SomeStubMethod</span><span class="params">(ctx contractapi.TransactionContextInterface, assetID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">stub := ctx.GetStub()</span><br><span class="line"><span class="comment">// stub.GetArgs()和stub.GetStringArgs()都是获取调用链码时的入参，第一个参数时方法名，后面的参数是这个方法的参数的信息,如下：</span></span><br><span class="line"><span class="comment">// 2021/01/25 08:06:32 stub.GetArgs(),i=0, arg=Practice_SmartContract:SomeStubMethod</span></span><br><span class="line"><span class="comment">//2021/01/25 08:06:32 stub.GetArgs(),i=1, arg=asset1</span></span><br><span class="line"><span class="keyword">for</span> i, arg := <span class="keyword">range</span> stub.GetArgs() &#123;</span><br><span class="line">log.Printf(<span class="string">"stub.GetArgs(),i=%d, arg=%s"</span>, i, byteToString(arg))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, arg := <span class="keyword">range</span> stub.GetStringArgs() &#123;</span><br><span class="line">log.Printf(<span class="string">"stub.GetStringArgs(),i=%d, arg=%s"</span>, i, arg)</span><br><span class="line">&#125;</span><br><span class="line">binding, err := stub.GetBinding()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"stub.GetBinding()=%s"</span>, byteToString(binding))</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> stub.GetDecorations() &#123;</span><br><span class="line">log.Printf(<span class="string">"stub.GetDecorations(), k=%s, v=%s"</span>, k, byteToString(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// stub.GetCreator()返回的是证书，如过是组织s2.supply.com的管理员发起的交易，则此处获得的是：Admin@s2.supply.com-cert.pem</span></span><br><span class="line">creator, err := stub.GetCreator()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"stub.GetCreator()=%s"</span>, byteToString(creator))</span><br><span class="line"><span class="comment">// 已经签名的提议，包含以下内容：</span></span><br><span class="line"><span class="comment">// 1.通道名称</span></span><br><span class="line"><span class="comment">// 2.链码名称</span></span><br><span class="line"><span class="comment">// 3.发起交易的组织名称</span></span><br><span class="line"><span class="comment">// 4.发起交易的人的证书</span></span><br><span class="line"><span class="comment">// 5.调用链码时的入参：方法名，参数等</span></span><br><span class="line"><span class="comment">// stub.GetSignedProposal().GetProposalBytes()的信息如下：</span></span><br><span class="line"><span class="comment">//2021/01/25 08:06:32 stub.GetSignedProposal().GetProposalBytes()=</span></span><br><span class="line"><span class="comment">//�</span></span><br><span class="line"><span class="comment">//v��������"alljoinchannel*@252b6bbd22eeaf2193cdbc86fe7bd9fa257e33a6209a5da7d81dcc41b8bb1b9d:secured_supply�</span></span><br><span class="line"><span class="comment">//�</span></span><br><span class="line"><span class="comment">//GylSOrg2MSP�-----BEGIN CERTIFICATE-----</span></span><br><span class="line"><span class="comment">//MIICETCCAbegAwIBAgIRAJw2YUKkmyKusGHm33D7LhkwCgYIKoZIzj0EAwIwbTEL</span></span><br><span class="line"><span class="comment">//MAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG</span></span><br><span class="line"><span class="comment">//cmFuY2lzY28xFjAUBgNVBAoTDXMyLnN1cHBseS5jb20xGTAXBgNVBAMTEGNhLnMy</span></span><br><span class="line"><span class="comment">//LnN1cHBseS5jb20wHhcNMjEwMTA3MDgzMTAwWhcNMzEwMTA1MDgzMTAwWjBYMQsw</span></span><br><span class="line"><span class="comment">//CQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy</span></span><br><span class="line"><span class="comment">//YW5jaXNjbzEcMBoGA1UEAwwTQWRtaW5AczIuc3VwcGx5LmNvbTBZMBMGByqGSM49</span></span><br><span class="line"><span class="comment">//AgEGCCqGSM49AwEHA0IABJ6An5vHmug1YBIUXKuD50ZJ79TiwDkW5uEr2ZkXU5Em</span></span><br><span class="line"><span class="comment">//XwVlxwCOKpfqKOr1Xdk0DWMlAQPQIxeXktdVBJxFc4KjTTBLMA4GA1UdDwEB/wQE</span></span><br><span class="line"><span class="comment">//AwIHgDAMBgNVHRMBAf8EAjAAMCsGA1UdIwQkMCKAIGO9q5qcp089i7bDqwyxRYdg</span></span><br><span class="line"><span class="comment">//aX65Bvs4X5wCsXWbxj37MAoGCCqGSM49BAMCA0gAMEUCIQCRBC/uF8ooaLQzSDo6</span></span><br><span class="line"><span class="comment">//e5+4UbBqjSi5MUy3IYfVrM5tHQIgaGHKXcKZY7q0Txs6LsbtayW6kWPOAee6Z1W8</span></span><br><span class="line"><span class="comment">//top2VDc=</span></span><br><span class="line"><span class="comment">//-----END CERTIFICATE-----</span></span><br><span class="line"><span class="comment">//�w�&#125;dȧC&gt;�v�@�El�S����I</span></span><br><span class="line"><span class="comment">//G</span></span><br><span class="line"><span class="comment">//Esecured_supply/</span></span><br><span class="line"><span class="comment">//%Practice_SmartContract:SomeStubMethod</span></span><br><span class="line"><span class="comment">//asset1</span></span><br><span class="line">proposal, err := stub.GetSignedProposal()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"stub.GetSignedProposal()=%#v"</span>, proposal)</span><br><span class="line">bytes := proposal.GetProposalBytes()</span><br><span class="line">log.Printf(<span class="string">"stub.GetSignedProposal().GetProposalBytes()=%s"</span>, byteToString(bytes))</span><br><span class="line">p := &amp;peer.Proposal&#123;&#125;</span><br><span class="line">err = proto.Unmarshal(bytes, p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"stub.GetSignedProposal().GetProposalBytes(),proto.Unmarshal=%#v"</span>, p)</span><br><span class="line"><span class="comment">//headerBytes:= p.GetHeader()</span></span><br><span class="line"><span class="comment">//header := &amp;peer.ChaincodeHeaderExtension&#123;&#125;</span></span><br><span class="line"><span class="comment">//err = proto.Unmarshal(headerBytes, header)</span></span><br><span class="line"><span class="comment">//if err != nil &#123;</span></span><br><span class="line"><span class="comment">//return err</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//log.Printf("stub.GetSignedProposal().GetProposalBytes()-Proposal-GetHeader()=%#v", header)</span></span><br><span class="line"><span class="comment">//payloadBytes := p.GetPayload()</span></span><br><span class="line"><span class="comment">//payload := &amp;peer.ChaincodeProposalPayload&#123;&#125;</span></span><br><span class="line"><span class="comment">//err = proto.Unmarshal(payloadBytes, payload)</span></span><br><span class="line"><span class="comment">//if err != nil &#123;</span></span><br><span class="line"><span class="comment">//return err</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//log.Printf("stub.GetSignedProposal().GetProposalBytes()-Proposal-GetPayload()=%#v", payload)</span></span><br><span class="line">log.Printf(<span class="string">"stub.GetSignedProposal().GetSignature()=%s"</span>, byteToString(proposal.GetSignature()))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个Event</span></span><br><span class="line"><span class="keyword">if</span> err := stub.SetEvent(<span class="string">"hello event"</span>, []<span class="keyword">byte</span>(<span class="string">"hello"</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2021/01/25 10:22:57 stub.GetHistoryForKey(asset1), next=&amp;queryresult.KeyModification&#123;</span></span><br><span class="line"><span class="comment">//TxId:"f251ce5352e294cd628fc0b5d09271ebe8253b41d66069c164195fe2783c3adc",</span></span><br><span class="line"><span class="comment">//Value:[]uint8&#123;0x7b, 0x22, 0x49, 0x44, 0x22, 0x3a, 0x22, 0x61, 0x73, 0x73, 0x65, 0x74, 0x31, 0x22, 0x2c</span></span><br><span class="line"><span class="comment">//, 0x22, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x22, 0x3a, 0x22, 0x62, 0x6c, 0x75, 0x65, 0x22, 0x2c, 0x22, 0x73, 0x69, 0x7a, 0x65, 0x22, 0x3a, 0x35, 0x2c, 0x22, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x22, 0x3a, 0x22, 0x54, 0x6f, 0x6d, 0x6f, 0x6b, 0x6f, 0x22, 0x2c, 0x22, 0x61, 0x70, 0x70, 0x72, 0x61, 0x69, 0x73, 0x65, 0x64, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x3a, 0x33, 0x30, 0x30, 0x7d&#125;,</span></span><br><span class="line"><span class="comment">//Timestamp:(*timestamp.Timestamp)(0xc00043d1a0),</span></span><br><span class="line"><span class="comment">//IsDelete:false, XXX_NoUnkeyedLiteral:struct &#123;&#125;&#123;&#125;,</span></span><br><span class="line"><span class="comment">//XXX_unrecognized:[]uint8(nil),</span></span><br><span class="line"><span class="comment">//XXX_sizecache:0&#125;</span></span><br><span class="line">assetHistory, err := stub.GetHistoryForKey(assetID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> assetHistory.Close()</span><br><span class="line"><span class="keyword">for</span> assetHistory.HasNext() &#123;</span><br><span class="line">next, err := assetHistory.Next()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"stub.GetHistoryForKey(%s), next=%#v"</span>, assetID, next)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">byteToString</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">str := (*<span class="keyword">string</span>)(unsafe.Pointer(&amp;data))</span><br><span class="line"><span class="keyword">return</span> *str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shim包下面也有一个<code>GetMSPID</code>方法，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// GetMSPID returns the local mspid of the peer by checking the CORE_PEER_LOCALMSPID</span></span><br><span class="line"><span class="comment">// env var and returns an error if the env var is not set</span></span><br><span class="line"><span class="comment">// 通过检查环境变量CORE_PEER_LOCALMSPID返回peer节点本地的mspid，如果没有设置这个环境变量则返回一个error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMSPID</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">mspid := os.Getenv(<span class="string">"CORE_PEER_LOCALMSPID"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mspid == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"'CORE_PEER_LOCALMSPID' is not set"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mspid, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO 待整合到一起</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"crypto/sha256"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/golang/protobuf/ptypes"</span></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-chaincode-go/pkg/statebased"</span></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-chaincode-go/shim"</span></span><br><span class="line"><span class="string">"github.com/hyperledger/fabric-contract-api-go/contractapi"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">typeAssetForSale     = <span class="string">"S"</span></span><br><span class="line">typeAssetBid         = <span class="string">"B"</span></span><br><span class="line">typeAssetSaleReceipt = <span class="string">"SR"</span></span><br><span class="line">typeAssetBuyReceipt  = <span class="string">"BR"</span></span><br><span class="line">statusEnable         = <span class="string">"enable"</span></span><br><span class="line">statusDelete         = <span class="string">"delete"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SmartContract <span class="keyword">struct</span> &#123;</span><br><span class="line">contractapi.Contract</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Asset struct and properties must be exported (start with capitals) to work with contract api metadata</span></span><br><span class="line"><span class="keyword">type</span> Asset <span class="keyword">struct</span> &#123;</span><br><span class="line">ObjectType        <span class="keyword">string</span> <span class="string">`json:"objectType"`</span> <span class="comment">// ObjectType is used to distinguish different object types in the same chaincode namespace</span></span><br><span class="line">ID                <span class="keyword">string</span> <span class="string">`json:"assetID"`</span></span><br><span class="line">OwnerOrg          <span class="keyword">string</span> <span class="string">`json:"ownerOrg"`</span></span><br><span class="line">PublicDescription <span class="keyword">string</span> <span class="string">`json:"publicDescription"`</span></span><br><span class="line">Status            <span class="keyword">string</span> <span class="string">`json:"status"`</span></span><br><span class="line">ParentID          <span class="keyword">string</span> <span class="string">`json:"parentID"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> receipt <span class="keyword">struct</span> &#123;</span><br><span class="line">price     <span class="keyword">int</span></span><br><span class="line">timestamp time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AssetProperties 资产属性</span></span><br><span class="line"><span class="keyword">type</span> AssetProperties <span class="keyword">struct</span> &#123;</span><br><span class="line">ObjectType <span class="keyword">string</span>    <span class="string">`json:"objectType"`</span> <span class="comment">// ObjectType is used to distinguish different object types in the same chaincode namespace</span></span><br><span class="line">ID         <span class="keyword">string</span>    <span class="string">`json:"assetID"`</span></span><br><span class="line">Issuer     <span class="keyword">string</span>    <span class="string">`json:"issuer"`</span></span><br><span class="line">Amount     <span class="keyword">int</span>       <span class="string">`json:"amount"`</span></span><br><span class="line">CreateDate time.Time <span class="string">`json:"createDate"`</span></span><br><span class="line">EndDate    time.Time <span class="string">`json:"endDate"`</span></span><br><span class="line">Salt       <span class="keyword">string</span>    <span class="string">`json:"salt"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateAsset creates an asset and sets it as owned by the client's org</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">CreateAsset</span><span class="params">(ctx contractapi.TransactionContextInterface, assetID, publicDescription <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取临时数据库的数据，返回一个map[string][]byte</span></span><br><span class="line">transientMap, err := ctx.GetStub().GetTransient()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"error getting transient: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Asset properties must be retrieved from the transient field as they are private</span></span><br><span class="line">immutablePropertiesJSON, ok := transientMap[<span class="string">"asset_properties"</span>]</span><br><span class="line">fmt.Println(<span class="string">"immutablePropertiesJSON:"</span>, immutablePropertiesJSON)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"asset_properties key not found in the transient map"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> createAsset(ctx, immutablePropertiesJSON, assetID, publicDescription, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateAsset creates an asset and sets it as owned by the client's org</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createAsset</span><span class="params">(ctx contractapi.TransactionContextInterface, immutablePropertiesJSON []<span class="keyword">byte</span>, assetID, publicDescription <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">parentID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Get client org id and verify it matches peer org id.</span></span><br><span class="line"><span class="comment">// In this scenario, client is only authorized to read/write private data from its own peer.</span></span><br><span class="line">clientOrgID, err := getClientOrgID(ctx, <span class="literal">true</span>)</span><br><span class="line">fmt.Println(<span class="string">"clientOrgID:"</span>, clientOrgID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get verified OrgID: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asset := Asset&#123;</span><br><span class="line">ObjectType:        <span class="string">"asset"</span>,</span><br><span class="line">ID:                assetID,</span><br><span class="line">OwnerOrg:          clientOrgID,</span><br><span class="line">PublicDescription: publicDescription,</span><br><span class="line">Status:            statusEnable,</span><br><span class="line">ParentID:          parentID,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"asset:"</span>, asset)</span><br><span class="line">assetBytes, err := json.Marshal(asset)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to create asset JSON: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = ctx.GetStub().PutState(asset.ID, assetBytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to put asset in public data: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the endorsement policy such that an owner org peer is required to endorse future updates</span></span><br><span class="line">err = setAssetStateBasedEndorsement(ctx, asset.ID, clientOrgID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed setting state based endorsement for owner: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Persist private immutable asset properties to owner's private data collection</span></span><br><span class="line">collection := buildCollectionName(clientOrgID)</span><br><span class="line">fmt.Println(<span class="string">"collection:"</span>, collection)</span><br><span class="line">err = ctx.GetStub().PutPrivateData(collection, asset.ID, immutablePropertiesJSON)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to put Asset private details: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // verifyAssetProperties 验证资产属性的信息</span></span><br><span class="line"><span class="comment">// func verifyAssetProperties(immutablePropertiesJSON []byte, asset Asset) error &#123;</span></span><br><span class="line"><span class="comment">// assetProperties, err := getAssetProperties(immutablePropertiesJSON)</span></span><br><span class="line"><span class="comment">// if err != nil &#123;</span></span><br><span class="line"><span class="comment">// return err</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// // 资产的属性ID和资产ID相同</span></span><br><span class="line"><span class="comment">// if asset.ID != assetProperties.ID &#123;</span></span><br><span class="line"><span class="comment">// return fmt.Errorf("资产ID和资产属性ID必须相同")</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// // 资产的发行者就是资产的创建者，所有人都可以发行，但是别人认不认可这个组织发行的资产是另一回事</span></span><br><span class="line"><span class="comment">// if asset.OwnerOrg != assetProperties.Issuer &#123;</span></span><br><span class="line"><span class="comment">// return fmt.Errorf("资产的发行方必须是当前创建资产的组织")</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// // 理论上这里应该还有更多的校验，比如说创建时间和失效时间的验证</span></span><br><span class="line"><span class="comment">// return nil</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// ChangePublicDescription updates the assets public description. Only the current owner can update the public description</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">ChangePublicDescription</span><span class="params">(ctx contractapi.TransactionContextInterface, assetID <span class="keyword">string</span>, newDescription <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">asset, err := s.ReadAsset(ctx, assetID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get asset: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> changeOriginAssetInfo(ctx, *asset, <span class="string">""</span>, newDescription)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AgreeToSell adds seller's asking price to seller's implicit private data collection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">AgreeToSell</span><span class="params">(ctx contractapi.TransactionContextInterface, assetID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">asset, err := s.ReadAsset(ctx, assetID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clientOrgID, err := getClientOrgID(ctx, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get verified OrgID: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify that this clientOrgId actually owns the asset.</span></span><br><span class="line"><span class="keyword">if</span> clientOrgID != asset.OwnerOrg &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"a client from %s cannot sell an asset owned by %s"</span>, clientOrgID, asset.OwnerOrg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> agreeToPrice(ctx, assetID, typeAssetForSale)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AgreeToBuy adds buyer's bid price to buyer's implicit private data collection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">AgreeToBuy</span><span class="params">(ctx contractapi.TransactionContextInterface, assetID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> agreeToPrice(ctx, assetID, typeAssetBid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// agreeToPrice adds a bid or ask price to caller's implicit private data collection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">agreeToPrice</span><span class="params">(ctx contractapi.TransactionContextInterface, assetID <span class="keyword">string</span>, priceType <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// In this scenario, client is only authorized to read/write private data from its own peer.</span></span><br><span class="line">clientOrgID, err := getClientOrgID(ctx, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get verified OrgID: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transMap, err := ctx.GetStub().GetTransient()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"error getting transient: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Asset price must be retrieved from the transient field as they are private</span></span><br><span class="line">price, ok := transMap[<span class="string">"asset_price"</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"asset_price key not found in the transient map"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collection := buildCollectionName(clientOrgID)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Persist the agreed to price in a collection sub-namespace based on priceType key prefix,</span></span><br><span class="line"><span class="comment">// to avoid collisions between private asset properties, sell price, and buy price</span></span><br><span class="line">assetPriceKey, err := ctx.GetStub().CreateCompositeKey(priceType, []<span class="keyword">string</span>&#123;assetID&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to create composite key: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The Price hash will be verified later, therefore always pass and persist price bytes as is,</span></span><br><span class="line"><span class="comment">// so that there is no risk of nondeterministic marshaling.</span></span><br><span class="line">err = ctx.GetStub().PutPrivateData(collection, assetPriceKey, price)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to put asset bid: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VerifyAssetProperties  Allows a buyer to validate the properties of</span></span><br><span class="line"><span class="comment">// an asset against the owner's implicit private data collection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">VerifyAssetProperties</span><span class="params">(ctx contractapi.TransactionContextInterface, assetID <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">transMap, err := ctx.GetStub().GetTransient()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"error getting transient: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Asset properties must be retrieved from the transient field as they are private</span></span><br><span class="line">immutablePropertiesJSON, ok := transMap[<span class="string">"asset_properties"</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"asset_properties key not found in the transient map"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asset, err := s.ReadAsset(ctx, assetID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"failed to get asset: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加资产状态的验证</span></span><br><span class="line"><span class="keyword">if</span> (*asset).Status != statusEnable &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"资产不可以，不允许交易: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collectionOwner := buildCollectionName(asset.OwnerOrg)</span><br><span class="line">immutablePropertiesOnChainHash, err := ctx.GetStub().GetPrivateDataHash(collectionOwner, assetID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"failed to read asset private properties hash from seller's collection: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> immutablePropertiesOnChainHash == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"asset private properties hash does not exist: %s"</span>, assetID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hash := sha256.New()</span><br><span class="line">hash.Write(immutablePropertiesJSON)</span><br><span class="line">calculatedPropertiesHash := hash.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// verify that the hash of the passed immutable properties matches the on-chain hash</span></span><br><span class="line"><span class="keyword">if</span> !bytes.Equal(immutablePropertiesOnChainHash, calculatedPropertiesHash) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">"hash %x for passed immutable properties %s does not match on-chain hash %x"</span>,</span><br><span class="line">calculatedPropertiesHash,</span><br><span class="line">immutablePropertiesJSON,</span><br><span class="line">immutablePropertiesOnChainHash,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransferAsset checks transfer conditions and then transfers asset state to buyer.</span></span><br><span class="line"><span class="comment">// TransferAsset can only be called by current owner</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">TransferAsset</span><span class="params">(ctx contractapi.TransactionContextInterface, assetID <span class="keyword">string</span>, buyerOrgID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">clientOrgID, err := getClientOrgID(ctx, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get verified OrgID: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transMap, err := ctx.GetStub().GetTransient()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"error getting transient data: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">immutablePropertiesJSON, ok := transMap[<span class="string">"asset_properties"</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"asset_properties key not found in the transient map"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priceJSON, ok := transMap[<span class="string">"asset_price"</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"asset_price key not found in the transient map"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> agreement Agreement</span><br><span class="line">err = json.Unmarshal(priceJSON, &amp;agreement)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to unmarshal price JSON: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asset, err := s.ReadAsset(ctx, assetID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get asset: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加资产状态的验证</span></span><br><span class="line"><span class="keyword">if</span> (*asset).Status != statusEnable &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"资产不可以，不允许交易"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = verifyTransferConditions(ctx, asset, immutablePropertiesJSON, clientOrgID, buyerOrgID, priceJSON)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed transfer verification: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = transferAssetState(ctx, asset, immutablePropertiesJSON, clientOrgID, buyerOrgID, agreement.Price)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed asset transfer: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SplitAsset 拆分资产为两个资产，传入的amount是拆分后的其中一个资产的金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">SplitAsset</span><span class="params">(ctx contractapi.TransactionContextInterface, assetID <span class="keyword">string</span>, amount <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">asset, err := s.ReadAsset(ctx, assetID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">immutableProperties, err := getAssetPrivateProperties(ctx, assetID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">assetProperties, err := getAssetProperties(immutableProperties)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> assetProperties.Amount &lt;= amount &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"资产ID的金额为%d小于想要拆分的金额为%d，不允许拆分"</span>, assetProperties.Amount, amount)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := splitAsset(ctx, assetProperties, assetID+<span class="string">"1"</span>, amount, *asset); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := splitAsset(ctx, assetProperties, assetID+<span class="string">"2"</span>, assetProperties.Amount-amount, *asset); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拆分之后删除旧资产</span></span><br><span class="line">collection := buildCollectionName((*asset).OwnerOrg)</span><br><span class="line">err = ctx.GetStub().DelPrivateData(collection, asset.ID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to delete Asset private details from org: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改公共资产信息</span></span><br><span class="line">changeOriginAssetInfo(ctx, *asset, statusDelete, <span class="string">"已拆分"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据transient获取的assetProperties的字节数组获取AssetProperties</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAssetProperties</span><span class="params">(immutablePropertiesJSON []<span class="keyword">byte</span>)</span> <span class="params">(AssetProperties, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> assetProperties AssetProperties</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(immutablePropertiesJSON, &amp;assetProperties); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> assetProperties, fmt.Errorf(<span class="string">"failed to unmarshal price JSON: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> assetProperties, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChangePublicDescription updates the assets public description. Only the current owner can update the public description</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeOriginAssetInfo</span><span class="params">(ctx contractapi.TransactionContextInterface, asset Asset, status <span class="keyword">string</span>, newDescription <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// No need to check client org id matches peer org id, rely on the asset ownership check instead.</span></span><br><span class="line">clientOrgID, err := getClientOrgID(ctx, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get verified OrgID: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Auth check to ensure that client's org actually owns the asset</span></span><br><span class="line"><span class="keyword">if</span> clientOrgID != asset.OwnerOrg &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"a client from %s cannot update the description of a asset owned by %s"</span>, clientOrgID, asset.OwnerOrg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加资产状态的验证</span></span><br><span class="line"><span class="keyword">if</span> asset.Status != statusEnable &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"资产不可用，不允许修改"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> status != <span class="string">""</span> &#123;</span><br><span class="line">asset.Status = status</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> newDescription != <span class="string">""</span> &#123;</span><br><span class="line">asset.PublicDescription = newDescription</span><br><span class="line">&#125;</span><br><span class="line">updatedAssetJSON, err := json.Marshal(asset)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to marshal asset: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx.GetStub().PutState(asset.ID, updatedAssetJSON)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// splitAsset 从原始资产属性拆分成指定ID和金额的资产</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">splitAsset</span><span class="params">(ctx contractapi.TransactionContextInterface, originAssetProperties AssetProperties, newAssetID <span class="keyword">string</span>, newAmount <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">asset Asset)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">originAssetProperties.Amount = newAmount</span><br><span class="line">originAssetProperties.ID = newAssetID</span><br><span class="line">immutablePropertiesJSON, err := json.Marshal(originAssetProperties)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> createAsset(ctx, immutablePropertiesJSON, newAssetID, asset.PublicDescription, asset.ID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// verifyTransferConditions checks that client org currently owns asset and that both parties have agreed on price</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyTransferConditions</span><span class="params">(ctx contractapi.TransactionContextInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">asset *Asset,</span></span></span><br><span class="line"><span class="function"><span class="params">immutablePropertiesJSON []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">clientOrgID <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">buyerOrgID <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">priceJSON []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CHECK1: Auth check to ensure that client's org actually owns the asset</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> clientOrgID != asset.OwnerOrg &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"a client from %s cannot transfer a asset owned by %s"</span>, clientOrgID, asset.OwnerOrg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CHECK2: Verify that the hash of the passed immutable properties matches the on-chain hash</span></span><br><span class="line"></span><br><span class="line">collectionSeller := buildCollectionName(clientOrgID)</span><br><span class="line">immutablePropertiesOnChainHash, err := ctx.GetStub().GetPrivateDataHash(collectionSeller, asset.ID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to read asset private properties hash from seller's collection: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> immutablePropertiesOnChainHash == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"asset private properties hash does not exist: %s"</span>, asset.ID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hash := sha256.New()</span><br><span class="line">hash.Write(immutablePropertiesJSON)</span><br><span class="line">calculatedPropertiesHash := hash.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// verify that the hash of the passed immutable properties matches the on-chain hash</span></span><br><span class="line"><span class="keyword">if</span> !bytes.Equal(immutablePropertiesOnChainHash, calculatedPropertiesHash) &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"hash %x for passed immutable properties %s does not match on-chain hash %x"</span>,</span><br><span class="line">calculatedPropertiesHash,</span><br><span class="line">immutablePropertiesJSON,</span><br><span class="line">immutablePropertiesOnChainHash,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CHECK3: Verify that seller and buyer agreed on the same price</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get sellers asking price</span></span><br><span class="line">assetForSaleKey, err := ctx.GetStub().CreateCompositeKey(typeAssetForSale, []<span class="keyword">string</span>&#123;asset.ID&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to create composite key: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">sellerPriceHash, err := ctx.GetStub().GetPrivateDataHash(collectionSeller, assetForSaleKey)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get seller price hash: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sellerPriceHash == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"seller price for %s does not exist"</span>, asset.ID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get buyers bid price</span></span><br><span class="line">collectionBuyer := buildCollectionName(buyerOrgID)</span><br><span class="line">assetBidKey, err := ctx.GetStub().CreateCompositeKey(typeAssetBid, []<span class="keyword">string</span>&#123;asset.ID&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to create composite key: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TODO 疑问：这个方法是由资产拥有者调用的，那么资产拥有者怎么可以获取资产买方的出价信息呢？如果是从公共状态获取购买方的出价hash是没问题的，但是从购买方的私有数据集中获取出价hash很让人费解。</span></span><br><span class="line">buyerPriceHash, err := ctx.GetStub().GetPrivateDataHash(collectionBuyer, assetBidKey)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get buyer price hash: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> buyerPriceHash == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"buyer price for %s does not exist"</span>, asset.ID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hash = sha256.New()</span><br><span class="line">hash.Write(priceJSON)</span><br><span class="line">calculatedPriceHash := hash.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify that the hash of the passed price matches the on-chain sellers price hash</span></span><br><span class="line"><span class="keyword">if</span> !bytes.Equal(calculatedPriceHash, sellerPriceHash) &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"hash %x for passed price JSON %s does not match on-chain hash %x, seller hasn't agreed to the passed trade id and price"</span>,</span><br><span class="line">calculatedPriceHash,</span><br><span class="line">priceJSON,</span><br><span class="line">sellerPriceHash,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify that the hash of the passed price matches the on-chain buyer price hash</span></span><br><span class="line"><span class="keyword">if</span> !bytes.Equal(calculatedPriceHash, buyerPriceHash) &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"hash %x for passed price JSON %s does not match on-chain hash %x, buyer hasn't agreed to the passed trade id and price"</span>,</span><br><span class="line">calculatedPriceHash,</span><br><span class="line">priceJSON,</span><br><span class="line">buyerPriceHash,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// transferAssetState performs the public and private state updates for the transferred asset</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transferAssetState</span><span class="params">(ctx contractapi.TransactionContextInterface, asset *Asset, immutablePropertiesJSON []<span class="keyword">byte</span>, clientOrgID <span class="keyword">string</span>, buyerOrgID <span class="keyword">string</span>, price <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">asset.OwnerOrg = buyerOrgID</span><br><span class="line">updatedAsset, err := json.Marshal(asset)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = ctx.GetStub().PutState(asset.ID, updatedAsset)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to write asset for buyer: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Change the endorsement policy to the new owner</span></span><br><span class="line">err = setAssetStateBasedEndorsement(ctx, asset.ID, buyerOrgID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed setting state based endorsement for new owner: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transfer the private properties (delete from seller collection, create in buyer collection)</span></span><br><span class="line">collectionSeller := buildCollectionName(clientOrgID)</span><br><span class="line">err = ctx.GetStub().DelPrivateData(collectionSeller, asset.ID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to delete Asset private details from seller: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collectionBuyer := buildCollectionName(buyerOrgID)</span><br><span class="line">err = ctx.GetStub().PutPrivateData(collectionBuyer, asset.ID, immutablePropertiesJSON)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to put Asset private properties for buyer: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete the price records for seller</span></span><br><span class="line">assetPriceKey, err := ctx.GetStub().CreateCompositeKey(typeAssetForSale, []<span class="keyword">string</span>&#123;asset.ID&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to create composite key for seller: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = ctx.GetStub().DelPrivateData(collectionSeller, assetPriceKey)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to delete asset price from implicit private data collection for seller: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete the price records for buyer</span></span><br><span class="line">assetPriceKey, err = ctx.GetStub().CreateCompositeKey(typeAssetBid, []<span class="keyword">string</span>&#123;asset.ID&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to create composite key for buyer: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = ctx.GetStub().DelPrivateData(collectionBuyer, assetPriceKey)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to delete asset price from implicit private data collection for buyer: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep record for a 'receipt' in both buyers and sellers private data collection to record the sale price and date.</span></span><br><span class="line"><span class="comment">// Persist the agreed to price in a collection sub-namespace based on receipt key prefix.</span></span><br><span class="line">receiptBuyKey, err := ctx.GetStub().CreateCompositeKey(typeAssetBuyReceipt, []<span class="keyword">string</span>&#123;asset.ID, ctx.GetStub().GetTxID()&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to create composite key for receipt: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">txTimestamp, err := ctx.GetStub().GetTxTimestamp()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to create timestamp for receipt: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timestamp, err := ptypes.Timestamp(txTimestamp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">assetReceipt := receipt&#123;</span><br><span class="line">price:     price,</span><br><span class="line">timestamp: timestamp,</span><br><span class="line">&#125;</span><br><span class="line">receipt, err := json.Marshal(assetReceipt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to marshal receipt: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = ctx.GetStub().PutPrivateData(collectionBuyer, receiptBuyKey, receipt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to put private asset receipt for buyer: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">receiptSaleKey, err := ctx.GetStub().CreateCompositeKey(typeAssetSaleReceipt, []<span class="keyword">string</span>&#123;ctx.GetStub().GetTxID(), asset.ID&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to create composite key for receipt: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = ctx.GetStub().PutPrivateData(collectionSeller, receiptSaleKey, receipt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to put private asset receipt for seller: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getClientOrgID gets the client org ID.</span></span><br><span class="line"><span class="comment">// The client org ID can optionally be verified against the peer org ID, to ensure that a client</span></span><br><span class="line"><span class="comment">// from another org doesn't attempt to read or write private data from this peer.</span></span><br><span class="line"><span class="comment">// The only exception in this scenario is for TransferAsset, since the current owner</span></span><br><span class="line"><span class="comment">// needs to get an endorsement from the buyer's peer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getClientOrgID</span><span class="params">(ctx contractapi.TransactionContextInterface, verifyOrg <span class="keyword">bool</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// GetClientIdentity()获取客户端的身份，返回ClientIdentity接口，这个接口有如下方法：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetID returns the ID associated with the invoking identity.  This ID</span></span><br><span class="line"><span class="comment">// is guaranteed to be unique within the MSP.</span></span><br><span class="line"><span class="comment">// * GetID() (string, error) 获取</span></span><br><span class="line"></span><br><span class="line">clientOrgID, err := ctx.GetClientIdentity().GetMSPID()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"failed getting client's orgID: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> verifyOrg &#123;</span><br><span class="line">err = verifyClientOrgMatchesPeerOrg(clientOrgID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> clientOrgID, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// verifyClientOrgMatchesPeerOrg checks the client org id matches the peer org id.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyClientOrgMatchesPeerOrg</span><span class="params">(clientOrgID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">peerOrgID, err := shim.GetMSPID()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed getting peer's orgID: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> clientOrgID != peerOrgID &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"client from org %s is not authorized to read or write private data from an org %s peer"</span>,</span><br><span class="line">clientOrgID,</span><br><span class="line">peerOrgID,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setAssetStateBasedEndorsement adds an endorsement policy to a asset so that only a peer from an owning org</span></span><br><span class="line"><span class="comment">// can update or transfer the asset.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setAssetStateBasedEndorsement</span><span class="params">(ctx contractapi.TransactionContextInterface, assetID <span class="keyword">string</span>, orgToEndorse <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">endorsementPolicy, err := statebased.NewStateEP(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">err = endorsementPolicy.AddOrgs(statebased.RoleTypeMember, orgToEndorse)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to add org to endorsement policy: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">policy, err := endorsementPolicy.Policy()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to create endorsement policy bytes from org: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fmt.Printf("assetID=%s, orgToEndorse=%s, policy=%s, len(policy)=%d \n", assetID, orgToEndorse, policy, len(policy))</span></span><br><span class="line"><span class="comment">// fmt.Printf("assetID=%s, policy=%s, endorsementPolicy.ListOrgs=%s\n", assetID, string(policy[:]), endorsementPolicy.ListOrgs())</span></span><br><span class="line"><span class="keyword">return</span> ctx.GetStub().SetStateValidationParameter(assetID, policy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildCollectionName</span><span class="params">(clientOrgID <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"_implicit_org_%s"</span>, clientOrgID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getClientImplicitCollectionName</span><span class="params">(ctx contractapi.TransactionContextInterface)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">clientOrgID, err := getClientOrgID(ctx, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"failed to get verified OrgID: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = verifyClientOrgMatchesPeerOrg(clientOrgID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> buildCollectionName(clientOrgID), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">chaincode, err := contractapi.NewChaincode(<span class="built_in">new</span>(SmartContract))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">"Error create transfer asset chaincode: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := chaincode.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">"Error starting asset chaincode: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文档通过学习之前写的chaincode来查看Fabric的智能合约相关的源码。并学习这些源码的功能。&lt;/p&gt;
&lt;h2 id=&quot;智能合约里面的方法如何定义的&quot;&gt;智能合约里面的方法如何定义的&lt;/h2&gt;
&lt;p&gt;智能合约中的每个导出的方法都必须有&lt;code&gt;contractap</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="API" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/API/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="API" scheme="https://guozhe001.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Fabric关键问题20问</title>
    <link href="https://guozhe001.github.io/2021/01/12/blockchain/fabric/Fabric%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%9820%E9%97%AE/"/>
    <id>https://guozhe001.github.io/2021/01/12/blockchain/fabric/Fabric%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%9820%E9%97%AE/</id>
    <published>2021-01-12T03:39:23.842Z</published>
    <updated>2021-01-13T11:59:54.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、是否所有的背书节点都有相同的功能？一笔交易是不是任意的背书节点都可以验证，还是只能由支持此交易的背书节点验证？">1、是否所有的背书节点都有相同的功能？一笔交易是不是任意的背书节点都可以验证，还是只能由支持此交易的背书节点验证？</h2><p>答：只有安装了相同的chaincode的peer节点才具有背书的功能。所以一个peer节点想要成为背书节点，必须安装对应的chaincode。<br>一笔交易肯定是由于调用了链码而产生的，所以这笔交易必须由其他的安装了相同链码的背书节点进行验证。</p><h2 id="2、背书节点在验证的时候是否知道了交易的全部内容，如何保证数据的隐私的？">2、背书节点在验证的时候是否知道了交易的全部内容，如何保证数据的隐私的？</h2><p>答：背书节点在验证的时候可能并不知道交易的全部内容，Fabric有一个名为“transient”的存储，这个存储只在当前peer节点；如果有交易的话“transient”存储的数据会通过Gossip协议隐秘的传输给另一个peer节点。然后这两个peer节点都可以查询到“transient”存储的数据。而channel上的其他成员是无法看到这些数据的，因此并不是所有的背书节点都可以直到交易的全部内容。</p><h3 id="2-1-这个问题会引出另一个新的问题，背书节点在缺少数据的情况下如何进行背书呢？这不就导致背书失败了吗？">2.1 这个问题会引出另一个新的问题，背书节点在缺少数据的情况下如何进行背书呢？这不就导致背书失败了吗？</h3><p>答：是的，拿不到“transient”存储的数据的背书节点会背书失败。但是由于我们可以设置chaincode和key的基于状态的背书策略，因此就算有部分背书节点背书失败了，只要能看到数据的背书节点做了背书并符合背书策略即可达成共识。</p><p>这个问题可以查看<a href="https://guozhe001.github.io/2020/12/31/blockchain/fabric/%E5%9C%A8Fabric%E4%B8%AD%E4%BA%A4%E6%98%93%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E8%B5%84%E4%BA%A7/">在Fabric中交易受保护的资产</a></p><h2 id="3、区块数据的数据结构如果是数组的话，如何做到防篡改？">3、区块数据的数据结构如果是数组的话，如何做到防篡改？</h2><p>答：暂时无法回答此问题，待完成。</p><h2 id="4、主节点是干什么的？主节点可以交易吗？主节点和普通的peer节点有什么不一样？">4、主节点是干什么的？主节点可以交易吗？主节点和普通的peer节点有什么不一样？</h2><p>答：所谓的主节点应该是Order，目前了解到的只是负责交易的排序以及信息的转发。更多内容待学习。</p><h2 id="5、链码是不是就是智能合约？">5、链码是不是就是智能合约？</h2><p>答：链码就是智能合约，只有调用智能合约才可以更改channel上的账本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、是否所有的背书节点都有相同的功能？一笔交易是不是任意的背书节点都可以验证，还是只能由支持此交易的背书节点验证？&quot;&gt;1、是否所有的背书节点都有相同的功能？一笔交易是不是任意的背书节点都可以验证，还是只能由支持此交易的背书节点验证？&lt;/h2&gt;
&lt;p&gt;答：只有安装了</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
  </entry>
  
  <entry>
    <title>在Fabric中使用私有数据</title>
    <link href="https://guozhe001.github.io/2021/01/06/blockchain/fabric/%E5%9C%A8Fabric%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE/"/>
    <id>https://guozhe001.github.io/2021/01/06/blockchain/fabric/%E5%9C%A8Fabric%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE/</id>
    <published>2021-01-06T07:58:09.390Z</published>
    <updated>2021-01-11T10:11:01.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Fabric中使用私有数据">在Fabric中使用私有数据</h1><p>官方文档：<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.html" target="_blank" rel="noopener">Using Private Data in Fabric</a></p><p>This tutorial will demonstrate the use of Private Data Collections (PDC) to provide storage and retrieval of private data on the blockchain network for authorized peers of organizations. The collection is specified using a collection definition file containing the policies governing that collection.</p><p>本教程将演示如何使用私有数据集（PDC）为组织的有权限的peer在区块链网络上提供私有数据的存储和检索。使用包含定义该PDC策略的集合定义文件来管理PDC。</p><p>The information in this tutorial assumes knowledge of private data stores and their use cases. For more information, check out <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private-data/private-data.html" target="_blank" rel="noopener">Private data</a>.</p><p>本教程中的信息假定您了解私有数据存储及其使用案例。有关更多信息，请查看<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private-data/private-data.html" target="_blank" rel="noopener">Private data</a>。</p><p>The tutorial will take you through the following steps to practice defining, configuring and using private data with Fabric:</p><p>本教程将指导您完成以下步骤，以练习定义、配置和使用Fabric私有数据：</p><ol><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.html#pd-use-case" target="_blank" rel="noopener">Asset transfer private data sample use case</a> 资产转移私有数据样例使用方法</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.html#pd-build-json" target="_blank" rel="noopener">Build a collection definition JSON file</a> 构建一个集合定义JSON文件</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.html#pd-read-write-private-data" target="_blank" rel="noopener">Read and Write private data using chaincode APIs</a> 使用chaincode API读写私有数据</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.html#pd-install-define-cc" target="_blank" rel="noopener">Deploy the private data smart contract to the channel</a> 部署私有数据智能合约到通道</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.html#pd-register-identities" target="_blank" rel="noopener">Register identities</a> 注册身份</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.html#pd-store-private-data" target="_blank" rel="noopener">Create an asset in private data</a> 在私有数据集中创建资产</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.html#pd-query-authorized" target="_blank" rel="noopener">Query the private data as an authorized peer</a> 通过有权限的peer查询私有数据</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.html#pd-query-unauthorized" target="_blank" rel="noopener">Query the private data as an unauthorized peer</a> 通过没有权限的peer查询私有数据</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.html#pd-transfer-asset" target="_blank" rel="noopener">Transfer the Asset</a> 交易在私有数据集中的资产</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.html#pd-purge" target="_blank" rel="noopener">Purge Private Data</a> 清除私有数据</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.html#pd-indexes" target="_blank" rel="noopener">Using indexes with private data</a> 对私有数据使用索引</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.html#pd-ref-material" target="_blank" rel="noopener">Additional resources</a> 额外资源</li></ol><p>This tutorial will deploy the <a href="https://github.com/hyperledger/fabric-samples/tree/master/asset-transfer-private-data/chaincode-go" target="_blank" rel="noopener">asset transfer private data sample</a> to the Fabric test network to demonstrate how to create, deploy, and use a collection of private data. You should have completed the task <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/install.html" target="_blank" rel="noopener">Install Samples, Binaries, and Docker Images</a>.</p><p>这个教程会部署 <a href="https://github.com/hyperledger/fabric-samples/tree/master/asset-transfer-private-data/chaincode-go" target="_blank" rel="noopener">asset transfer private data sample</a>到Fabric的测试网络来演示如何创建、部署以及使用PDC。</p><h2 id="Asset-transfer-private-data-sample-use-case（资产转移私有数据样例使用方法）">Asset transfer private data sample use case（资产转移私有数据样例使用方法）</h2><p>This sample demonstrates the use of three private data collections, <code>assetCollection</code>, <code>Org1MSPPrivateCollection</code> &amp; <code>Org2MSPPrivateCollection</code> to transfer an asset between Org1 and Org2, using following use case:</p><p>这个样例使用以下用例演示使用三个私有数据集（PDC）来在Org1和Org2组织之间交易资产；这三个PDC为：<code>assetCollection</code>, <code>Org1MSPPrivateCollection</code> &amp; <code>Org2MSPPrivateCollection</code> 。</p><p>A member of Org1 creates a new asset, henceforth referred as owner. The public details of the asset, including the identity of the owner, are stored in the private data collection named <code>assetCollection</code>. The asset is also created with an appraised value supplied by the owner. The appraised value is used by each participant to agree to the transfer of the asset, and is only stored in owner organization’s collection. In our case, the initial appraisal value agreed by the owner is stored in the <code>Org1MSPPrivateCollection</code>.</p><p>组织Org1的一个成员创建一个新的资产，并拥有这个资产。公共的资产详情，包括拥有者的身份被存储在称作 <code>assetCollection</code>的私有数据集中。资产所有者也会为这个资产创建一个评估价值，通道上的每个参与者都使用这个评估价值来同意资产转让，并且它仅存储在所有者组织的集合中。在我们的案例中，所有者确认的初始评估值存储在<code>Org1MSPPrivateCollection</code>中。</p><p>To purchase the asset, the buyer needs to agree to the same appraised value as the asset owner. In this step, the buyer (a member of Org2) creates an agreement to trade and agree to an appraisal value using smart contract function <code>'AgreeToTransfer'</code>. This value is stored in <code>Org2MSPPrivateCollection</code> collection. Now, the asset owner can transfer the asset to the buyer using smart contract function <code>'TransferAsset'</code>. The <code>'TransferAsset'</code> function uses the hash on the channel ledger to confirm that the owner and the buyer have agreed to the same appraised value before transferring the asset.</p><p>要购买资产，购买者需要同意与资产所有者相同的评估价值。在此步骤中，买方（Org2的成员）使用智能合约的<code>“AgreeToTransfer”</code>方法来创建交易协议并同意评估价值。此值存储在<code>Org2MSPPrivateCollection</code>集合中。现在资产的拥有者可以通过智能合约中的<code>'TransferAsset'</code>方法来交易资产了。 <code>'TransferAsset'</code> 方法在转让资产之前先使用通道账本上的hash来验证买卖双方已经对相同的评估价格达成了一致。</p><p>Before we go through the transfer scenario, we will discuss how organizations can use private data collections in Fabric.</p><p>在此之前，我们将讨论组织如何在Fabric中使用私有数据集合。</p><h2 id="Build-a-collection-definition-JSON-file（构建一个集合定义JSON文件）">Build a collection definition JSON file（构建一个集合定义JSON文件）</h2><p>Before a set of organizations can transact using private data, all organizations on channel need to build a collection definition file that defines the private data collections associated with each chaincode. Data that is stored in a private data collection is only distributed to the peers of certain organizations instead of all members of the channel. The collection definition file describes all of the private data collections that organizations can read and write to from a chaincode.</p><p>在一组组织可以使用私有数据进行交易之前，通道上的所有组织需要构建一个集合定义文件，这个文件定义与每个链码关联的私有数据集合。存储在私有数据集合中的数据仅分发给相同组织的peer节点，而不是分发给通道的所有成员。集合定义文件描述了组织可以通过链码读写的所有私有数据集。</p><p>Each collection is defined by the following properties:</p><ul><li><code>name</code>: Name of the collection.</li><li><code>policy</code>: Defines the organization peers allowed to persist the collection data.</li><li><code>requiredPeerCount</code>: Number of peers required to disseminate the private data as a condition of the endorsement of the chaincode</li><li><code>maxPeerCount</code>: For data redundancy purposes, the number of other peers that the current endorsing peer will attempt to distribute the data to. If an endorsing peer goes down, these other peers are available at commit time if there are requests to pull the private data.</li><li><code>blockToLive</code>: For very sensitive information such as pricing or personal information, this value represents how long the data should live on the private database in terms of blocks. The data will live for this specified number of blocks on the private database and after that it will get purged, making this data obsolete from the network. To keep private data indefinitely, that is, to never purge private data, set the <code>blockToLive</code> property to <code>0</code>.</li><li><code>memberOnlyRead</code>: a value of <code>true</code> indicates that peers automatically enforce that only clients belonging to one of the collection member organizations are allowed read access to private data.</li><li><code>memberOnlyWrite</code>: a value of <code>true</code> indicates that peers automatically enforce that only clients belonging to one of the collection member organizations are allowed write access to private data.</li><li><code>endorsementPolicy</code>: defines the endorsement policy that needs to be met in order to write to the private data collection. The collection level endorsement policy overrides to chaincode level policy. For more information on building a policy definition refer to the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/endorsement-policies.html" target="_blank" rel="noopener">Endorsement policies</a> topic.</li></ul><p>所有的集合都是用下面的属性来定义：</p><ul><li><code>name</code>: 集合名称</li><li><code>policy</code>: 定义允许持久化集合数据的组织的peer节点。</li><li><code>requiredPeerCount</code>: 传播私有数据所需的peer数目，以作为对链码的认可</li><li><code>maxPeerCount</code>: 为了数据冗余，当前合法peer将尝试向其分发数据的其他peer的数量。如果一个合法的peer挂了，如果有请求拉私有数据的请求，则这些其他peer在提交时可用。</li><li><code>blockToLive</code>: 对于如价格或个人信息这类非常敏感的信息，此值表示数据应在私有数据库的块上保存的时间。数据将在私有数据库块上保留指定的时间，然后清除，使该数据从网络上过时。要无限期保留私有数据，即从不清除私有数据，请将<code>blockToLive</code>属性设置为0。</li><li><code>memberOnlyRead</code>: 值为true表示peer节点自动强制只有属于集合成员组织的客户端才允许读取私有数据。</li><li><code>memberOnlyWrite</code>:值为true表示peer节点自动强制只有属于集合成员组织的客户端才允许写入私有数据。</li><li><code>endorsementPolicy</code>: 定义了写入私有数据集合需要满足的认可策略。集合级别的背书策略会覆盖chaincode级别的策略。有关构建策略定义的更多信息，请参考 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/endorsement-policies.html" target="_blank" rel="noopener">Endorsement policies</a>主题。</li></ul><p>The same collection definition file needs to be deployed by all organizations that use the chaincode, even if the organization does not belong to any collections. In addition to the collections that are explicitly defined in a collection file, each organization has access to an implicit collection on their peers that can only be read by their organization. For an example that uses implicit data collections, see the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/secured_asset_transfer/secured_private_asset_transfer_tutorial.html" target="_blank" rel="noopener">Secured asset transfer in Fabric</a>.</p><p>所有使用同一个chaincode的组织都要部署相同的集合定义文件，即使这个组织不属于任何集合。除了在集合文件中显式定义的集合之外，每个组织都可以访问其peer节点上的隐式集合，这些隐式集合只能由其组织读取。使用隐式数据集的例子可以看<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/secured_asset_transfer/secured_private_asset_transfer_tutorial.html" target="_blank" rel="noopener">Secured asset transfer in Fabric</a>。</p><p>The asset transfer private data example contains a collections_config.json file that defines three private data collection definitions: <code>assetCollection</code>, <code>Org1MSPPrivateCollection</code>, and <code>Org2MSPPrivateCollection</code>.</p><p>资产转移私有数据的示例包含一个collections_config.json文件，该文件定义了三个私有数据集合定义：<code>assetCollection</code>, <code>Org1MSPPrivateCollection</code>, and <code>Org2MSPPrivateCollection</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections_config.json</span></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="attr">"name"</span>: <span class="string">"assetCollection"</span>,</span><br><span class="line">   <span class="attr">"policy"</span>: <span class="string">"OR('Org1MSP.member', 'Org2MSP.member')"</span>,</span><br><span class="line">   <span class="attr">"requiredPeerCount"</span>: <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"maxPeerCount"</span>: <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"blockToLive"</span>:<span class="number">1000000</span>,</span><br><span class="line">   <span class="attr">"memberOnlyRead"</span>: <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">"memberOnlyWrite"</span>: <span class="literal">true</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="attr">"name"</span>: <span class="string">"Org1MSPPrivateCollection"</span>,</span><br><span class="line">   <span class="attr">"policy"</span>: <span class="string">"OR('Org1MSP.member')"</span>,</span><br><span class="line">   <span class="attr">"requiredPeerCount"</span>: <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"maxPeerCount"</span>: <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"blockToLive"</span>:<span class="number">3</span>,</span><br><span class="line">   <span class="attr">"memberOnlyRead"</span>: <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">"memberOnlyWrite"</span>: <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">"endorsementPolicy"</span>: &#123;</span><br><span class="line">       <span class="attr">"signaturePolicy"</span>: <span class="string">"OR('Org1MSP.member')"</span></span><br><span class="line">   &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="attr">"name"</span>: <span class="string">"Org2MSPPrivateCollection"</span>,</span><br><span class="line">   <span class="attr">"policy"</span>: <span class="string">"OR('Org2MSP.member')"</span>,</span><br><span class="line">   <span class="attr">"requiredPeerCount"</span>: <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"maxPeerCount"</span>: <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"blockToLive"</span>:<span class="number">3</span>,</span><br><span class="line">   <span class="attr">"memberOnlyRead"</span>: <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">"memberOnlyWrite"</span>: <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">"endorsementPolicy"</span>: &#123;</span><br><span class="line">       <span class="attr">"signaturePolicy"</span>: <span class="string">"OR('Org2MSP.member')"</span></span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>The <code>policy</code> property in the <code>assetCollection</code> definition specifies that both Org1 and Org2 can store the collection on their peers. The <code>memberOnlyRead</code> and <code>memberOnlyWrite</code> parameters are used to specify that only Org1 and Org2 clients can read and write to this collection.</p><p><code>assetCollection</code>定义中的<code>policy</code>属性指定Org1和Org2都可以在其peer节点上存储集合。 <code>memberOnlyRead</code> 和 <code>memberOnlyWrite</code> 参数被用于指定只有Org1和Org2的客户端可以读写这个集合。</p><p>The <code>Org1MSPPrivateCollection</code> collection allows only peers of Org1 to have the private data in their private database, while the <code>Org2MSPPrivateCollection</code> collection can only be stored by the peers of Org2. The <code>endorsementPolicy</code> parameter is used to create a collection specific endorsement policy. Each update to <code>Org1MSPPrivateCollection</code> or <code>Org2MSPPrivateCollection</code> needs to be endorsed by the organization that stores the collection on their peers. We will see how these collections are used to transfer the asset in the course of the tutorial.</p><p><code>Org1MSPPrivateCollection</code> 集合只允许Org1的peer节点在他们的私有数据库中拥有私有数据，而<code>Org2MSPPrivateCollection</code>集合只能由Org2的peer节点存储。 <code>endorsementPolicy</code> 参数用于创建特定集合的认可策略。对<code>Org1MSPPrivateCollection</code>或<code>Org2MSPPrivateCollection</code>的每次更新都需要由将集合存储在其peer节点的组织认可。在本教程中，我们将了解如何使用这些集合来转移资产。</p><p>This collection definition file is deployed when the chaincode definition is committed to the channel using the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-commit" target="_blank" rel="noopener">peer lifecycle chaincode commit command</a>. More details on this process are provided in Section 3 below.</p><p>这个集合定义文件是在使用<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-commit" target="_blank" rel="noopener">peer lifecycle chaincode commit command</a>把链码定义提交到通道时被部署的。</p><h2 id="Read-and-Write-private-data-using-chaincode-APIs（使用chaincode-API读写私有数据）">Read and Write private data using chaincode APIs（使用chaincode API读写私有数据）</h2><p>The next step in understanding how to privatize data on a channel is to build the data definition in the chaincode. The asset transfer private data sample divides the private data into three separate data definitions according to how the data will be accessed.</p><p>下一步是了解如何在链码中建立数据定义来对通道上的数据进行私有化。资产转移私有数据实例根据访问数据的方式将私有数据分为三个单独的数据定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Peers in Org1 and Org2 will have this private data in a side database</span></span><br><span class="line"><span class="keyword">type</span> Asset <span class="keyword">struct</span> &#123;</span><br><span class="line">       Type  <span class="keyword">string</span> <span class="string">`json:"objectType"`</span> <span class="comment">//Type is used to distinguish the various types of objects in state database</span></span><br><span class="line">       ID    <span class="keyword">string</span> <span class="string">`json:"assetID"`</span></span><br><span class="line">       Color <span class="keyword">string</span> <span class="string">`json:"color"`</span></span><br><span class="line">       Size  <span class="keyword">int</span>    <span class="string">`json:"size"`</span></span><br><span class="line">       Owner <span class="keyword">string</span> <span class="string">`json:"owner"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AssetPrivateDetails describes details that are private to owners</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Only peers in Org1 will have this private data in a side database</span></span><br><span class="line"><span class="keyword">type</span> AssetPrivateDetails <span class="keyword">struct</span> &#123;</span><br><span class="line">       ID             <span class="keyword">string</span> <span class="string">`json:"assetID"`</span></span><br><span class="line">       AppraisedValue <span class="keyword">int</span>    <span class="string">`json:"appraisedValue"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only peers in Org2 will have this private data in a side database</span></span><br><span class="line"><span class="keyword">type</span> AssetPrivateDetails <span class="keyword">struct</span> &#123;</span><br><span class="line">       ID             <span class="keyword">string</span> <span class="string">`json:"assetID"`</span></span><br><span class="line">       AppraisedValue <span class="keyword">int</span>    <span class="string">`json:"appraisedValue"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Specifically, access to the private data will be restricted as follows:</p><ul><li><code>objectType, color, size, and owner</code> are stored in <code>assetCollection</code> and hence will be visible to members of the channel per the definition in the collection policy (Org1 and Org2).</li><li><code>AppraisedValue</code> of an asset is stored in collection <code>Org1MSPPrivateCollection</code> or <code>Org2MSPPrivateCollection</code> , depending on the owner of the asset. The value is only accessible to the users who belong to the organization that can store the collection.</li></ul><p>具体来说，对私有数据的访问将受到以下限制：</p><ul><li><code>objectType, color, size, and owner</code> 被存储在 <code>assetCollection</code> 因此，根据集合策略中的定义，这些数据对通道上的Org1和Org2是可以访问的。</li><li>资产的评估价值被存储在 <code>Org1MSPPrivateCollection</code> 或 <code>Org2MSPPrivateCollection</code> 集合中，取决于资产的所有者。只有属于可以存储集合的组织的用户才能访问该评估值。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在Fabric中使用私有数据&quot;&gt;在Fabric中使用私有数据&lt;/h1&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/release-2.2/private_data_tutorial.</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="Secured" scheme="https://guozhe001.github.io/tags/Secured/"/>
    
    <category term="Private Data" scheme="https://guozhe001.github.io/tags/Private-Data/"/>
    
  </entry>
  
  <entry>
    <title>背书策略（Endorsement policies）</title>
    <link href="https://guozhe001.github.io/2021/01/06/blockchain/fabric/Endorsement%20policies%E8%83%8C%E4%B9%A6%E7%AD%96%E7%95%A5/"/>
    <id>https://guozhe001.github.io/2021/01/06/blockchain/fabric/Endorsement%20policies%E8%83%8C%E4%B9%A6%E7%AD%96%E7%95%A5/</id>
    <published>2021-01-06T02:45:38.665Z</published>
    <updated>2021-01-06T08:03:19.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背书策略">背书策略</h1><p>官方文档：<a href="https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html#endorsement-policy-syntax" target="_blank" rel="noopener">Endorsement policies</a></p><p>。。。省略部分</p><h2 id="Setting-chaincode-level-endorsement-policies-设置链码级别的背书策略">Setting chaincode-level endorsement policies(设置链码级别的背书策略)</h2><p>Chaincode-level endorsement policies are agreed to by channel members when they approve a chaincode definition for their organization. A sufficient number of channel members need to approve a chaincode definition to meet the <code>Channel/Application/LifecycleEndorsement</code> policy, which by default is set to a majority of channel members, before the definition can be committed to the channel. Once the definition has been committed, the chaincode is ready to use. Any invoke of the chaincode that writes data to the ledger will need to be validated by enough channel members to meet the endorsement policy.</p><p>通道成员在为其组织批准链码定义时，会同意链码级认可策略。需要足够数量的通道成员批准链码定义才能满足Channel / Application / LifecycleEndorsement策略，该策略默认情况下设置为大多数通道成员，然后才能将链码定义提交给通道。提交定义后，便可以使用链码了。任何将数据写入账本的链码的调用都需要由足够的通道成员来验证，以满足背书策略。</p><p>You can specify an endorsement policy for a chaincode using the Fabric SDKs. For an example, visit the <a href="https://hyperledger.github.io/fabric-sdk-node/master/tutorial-chaincode-lifecycle.html" target="_blank" rel="noopener">How to install and start your chaincode</a> in the Node.js SDK documentation. You can also create an endorsement policy from your CLI when you approve and commit a chaincode definition with the Fabric peer binaries by using the <code>--signature-policy</code> flag.</p><p>你可以使用Fabric SDKs来为链码指定背书策略，访问<a href="https://hyperledger.github.io/fabric-sdk-node/master/tutorial-chaincode-lifecycle.html" target="_blank" rel="noopener">How to install and start your chaincode</a>来查看使用Node.js SDK的文档。你也可以通过CLI在批准和提交链码定义时来创建背书策略，使用Fabric的peer可执行程序时使用 <code>--signature-policy</code> 标志来实现这个功能。</p><p>For example：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode approveformyorg --channelID mychannel --signature-policy "AND('Org1.member', 'Org2.member')" --name mycc --version 1.0 --package-id mycc_1:3a8c52d70c36313cfebbaf09d8616e7a6318ababa01c7cbe40603c373bcfe173 --sequence 1 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --waitForEvent</span><br></pre></td></tr></table></figure><p>The above command approves the chaincode definition of <code>mycc</code> with the policy <code>AND('Org1.member', 'Org2.member')</code> which would require that a member of both Org1 and Org2 sign the transaction. After a sufficient number of channel members approve a chaincode definition for <code>mycc</code>, the definition and endorsement policy can be committed to the channel using the command below:</p><p>上面的命令使用 <code>AND('Org1.member', 'Org2.member')</code> 策略来批准<code>mycc</code>的链码定义，这个策略要求Org1和Org2的成员都需要对一笔交易进行签名。在有足够的通道成员批准了<code>mycc</code>的链码定义之后，这个定义和背书策略就可以使用下面的命令被提交到通道了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode commit -o orderer.example.com:7050 --channelID mychannel --signature-policy "AND('Org1.member', 'Org2.member')" --name mycc --version 1.0 --sequence 1 --init-required --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --waitForEvent --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br></pre></td></tr></table></figure><p>Notice that, if the identity classification is enabled (see <a href="https://hyperledger-fabric.readthedocs.io/en/latest/msp.html" target="_blank" rel="noopener">Membership Service Providers (MSP)</a>), one can use the <code>PEER</code> role to restrict endorsement to only peers.</p><p>请注意，如果启用了身份分类（请参阅 <a href="https://hyperledger-fabric.readthedocs.io/en/latest/msp.html" target="_blank" rel="noopener">Membership Service Providers (MSP)</a>），则可以使用<code>PEER</code>角色将背书限制为仅peer节点。</p><p>For example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode approveformyorg --channelID mychannel --signature-policy "AND('Org1.peer', 'Org2.peer')" --name mycc --version 1.0 --package-id mycc_1:3a8c52d70c36313cfebbaf09d8616e7a6318ababa01c7cbe40603c373bcfe173 --sequence 1 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --waitForEvent</span><br></pre></td></tr></table></figure><p>In addition to the specifying an endorsement policy from the CLI or SDK, a chaincode can also use policies in the channel configuration as endorsement policies. You can use the <code>--channel-config-policy</code> flag to select a channel policy with format used by the channel configuration and by ACLs.</p><p>除了从CLI或SDK中指定背书策略以外，链码还可以使用通道配置中的策略作为背书策略。你可以使用<code>--channel-config-policy</code>标志来选择一个通道策略，其格式由通道配置和ACL使用。</p><p>For example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode approveformyorg --channelID mychannel --channel-config-policy Channel/Application/Admins --name mycc --version 1.0 --package-id mycc_1:3a8c52d70c36313cfebbaf09d8616e7a6318ababa01c7cbe40603c373bcfe173 --sequence 1 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --waitForEvent</span><br></pre></td></tr></table></figure><p>If you do not specify a policy, the chaincode definition will use the <code>Channel/Application/Endorsement</code> policy by default, which requires that a transaction be validated by a majority of channel members. This policy depends on the membership of the channel, so it will be updated automatically when organizations are added or removed from a channel. One advantage of using channel policies is that they can be written to be updated automatically with channel membership.</p><p>如果你不指定背书策略，链码定义会使用默认的 <code>Channel/Application/Endorsement</code>策略，这个策略要求交易必须经过大多数通道成员的验证。该策略取决于通道成员，因此从通道中添加或删除组织时，它将自动更新。使用通道策略的一个优势是，可以将其编写为根据通道成员数量自动更新。</p><p>If you specify an endorsement policy using the <code>--signature-policy</code> flag or the SDK, you will need to update the policy when organizations join or leave the channel. A new organization added to the channel after the chaincode has been defined will be able to query a chaincode (provided the query has appropriate authorization as defined by channel policies and any application level checks enforced by the chaincode) but will not be able to execute or endorse the chaincode. Only organizations listed in the endorsement policy syntax will be able sign transactions.</p><p>如果你使用 <code>--signature-policy</code> 标志或者SDK指定了背书策略，你需要在组织加入或者离开通道时更新这个策略。一个新的组织在链码被定义好之后加入这个通道，这个组织可以查询这个链码（提供查询具有通道策略和链码强制执行的任何应用程序级别检查所定义的适当授权），但是不能够执行或认可链码。只有组织在认可策略语法的列表中之后，组织才能签署交易。</p><h3 id="个人验证">个人验证</h3><p>chaincode如果不设置背书策略，则默认的背书策略是：<code> /Channel/Application/Endorsement</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">apple$</span><span class="bash"> peer lifecycle chaincode querycommitted --channelID alljoinchannel --name secured_supply --output json</span></span><br><span class="line">&#123;</span><br><span class="line">"sequence": 6,</span><br><span class="line">"version": "3.0",</span><br><span class="line">"endorsement_plugin": "escc",</span><br><span class="line">"validation_plugin": "vscc",</span><br><span class="line">"validation_parameter": "EiAvQ2hhbm5lbC9BcHBsaWNhdGlvbi9FbmRvcnNlbWVudA==",</span><br><span class="line">"collections": &#123;&#125;,</span><br><span class="line">"approvals": &#123;</span><br><span class="line">"GylCoreOrg1MSP": true,</span><br><span class="line">"GylFOrg1MSP": true,</span><br><span class="line">"GylSOrg1MSP": true,</span><br><span class="line">"GylSOrg2MSP": true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置背书策略为<code>--signature-policy &quot;OR('GylCoreOrg1MSP.peer','GylFOrg1MSP.peer','GylSOrg1MSP.peer','GylSOrg2MSP.peer')&quot;</code>，再次查询链码定义：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">apple$</span><span class="bash"> peer lifecycle chaincode querycommitted --channelID alljoinchannel --name secured_supply --output json</span></span><br><span class="line">&#123;</span><br><span class="line">"sequence": 7,</span><br><span class="line">"version": "3.0",</span><br><span class="line">"endorsement_plugin": "escc",</span><br><span class="line">"validation_plugin": "vscc",</span><br><span class="line">"validation_parameter": "CmUSFBISCAESAggAEgIIARICCAISAggDGhQSEgoOR3lsQ29yZU9yZzFNU1AQAxoREg8KC0d5bEZPcmcxTVNQEAMaERIPCgtHeWxTT3JnMU1TUBADGhESDwoLR3lsU09yZzJNU1AQAw==",</span><br><span class="line">"collections": &#123;&#125;,</span><br><span class="line">"approvals": &#123;</span><br><span class="line">"GylCoreOrg1MSP": true,</span><br><span class="line">"GylFOrg1MSP": true,</span><br><span class="line">"GylSOrg1MSP": true,</span><br><span class="line">"GylSOrg2MSP": true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解码之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e</span><br><span class="line">GylCoreOrg1MSP</span><br><span class="line">GylFOrg1MSP</span><br><span class="line">GylSOrg1MSP</span><br><span class="line">GylSOrg2MSP</span><br></pre></td></tr></table></figure><h3 id="Endorsement-policy-syntax（背书策略的语法）">Endorsement policy syntax（背书策略的语法）</h3><p>As you can see above, policies are expressed in terms of principals (“principals” are identities matched to a role). Principals are described as <code>'MSP.ROLE'</code>, where <code>MSP</code> represents the required MSP ID and <code>ROLE</code> represents one of the four accepted roles: <code>member</code>, <code>admin</code>, <code>client</code>, and <code>peer</code>.</p><p>正如您在上面看到的那样，策略是根据主体表达的（“主体”是与角色匹配的身份）。主体被描述为<code>'MSP.ROLE'</code>，其中<code>MSP</code>代表所需的MSP ID,<code>ROLE</code> 代表四个公认的角色之一：<code>member</code>, <code>admin</code>, <code>client</code>，和 <code>peer</code>。</p><p>Here are a few examples of valid principals:</p><ul><li><code>'Org0.admin'</code>: any administrator of the <code>Org0</code> MSP</li><li><code>'Org1.member'</code>: any member of the <code>Org1</code> MSP</li><li><code>'Org1.client'</code>: any client of the <code>Org1</code> MSP</li><li><code>'Org1.peer'</code>: any peer of the <code>Org1</code> MSP</li></ul><p>The syntax of the language is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPR(E[, E...])</span><br></pre></td></tr></table></figure><p>Where <code>EXPR</code> is either <code>AND</code>, <code>OR</code>, or <code>OutOf</code>, and <code>E</code> is either a principal (with the syntax described above) or another nested call to <code>EXPR</code>.</p><p><code>EXPR</code> 可以为<code>AND</code>, <code>OR</code>, or <code>OutOf</code>，<code>E</code>可以是一个具有上面语法的主体，也可以是对另一个<code>EXPR</code>的嵌套调用。</p><p>For example:</p><ul><li><p><code>AND('Org1.member', 'Org2.member', 'Org3.member')</code> requests one signature from each of the three principals.</p></li><li><p><code>OR('Org1.member', 'Org2.member')</code> requests one signature from either one of the two principals.</p></li><li><p><code>OR('Org1.member', AND('Org2.member', 'Org3.member'))</code> requests either one signature from a member of the <code>Org1</code> MSP or one signature from a member of the <code>Org2</code> MSP and one signature from a member of the <code>Org3</code> MSP.</p></li><li><p><code>OutOf(1, 'Org1.member', 'Org2.member')</code>, which resolves to the same thing as <code>OR('Org1.member', 'Org2.member')</code>.</p></li><li><p>Similarly, <code>OutOf(2, 'Org1.member', 'Org2.member')</code> is equivalent to <code>AND('Org1.member', 'Org2.member')</code>, and <code>OutOf(2, 'Org1.member', 'Org2.member', 'Org3.member')</code> is equivalent to <code>OR(AND('Org1.member', 'Org2.member'), AND('Org1.member', 'Org3.member'), AND('Org2.member', 'Org3.member'))</code>.</p></li></ul><p>例如：</p><ul><li><p><code>AND('Org1.member', 'Org2.member', 'Org3.member')</code> 三个主体都需要进行签名。</p></li><li><p><code>OR('Org1.member', 'Org2.member')</code> 只需要两个主体的其中一个提供签名。</p></li><li><p><code>OR('Org1.member', AND('Org2.member', 'Org3.member'))</code> 需要Org1提供签名，或者需要Org2和Org3同时提供签名。</p></li><li><p><code>OutOf(1, 'Org1.member', 'Org2.member')</code>, 和 <code>OR('Org1.member', 'Org2.member')</code>做的事情一样。</p></li><li><p>相似的, <code>OutOf(2, 'Org1.member', 'Org2.member')</code> 与 <code>AND('Org1.member', 'Org2.member')</code>相同</p></li><li><p><code>OutOf(2, 'Org1.member', 'Org2.member', 'Org3.member')</code> 与 <code>OR(AND('Org1.member', 'Org2.member'), AND('Org1.member', 'Org3.member'), AND('Org2.member', 'Org3.member'))</code>相同。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背书策略&quot;&gt;背书策略&lt;/h1&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html#endorsement-policy-sy</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="Endorsement policies" scheme="https://guozhe001.github.io/tags/Endorsement-policies/"/>
    
  </entry>
  
  <entry>
    <title>fabric命令记录.md</title>
    <link href="https://guozhe001.github.io/2021/01/05/blockchain/fabric/%E9%80%9A%E8%BF%87%E4%BE%9B%E5%BA%94%E9%93%BE%E9%87%91%E8%9E%8D%E7%BB%83%E4%B9%A0Fabric/fabric%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
    <id>https://guozhe001.github.io/2021/01/05/blockchain/fabric/%E9%80%9A%E8%BF%87%E4%BE%9B%E5%BA%94%E9%93%BE%E9%87%91%E8%9E%8D%E7%BB%83%E4%B9%A0Fabric/fabric%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</id>
    <published>2021-01-05T03:42:42.207Z</published>
    <updated>2021-01-05T03:43:47.527Z</updated>
    
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="供应链金融" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/%E4%BE%9B%E5%BA%94%E9%93%BE%E9%87%91%E8%9E%8D/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
  </entry>
  
  <entry>
    <title>隐秘交易.md</title>
    <link href="https://guozhe001.github.io/2021/01/05/blockchain/fabric/%E9%80%9A%E8%BF%87%E4%BE%9B%E5%BA%94%E9%93%BE%E9%87%91%E8%9E%8D%E7%BB%83%E4%B9%A0Fabric/%E9%9A%90%E7%A7%98%E4%BA%A4%E6%98%93/"/>
    <id>https://guozhe001.github.io/2021/01/05/blockchain/fabric/%E9%80%9A%E8%BF%87%E4%BE%9B%E5%BA%94%E9%93%BE%E9%87%91%E8%9E%8D%E7%BB%83%E4%B9%A0Fabric/%E9%9A%90%E7%A7%98%E4%BA%A4%E6%98%93/</id>
    <published>2021-01-05T03:28:50.056Z</published>
    <updated>2021-01-12T06:40:21.539Z</updated>
    
    <content type="html"><![CDATA[<p>自己开发的智能合约在channel上的所有成员都可以看到，这不符合现实世界中的交易规则。理论上两个组织之间的交易是不允许别人看到的。所以这次我使用fabric-samples提供的<code>asset-transfer-secured-agreement</code>来作为我的供应链金融区块链项目的chaincode。</p><h2 id="部署链码">部署链码</h2><h3 id="打包">打包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode package secured_supply.5.tar.gz --path ./asset-transfer-secured-agreement/chaincode-go --lang golang --label secured_supply_15.0</span><br></pre></td></tr></table></figure><h3 id="安装链码包-每个peer都要安装：">安装链码包,每个peer都要安装：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode install secured_supply.5.tar.gz</span><br></pre></td></tr></table></figure><h3 id="批准链码定义">批准链码定义</h3><h4 id="查看已经安装的chaincode">查看已经安装的chaincode</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode queryinstalled</span><br></pre></td></tr></table></figure><p>将链码的信息保存为一个变量，两个组织都需要定义此变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CC_PACKAGE_ID=secured_supply_15.0:3ea87d3c0b13f8711e0bacbd9dcb8965acdde79241006f9bbfc89dfb6a822126</span><br></pre></td></tr></table></figure><h4 id="批准链码定义，每个peer都要执行此命令：">批准链码定义，每个peer都要执行此命令：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode approveformyorg -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --channelID alljoinchannel --name secured_supply --version 15.0 --package-id $CC_PACKAGE_ID --sequence 15 --signature-policy "OR('GylCoreOrg1MSP.member','GylFOrg1MSP.member','GylSOrg1MSP.member','GylSOrg2MSP.member')" --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem</span><br></pre></td></tr></table></figure><h3 id="将链码定义提交到通道">将链码定义提交到通道</h3><h4 id="检查channel上的成员是否已经批准了链码定义：">检查channel上的成员是否已经批准了链码定义：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode checkcommitreadiness --channelID alljoinchannel --name secured_supply --version 15.0 --sequence 15 --signature-policy "OR('GylCoreOrg1MSP.member','GylFOrg1MSP.member','GylSOrg1MSP.member','GylSOrg2MSP.member')" --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem --output json</span><br></pre></td></tr></table></figure><h4 id="在所有组织都批准之后，执行下面的命令将链码定义提交到通道：">在所有组织都批准之后，执行下面的命令将链码定义提交到通道：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode commit -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --channelID alljoinchannel --name secured_supply --version 15.0 --sequence 15 --signature-policy "OR('GylCoreOrg1MSP.member','GylFOrg1MSP.member','GylSOrg1MSP.member','GylSOrg2MSP.member')" --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem --peerAddresses localhost:8053 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/f1.supply.com/peers/peer0.f1.supply.com/tls/ca.crt --peerAddresses localhost:8055 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/s1.supply.com/peers/peer0.s1.supply.com/tls/ca.crt --peerAddresses localhost:8151 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/s2.supply.com/peers/peer0.s2.supply.com/tls/ca.crt --peerAddresses localhost:8051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/core.supply.com/peers/peer0.core.supply.com/tls/ca.crt</span><br></pre></td></tr></table></figure><p>使用 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-querycommitted" target="_blank" rel="noopener">peer lifecycle chaincode querycommitted</a> 命令来确认链码定义已经提交到通道。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode querycommitted --channelID alljoinchannel --name secured_supply --output json</span><br></pre></td></tr></table></figure><h2 id="调用链码">调用链码</h2><h3 id="创建资产">创建资产</h3><p><em><strong>资产的内容需要打个问号，因为这个资产在后面需要被交易，如果资产的内容不能够修改那么合同和发票的hash应该不在资产的详细信息里面，这里先放这里后面再改</strong></em></p><p><em><strong>发行者能否放在外面而不是资产里面？哪种方式比较好呢？</strong></em></p><p>在核心企业的节点创建一个资产如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PROPERTIES=$(echo -n "&#123;\"objectType\":\"asset_properties\",\"assetID\":\"asset010\",\"issuer\":\"GylCoreOrg1MSP\",\"amount\":1000,\"createDate\":\"2020-01-11T06:57:06.963617Z\",\"endDate\":\"2021-07-11T06:57:06.963617Z\",\"salt\":\"224cba6c547aecc76ab6acfac41d12dfd96e7165\"&#125;" | base64 | tr -d \\n)</span><br></pre></td></tr></table></figure><p>在核心企业的节点上调用chaincode，创建资产：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"CreateAsset","Args":["asset010", "A new asset for GylCoreOrg1MSP"]&#125;' --transient "&#123;\"asset_properties\":\"$ASSET_PROPERTIES\"&#125;"</span><br></pre></td></tr></table></figure><p>在私有数据集中查询刚才创建的资产：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetPrivateProperties","Args":["asset010"]&#125;'|jq</span><br></pre></td></tr></table></figure><p>成功结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset_properties"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset010"</span>,</span><br><span class="line">  <span class="attr">"issuer"</span>: <span class="string">"GylCoreOrg1MSP"</span>,</span><br><span class="line">  <span class="attr">"amount"</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">"createDate"</span>: <span class="string">"2020-01-11T06:57:06.963617Z"</span>,</span><br><span class="line">  <span class="attr">"endDate"</span>: <span class="string">"2021-07-11T06:57:06.963617Z"</span>,</span><br><span class="line">  <span class="attr">"salt"</span>: <span class="string">"224cba6c547aecc76ab6acfac41d12dfd96e7165"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询账本来查看公共记录，所有在channel上的成员都可以查询得到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ReadAsset","Args":["asset010"]&#125;'</span><br></pre></td></tr></table></figure><p>返回结果，channel上的成员只能看到资产的部分信息，详细信息是无法看到的。：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset010"</span>,</span><br><span class="line">  <span class="attr">"ownerOrg"</span>: <span class="string">"GylCoreOrg1MSP"</span>,</span><br><span class="line">  <span class="attr">"publicDescription"</span>: <span class="string">"A new asset for GylCoreOrg1MSP"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"enable"</span>,</span><br><span class="line">  <span class="attr">"parentID"</span>: <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资产拥有者更改资产的公共信息">资产拥有者更改资产的公共信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ChangePublicDescription","Args":["asset010","This asset is for sale"]&#125;'</span><br></pre></td></tr></table></figure><p>上面的方法，在核心企业的peer节点返回日志如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-01-07 16:07:43.589 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</span><br></pre></td></tr></table></figure><p>其他的组织如果想要调用这个链码的方法更改信息，则会报错，因为属于核心企业的资产别人不可以更改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: endorsement failure during invoke. response: status:500 message:"a client from GylFOrg1MSP cannot update the description of a asset owned by GylCoreOrg1MSP"</span><br></pre></td></tr></table></figure><h3 id="资产交易">资产交易</h3><h4 id="允许出售资产">允许出售资产</h4><p>现在核心企业要与一级供应商交易核心企业的资产。首先核心企业与一级供应商要在链下对价格达成共识，并且核心企业要把资产的详情也通过链下的通道发送给一级供应商。之后买卖双方就可以对价格达成共识了。</p><h5 id="核心企业将资产的价格设置为1000：">核心企业将资产的价格设置为1000：</h5><p>下面的trade_id是合同的hash值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PRICE=$(echo -n "&#123;\"asset_id\":\"asset007\",\"trade_id\":\"93b46869be90a6b1f688357965f89b5a8a5e32bf13710fb4ad00e25cca0f0b14\",\"price\":1000&#125;" | base64)</span><br><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"AgreeToSell","Args":["asset007"]&#125;' --transient "&#123;\"asset_price\":\"$ASSET_PRICE\"&#125;"</span><br></pre></td></tr></table></figure><p>查询核心企业的私有数据集合来读取同意的销售价格：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetSalesPrice","Args":["asset007"]&#125;'</span><br></pre></td></tr></table></figure><h5 id="一级供应商出价1000">一级供应商出价1000</h5><p>在一级供应商出价之前，他需要先验证资产的信息是否正确。此链码中返回true即为正确。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">export</span> ASSET_PROPERTIES=$(<span class="built_in">echo</span> -n <span class="string">"&#123;\"object_type\":\"asset_properties\",\"asset_id\":\"asset006\",\"issuer\":\"GylCoreOrg1MSP\",\"amount\":1000,\"createDate\":\"2020-01-11T06:57:06.963617Z\",\"endDate\":\"2021-07-11T06:57:06.963617Z\",\"salt\":\"224cba6c547aecc76ab6acfac41d12dfd96e7165\"&#125;"</span> | base64 | tr -d \\n)</span></span><br><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"VerifyAssetProperties","Args":["asset007"]&#125;' --transient "&#123;\"asset_properties\":\"$ASSET_PROPERTIES\"&#125;"</span><br></pre></td></tr></table></figure><p>验证通过之后，就对资产出价：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PRICE=$(echo -n "&#123;\"asset_id\":\"asset007\",\"trade_id\":\"93b46869be90a6b1f688357965f89b5a8a5e32bf13710fb4ad00e25cca0f0b14\",\"price\":1000&#125;" | base64)</span><br><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"AgreeToBuy","Args":["asset007"]&#125;' --transient "&#123;\"asset_price\":\"$ASSET_PRICE\"&#125;"</span><br></pre></td></tr></table></figure><p>可以在一级供应商的隐私数据集中查询到出价信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetBidPrice","Args":["asset007"]&#125;'</span><br></pre></td></tr></table></figure><p><strong>如果在其他组织上查询，会看到如下错误，说明出价卖出设置的价格信息是隐秘的：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: endorsement failure during query. response: status:500 message:"asset price does not exist: asset001"</span><br></pre></td></tr></table></figure><h4 id="核心企业把资产转移给一级供应商">核心企业把资产转移给一级供应商</h4><p>核心企业和一级供应商对相同的价格达成共识之后，核心企业就可以把资产转移给一级供应商了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply --peerAddresses localhost:8051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/core.supply.com/peers/peer0.core.supply.com/tls/ca.crt --peerAddresses localhost:8053 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/f1.supply.com/peers/peer0.f1.supply.com/tls/ca.crt -c '&#123;"function":"TransferAsset","Args":["asset007","GylFOrg1MSP"]&#125;' --transient "&#123;\"asset_properties\":\"$ASSET_PROPERTIES\",\"asset_price\":\"$ASSET_PRICE\"&#125;"</span><br></pre></td></tr></table></figure><p>查询公共数据的资产归属以验证交易成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ReadAsset","Args":["asset001"]&#125;'</span><br></pre></td></tr></table></figure><h3 id="交易验证">交易验证</h3><p>除了交易双方其他人无法查看到资产详情</p><h5 id="验证一级供应商可以修改自己的资产的公共属性：">验证一级供应商可以修改自己的资产的公共属性：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ChangePublicDescription","Args":["asset005","This asset is not for sale now"]&#125;'</span><br></pre></td></tr></table></figure><p>然后通过所有四个组织查询资产ID为asset005的公共信息如下，说明一级供应商已经获得了修改权限并修改了这个资产的公共信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) w:supply-finance apple$ peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ReadAsset","Args":["asset005"]&#125;'|jq</span><br><span class="line">&#123;</span><br><span class="line">  "objectType": "asset",</span><br><span class="line">  "assetID": "asset005",</span><br><span class="line">  "ownerOrg": "GylFOrg1MSP",</span><br><span class="line">  "publicDescription": "This asset is not for sale now"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="验证核心企业不可以再修改这个资产的公共信息">验证核心企业不可以再修改这个资产的公共信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ChangePublicDescription","Args":["asset005","This asset is not for sale again"]&#125;'</span><br></pre></td></tr></table></figure><p>结果报错如下，符合预期：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: endorsement failure during invoke. response: status:500 message:"a client from GylCoreOrg1MSP cannot update the description of a asset owned by GylFOrg1MSP"</span><br></pre></td></tr></table></figure><h5 id="验证只有一级供应商才可以查询这个资产的私有信息">验证只有一级供应商才可以查询这个资产的私有信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetPrivateProperties","Args":["asset005"]&#125;'</span><br></pre></td></tr></table></figure><p>结果如下，验证通过：</p><p>再一级供应商的peer节点可以查询到资产的私有属性，其他组织的peer节点都报错：<code>Error: endorsement failure during query. response: status:500 message:&quot;asset private details does not exist in client org's collection: asset005&quot;</code></p><h2 id="资产拆分">资产拆分</h2><h3 id="调用拆分方法">调用拆分方法</h3><p>完成资产的拆分chaincode的更新之后，调用拆分的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"SplitAsset","Args":["asset010", "500"]&#125;'</span><br></pre></td></tr></table></figure><h3 id="验证拆分结果">验证拆分结果</h3><h4 id="私有数据验证">私有数据验证</h4><h5 id="第一个资产：">第一个资产：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetPrivateProperties","Args":["asset0101"]&#125;'|jq</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "objectType": "asset_properties",</span><br><span class="line">  "assetID": "asset0101",</span><br><span class="line">  "issuer": "GylCoreOrg1MSP",</span><br><span class="line">  "amount": 500,</span><br><span class="line">  "createDate": "2020-01-11T06:57:06.963617Z",</span><br><span class="line">  "endDate": "2021-07-11T06:57:06.963617Z",</span><br><span class="line">  "salt": "224cba6c547aecc76ab6acfac41d12dfd96e7165"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第二个资产：">第二个资产：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetPrivateProperties","Args":["asset0102"]&#125;'|jq</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset_properties"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset0102"</span>,</span><br><span class="line">  <span class="attr">"issuer"</span>: <span class="string">"GylCoreOrg1MSP"</span>,</span><br><span class="line">  <span class="attr">"amount"</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="attr">"createDate"</span>: <span class="string">"2020-01-11T06:57:06.963617Z"</span>,</span><br><span class="line">  <span class="attr">"endDate"</span>: <span class="string">"2021-07-11T06:57:06.963617Z"</span>,</span><br><span class="line">  <span class="attr">"salt"</span>: <span class="string">"224cba6c547aecc76ab6acfac41d12dfd96e7165"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="原始的资产：">原始的资产：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetPrivateProperties","Args":["asset010"]&#125;'|jq</span><br></pre></td></tr></table></figure><p>结果如下，原始资产已经没有了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: endorsement failure during query. response: status:500 message:"asset private details does not exist in client org's collection: asset010"</span><br></pre></td></tr></table></figure><h4 id="公共数据验证">公共数据验证</h4><h5 id="第一个资产：-v2">第一个资产：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ReadAsset","Args":["asset0101"]&#125;'|jq</span><br></pre></td></tr></table></figure><p>结果如下，channel上的所有的组织都可以看到相同的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset0101"</span>,</span><br><span class="line">  <span class="attr">"ownerOrg"</span>: <span class="string">"GylCoreOrg1MSP"</span>,</span><br><span class="line">  <span class="attr">"publicDescription"</span>: <span class="string">"A new asset for GylCoreOrg1MSP"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"enable"</span>,</span><br><span class="line">  <span class="attr">"parentID"</span>: <span class="string">"asset010"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第二个资产：-v2">第二个资产：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ReadAsset","Args":["asset0102"]&#125;'|jq</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset0102"</span>,</span><br><span class="line">  <span class="attr">"ownerOrg"</span>: <span class="string">"GylCoreOrg1MSP"</span>,</span><br><span class="line">  <span class="attr">"publicDescription"</span>: <span class="string">"A new asset for GylCoreOrg1MSP"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"enable"</span>,</span><br><span class="line">  <span class="attr">"parentID"</span>: <span class="string">"asset010"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="原始的资产：-v2">原始的资产：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ReadAsset","Args":["asset010"]&#125;'|jq</span><br></pre></td></tr></table></figure><p>结果如下，chaincode有问题，拆分资产之后原始资产的状态应该改变：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset010"</span>,</span><br><span class="line">  <span class="attr">"ownerOrg"</span>: <span class="string">"GylCoreOrg1MSP"</span>,</span><br><span class="line">  <span class="attr">"publicDescription"</span>: <span class="string">"已拆分"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"delete"</span>,</span><br><span class="line">  <span class="attr">"parentID"</span>: <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拆分后的资产交易">拆分后的资产交易</h2><h4 id="核心允许出售资产，价格设置为500：">核心允许出售资产，价格设置为500：</h4><p>下面的trade_id是合同的hash值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PRICE=$(echo -n "&#123;\"asset_id\":\"asset0101\",\"trade_id\":\"93b46869be90a6b1f688357965f89b5a8a5e32bf13710fb4ad00e25cca0f0b14\",\"price\":500&#125;" | base64)</span><br><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"AgreeToSell","Args":["asset0101"]&#125;' --transient "&#123;\"asset_price\":\"$ASSET_PRICE\"&#125;"</span><br></pre></td></tr></table></figure><p>查询核心企业的私有数据集合来读取同意的销售价格：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetSalesPrice","Args":["asset0101"]&#125;'</span><br></pre></td></tr></table></figure><h5 id="一级供应商出价500">一级供应商出价500</h5><p>在一级供应商出价之前，他需要先验证资产的信息是否正确。此链码中返回true即为正确。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PROPERTIES=$(echo -n "&#123;\"objectType\":\"asset_properties\",\"assetID\":\"asset0101\",\"issuer\":\"GylCoreOrg1MSP\",\"amount\":500,\"createDate\":\"2020-01-11T06:57:06.963617Z\",\"endDate\":\"2021-07-11T06:57:06.963617Z\",\"salt\":\"224cba6c547aecc76ab6acfac41d12dfd96e7165\"&#125;" | base64 | tr -d \\n)</span><br><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"VerifyAssetProperties","Args":["asset0101"]&#125;' --transient "&#123;\"asset_properties\":\"$ASSET_PROPERTIES\"&#125;"</span><br></pre></td></tr></table></figure><p>验证通过之后，就对资产出价：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PRICE=$(echo -n "&#123;\"asset_id\":\"asset0101\",\"trade_id\":\"93b46869be90a6b1f688357965f89b5a8a5e32bf13710fb4ad00e25cca0f0b14\",\"price\":500&#125;" | base64)</span><br><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"AgreeToBuy","Args":["asset0101"]&#125;' --transient "&#123;\"asset_price\":\"$ASSET_PRICE\"&#125;"</span><br></pre></td></tr></table></figure><p>可以在一级供应商的隐私数据集中查询到出价信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetBidPrice","Args":["asset0101"]&#125;'</span><br></pre></td></tr></table></figure><p><strong>如果在其他组织上查询，会看到如下错误，说明出价卖出设置的价格信息是隐秘的：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: endorsement failure during query. response: status:500 message:"asset price does not exist: asset001"</span><br></pre></td></tr></table></figure><h4 id="核心企业把资产转移给一级供应商-v2">核心企业把资产转移给一级供应商</h4><p>核心企业和一级供应商对相同的价格达成共识之后，核心企业就可以把资产转移给一级供应商了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply --peerAddresses localhost:8051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/core.supply.com/peers/peer0.core.supply.com/tls/ca.crt --peerAddresses localhost:8053 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/f1.supply.com/peers/peer0.f1.supply.com/tls/ca.crt -c '&#123;"function":"TransferAsset","Args":["asset0101","GylFOrg1MSP"]&#125;' --transient "&#123;\"asset_properties\":\"$ASSET_PROPERTIES\",\"asset_price\":\"$ASSET_PRICE\"&#125;"</span><br></pre></td></tr></table></figure><p>查询公共数据的资产归属以验证交易成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ReadAsset","Args":["asset0101"]&#125;'|jq</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset0101"</span>,</span><br><span class="line">  <span class="attr">"ownerOrg"</span>: <span class="string">"GylFOrg1MSP"</span>,</span><br><span class="line">  <span class="attr">"publicDescription"</span>: <span class="string">"A new asset for GylCoreOrg1MSP"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"enable"</span>,</span><br><span class="line">  <span class="attr">"parentID"</span>: <span class="string">"asset010"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交易验证-v2">交易验证</h3><p>除了交易双方其他人无法查看到资产详情</p><h5 id="验证一级供应商可以修改自己的资产的公共属性：-v2">验证一级供应商可以修改自己的资产的公共属性：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ChangePublicDescription","Args":["asset0101","This asset is not for sale now"]&#125;'</span><br></pre></td></tr></table></figure><p>修改成功之后重新查询资产的公共信息，验证通过：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset0101"</span>,</span><br><span class="line">  <span class="attr">"ownerOrg"</span>: <span class="string">"GylFOrg1MSP"</span>,</span><br><span class="line">  <span class="attr">"publicDescription"</span>: <span class="string">"This asset is not for sale now"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"enable"</span>,</span><br><span class="line">  <span class="attr">"parentID"</span>: <span class="string">"asset010"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="验证核心企业不可以再修改这个资产的公共信息-v2">验证核心企业不可以再修改这个资产的公共信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ChangePublicDescription","Args":["asset0101","This asset is not for sale again"]&#125;'</span><br></pre></td></tr></table></figure><p>结果报错如下，符合预期：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: endorsement failure during invoke. response: status:500 message:"a client from GylCoreOrg1MSP cannot update the description of a asset owned by GylFOrg1MSP"</span><br></pre></td></tr></table></figure><h5 id="验证只有一级供应商才可以查询这个资产的私有信息-v2">验证只有一级供应商才可以查询这个资产的私有信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetPrivateProperties","Args":["asset0101"]&#125;'</span><br></pre></td></tr></table></figure><p>结果如下，验证通过：</p><p>在一级供应商的peer节点可以查询到资产的私有属性，其他组织的peer节点都报错：<code>Error: endorsement failure during query. response: status:500 message:&quot;asset private details does not exist in client org's collection: asset005&quot;</code></p><h2 id="一级供应商与二级供应商交易">一级供应商与二级供应商交易</h2><p>调用拆分的方法，将资产拆分成200和300：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"SplitAsset","Args":["asset0101", "200"]&#125;'</span><br></pre></td></tr></table></figure><h3 id="验证拆分结果-v2">验证拆分结果</h3><h4 id="私有数据验证-v2">私有数据验证</h4><h5 id="第一个资产：-v3">第一个资产：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetPrivateProperties","Args":["asset01011"]&#125;'|jq</span><br></pre></td></tr></table></figure><h5 id="第二个资产：-v3">第二个资产：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetPrivateProperties","Args":["asset01012"]&#125;'|jq</span><br></pre></td></tr></table></figure><h5 id="原始的资产，原始资产已经没有了：">原始的资产，原始资产已经没有了：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetPrivateProperties","Args":["asset0101"]&#125;'|jq</span><br></pre></td></tr></table></figure><h4 id="公共数据验证-v2">公共数据验证</h4><h5 id="第一个资产：-v4">第一个资产：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ReadAsset","Args":["asset01011"]&#125;'|jq</span><br></pre></td></tr></table></figure><h5 id="第二个资产：-v4">第二个资产：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ReadAsset","Args":["asset01012"]&#125;'|jq</span><br></pre></td></tr></table></figure><h5 id="原始的资产，拆分资产之后原始资产的状态应该改变：">原始的资产，拆分资产之后原始资产的状态应该改变：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ReadAsset","Args":["asset0101"]&#125;'|jq</span><br></pre></td></tr></table></figure><h2 id="拆分后的资产交易-v2">拆分后的资产交易</h2><h4 id="一级供应商允许出售资产，设置价格：">一级供应商允许出售资产，设置价格：</h4><p>下面的trade_id是合同的hash值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PRICE=$(echo -n "&#123;\"asset_id\":\"asset01012\",\"trade_id\":\"f46555b7ddd1f8dd232bdc0dcbc5b1f34bdf1d4bb7c123a79a6ed628175f29bb\",\"price\":300&#125;" | base64)</span><br><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"AgreeToSell","Args":["asset01012"]&#125;' --transient "&#123;\"asset_price\":\"$ASSET_PRICE\"&#125;"</span><br></pre></td></tr></table></figure><p>查询核心企业的私有数据集合来读取同意的销售价格：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetSalesPrice","Args":["asset01012"]&#125;'</span><br></pre></td></tr></table></figure><h5 id="二级供应商2出价300">二级供应商2出价300</h5><p>在二级供应商2出价之前，他需要先验证资产的信息是否正确。此链码中返回true即为正确。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PROPERTIES=$(echo -n "&#123;\"objectType\":\"asset_properties\",\"assetID\":\"asset01012\",\"issuer\":\"GylCoreOrg1MSP\",\"amount\":300,\"createDate\":\"2020-01-11T06:57:06.963617Z\",\"endDate\":\"2021-07-11T06:57:06.963617Z\",\"salt\":\"224cba6c547aecc76ab6acfac41d12dfd96e7165\"&#125;" | base64 | tr -d \\n)</span><br><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"VerifyAssetProperties","Args":["asset01012"]&#125;' --transient "&#123;\"asset_properties\":\"$ASSET_PROPERTIES\"&#125;"</span><br></pre></td></tr></table></figure><p>验证通过之后，就对资产出价：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PRICE=$(echo -n "&#123;\"asset_id\":\"asset01012\",\"trade_id\":\"f46555b7ddd1f8dd232bdc0dcbc5b1f34bdf1d4bb7c123a79a6ed628175f29bb\",\"price\":300&#125;" | base64)</span><br><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"AgreeToBuy","Args":["asset01012"]&#125;' --transient "&#123;\"asset_price\":\"$ASSET_PRICE\"&#125;"</span><br></pre></td></tr></table></figure><p>可以在一级供应商的隐私数据集中查询到出价信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetBidPrice","Args":["asset01012"]&#125;'</span><br></pre></td></tr></table></figure><p><strong>如果在其他组织上查询，会看到如下错误，说明出价卖出设置的价格信息是隐秘的：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: endorsement failure during query. response: status:500 message:"asset price does not exist: asset001"</span><br></pre></td></tr></table></figure><h4 id="一级供应商把资产转移给二级供应商2">一级供应商把资产转移给二级供应商2</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply --peerAddresses localhost:8053 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/f1.supply.com/peers/peer0.f1.supply.com/tls/ca.crt --peerAddresses localhost:8151 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/s2.supply.com/peers/peer0.s2.supply.com/tls/ca.crt -c '&#123;"function":"TransferAsset","Args":["asset01012","GylSOrg2MSP"]&#125;' --transient "&#123;\"asset_properties\":\"$ASSET_PROPERTIES\",\"asset_price\":\"$ASSET_PRICE\"&#125;"</span><br></pre></td></tr></table></figure><p>查询公共数据的资产归属以验证交易成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ReadAsset","Args":["asset01012"]&#125;'|jq</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset01012"</span>,</span><br><span class="line">  <span class="attr">"ownerOrg"</span>: <span class="string">"GylSOrg2MSP"</span>,</span><br><span class="line">  <span class="attr">"publicDescription"</span>: <span class="string">"This asset is not for sale now"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"enable"</span>,</span><br><span class="line">  <span class="attr">"parentID"</span>: <span class="string">"asset0101"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交易验证-v3">交易验证</h3><p>除了交易双方其他人无法查看到资产详情</p><h5 id="验证二级级供应商2可以修改自己的资产的公共属性：">验证二级级供应商2可以修改自己的资产的公共属性：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ChangePublicDescription","Args":["asset01012","hello i am GylSOrg2MSP"]&#125;'</span><br></pre></td></tr></table></figure><p>修改成功之后重新查询资产的公共信息，验证通过：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset01012"</span>,</span><br><span class="line">  <span class="attr">"ownerOrg"</span>: <span class="string">"GylSOrg2MSP"</span>,</span><br><span class="line">  <span class="attr">"publicDescription"</span>: <span class="string">"hello i am GylSOrg2MSP"</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"enable"</span>,</span><br><span class="line">  <span class="attr">"parentID"</span>: <span class="string">"asset0101"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="验证只有二级级供应商2才可以查询这个资产的私有信息">验证只有二级级供应商2才可以查询这个资产的私有信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetPrivateProperties","Args":["asset01012"]&#125;'</span><br></pre></td></tr></table></figure><p>结果如下，验证通过：</p><p>在一级供应商的peer节点可以查询到资产的私有属性，其他组织的peer节点都报错：<code>Error: endorsement failure during query. response: status:500 message:&quot;asset private details does not exist in client org's collection: asset005&quot;</code></p><h2 id="chaincode接口记录">chaincode接口记录</h2><h3 id="查询卖出的交易信息">查询卖出的交易信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"QueryAssetSaleAgreements","Args":[]&#125;'</span><br></pre></td></tr></table></figure><h3 id="查询资产的公共信息">查询资产的公共信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"ReadAsset","Args":["asset01012"]&#125;'|jq</span><br></pre></td></tr></table></figure><h3 id="查询私有资产信息">查询私有资产信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"GetAssetPrivateProperties","Args":["asset01012"]&#125;'|jq</span><br></pre></td></tr></table></figure><h3 id="查询一个资产公共信息的历史数据">查询一个资产公共信息的历史数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:8050 --ordererTLSHostnameOverride orderer.supply.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/supply.com/orderers/orderer.supply.com/msp/tlscacerts/tlsca.supply.com-cert.pem -C alljoinchannel -n secured_supply -c '&#123;"function":"QueryAssetHistory","Args":["asset01012"]&#125;'|jq</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自己开发的智能合约在channel上的所有成员都可以看到，这不符合现实世界中的交易规则。理论上两个组织之间的交易是不允许别人看到的。所以这次我使用fabric-samples提供的&lt;code&gt;asset-transfer-secured-agreement&lt;/code&gt;来作</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    <category term="供应链金融" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/%E4%BE%9B%E5%BA%94%E9%93%BE%E9%87%91%E8%9E%8D/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="peer" scheme="https://guozhe001.github.io/tags/peer/"/>
    
    <category term="供应链金融" scheme="https://guozhe001.github.io/tags/%E4%BE%9B%E5%BA%94%E9%93%BE%E9%87%91%E8%9E%8D/"/>
    
  </entry>
  
  <entry>
    <title>在Fabric中交易受保护的资产</title>
    <link href="https://guozhe001.github.io/2020/12/31/blockchain/fabric/%E5%9C%A8Fabric%E4%B8%AD%E4%BA%A4%E6%98%93%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E8%B5%84%E4%BA%A7/"/>
    <id>https://guozhe001.github.io/2020/12/31/blockchain/fabric/%E5%9C%A8Fabric%E4%B8%AD%E4%BA%A4%E6%98%93%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E8%B5%84%E4%BA%A7/</id>
    <published>2020-12-31T07:00:21.116Z</published>
    <updated>2021-01-11T10:13:11.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Fabric中交易受保护的资产">在Fabric中交易受保护的资产</h1><p>官方文档：<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/secured_asset_transfer/secured_private_asset_transfer_tutorial.html" target="_blank" rel="noopener">Secured asset transfer in Fabric</a></p><p>This tutorial will demonstrate how an asset can be represented and traded between organizations in a Hyperledger Fabric blockchain channel, while keeping details of the asset and transaction private using private data. Each on-chain asset is a non-fungible token (NFT) that represents a specific asset having certain immutable metadata properties (such as size and color) with a unique owner. When the owner wants to sell the asset, both parties need to agree to the same price before the asset is transferred. The private asset transfer smart contract enforces that only the owner of the asset can transfer the asset. In the course of this tutorial, you will learn how Fabric features such as state based endorsement, private data, and access control come together to provide secured transactions that are both private and verifiable.</p><p>本文档会演示如何在Hyperledger Fabric区块链的通道中的组织之间表示和交易资产，同时保持资产和交易的私有性。链上的每个资产都是一个NFT（non-fungible token，不可替代令牌），这个NFT代表具有唯一拥有者、具有某些不变的元数据属性（例如大小和颜色）的特定资产。当所有者想要出售资产时，双方需要在转让资产之前达成一致的价格。私有资产转让智能合约强制规定只有资产所有者才能转让资产。在本教程的过程中，您将学习如何把Fabric的特性（如基于状态的背书、私有数据和访问控制）组合在一起，以提供私有且可验证的安全交易。</p><p>This tutorial will deploy the <a href="https://github.com/hyperledger/fabric-samples/tree/master/asset-transfer-secured-agreement/chaincode-go" target="_blank" rel="noopener">secured asset transfer sample</a> to demonstrate how to transfer a private asset between two organizations without publicly sharing data. You should have completed the task <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/secured_asset_transfer/install.html#install-samples-binaries-and-docker-images" target="_blank" rel="noopener">Install Samples, Binaries, and Docker Images</a>.</p><p>本教程会部署 <a href="https://github.com/hyperledger/fabric-samples/tree/master/asset-transfer-secured-agreement/chaincode-go" target="_blank" rel="noopener">secured asset transfer sample</a> 来演示如何在两个组织之间转移私有资产而不公开共享数据。</p><h2 id="Scenario-requirements（方案要求）">Scenario requirements（方案要求）</h2><p>The private asset transfer scenario is bound by the following requirements:</p><ul><li>An asset may be issued by the first owner’s organization (in the real world issuance may be restricted to some authority that certifies an asset’s properties).</li><li>Ownership is managed at the organization level (the Fabric permissioning scheme would equally support ownership at an individual identity level within an organization).</li><li>The asset identifier and owner is stored as public channel data for all channel members to see.</li><li>The asset metadata properties however are private information known only to the asset owner (and prior owners).</li><li>An interested buyer will want to verify an asset’s private properties.</li><li>An interested buyer will want to verify an asset’s provenance, specifically the asset’s origin and chain of custody. They will also want to verify that the asset has not changed since issuance, and that all prior transfers have been legitimate.</li><li>To transfer an asset, a buyer and seller must first agree on the sales price.</li><li>Only the current owner may transfer their asset to another organization.</li><li>The actual private asset transfer must verify that the legitimate asset is being transferred, and verify that the price has been agreed to. Both buyer and seller must endorse the transfer.</li></ul><p>私有资产交易方案受以下要求约束：</p><ul><li>一个资产可能由第一个拥有者的组织发行（在现实世界中，可能只能由某个权威的可以证明资产属性的组织来发行）。</li><li>所有权是在组织级别进行管理的（Fabric许可方案将同样支持组织内个人身份级别的所有权）。</li><li>资产的ID和所有人作为可以被channel上的所有成员可见的公共数据被存储。</li><li>但是资产的元数据作为私有信息，只能被资产的所有者看到（也包括前所有者）。</li><li>有兴趣的买家将希望验证资产的私有属性。</li><li>有兴趣的买家将希望验证资产的出处，特别是资产的来源和产销监管链。他们还希望验证资产自从发行之后没有被篡改过，并且这个资产的前面的所有交易都是合法的。</li><li>在资产交易之前，买卖双方必须对资产的价格达成一致。</li><li>只有当前拥有者可以把他们的资产转让给另一个组织。</li><li>实际的私有资产交易必须确认合法资产正在转让，并确认双方已经对价格达成一致。买卖双方都必须对交易进行背书。</li></ul><h2 id="How-privacy-is-maintained（如何保持隐私性）">How privacy is maintained（如何保持隐私性）</h2><p>The smart contract uses the following techniques to ensure that the asset properties remain private:</p><ul><li>The asset metadata properties are stored in the current owning organization’s implicit private data collection on the organization’s peers only. Each organization on a Fabric channel has a private data collection that their own organization can use. This collection is <em>implicit</em> because it does not need to be explicitly defined in the chaincode.</li><li>Although a hash of the private properties is automatically stored on-chain for all channel members to see, a random salt is included in the private properties so that other channel members cannot guess the private data pre-image through a dictionary attack.</li><li>Smart contract requests utilize the transient field for private data so that private data does not get included in the final on-chain transaction.</li><li>Private data queries must originate from a client whose org id matches the peer’s org id, which must be the same as the asset owner’s org id.</li></ul><p>智能合约使用以下技术来确保资产属性保持隐私：</p><ul><li>资产元数据属性仅存储在当前拥有组织的节点的隐式私有数据集合中。每个组织在Fabric通道上都有一个只能由组织自己可以使用的私有数据集合。该集合是隐式的，因为不需要在链码中显式定义它。</li><li>虽然私有属性的hash值被自动保存在链上然后通道上所有成员都可以看到，但是私有属性中包含随机盐，因此其他的通道成员无法通过字典攻击猜测私有数据原像。</li><li>智能合约请求将瞬态字段用于私有数据，因此私有数据不会包含在最终的链上交易中。</li><li>对私有数据的查询必须来自组织ID与peer的组织ID一致的客户端，并且该客户端的ID必须与资产所有者的组织ID相同。</li></ul><h2 id="How-the-transfer-is-implemented（交易是如何实施的）">How the transfer is implemented（交易是如何实施的）</h2><p>Before we start using the private asset transfer smart contract we will provide an overview of the transaction flow and how Fabric features are used to protect the asset created on the blockchain:</p><p>在我们开始使用私有资产交易的智能合约之前，我们将概述交易流程以及如何使用Fabric功能来保护在区块链上创建的资产：</p><h3 id="Creating-the-asset（创建资产）">Creating the asset（创建资产）</h3><p>The private asset transfer smart contract is deployed with an endorsement policy that requires an endorsement from any channel member. This allows any organization to create an asset that they own without requiring an endorsement from other channel members. The creation of the asset is the only transaction that uses the chaincode level endorsement policy. Transactions that update or transfer existing assets will be governed by state based endorsement policies or the endorsement policies of private data collections. Note that in other scenarios, you may want an issuing authority to also endorse create transactions.</p><p>私有资产交易智能合约在部署时有一个背书策略，这个背书策略是：不需要任何渠道成员的认可。这样任何组织都可以创建属于他们自己的资产，而不需要其他的通道成员批准。资产的创建是唯一使用链码级背书策略的交易。更新或交易现有资产的交易将受基于状态认可政策或私有数据集合认可政策的约束。注意在其他情况下，你可能想要一个发行机构也认可创建交易。</p><p>The smart contract uses the following Fabric features to ensure that the asset can only be updated or transferred by the organization that owns the asset:</p><ul><li>When the asset is created, the smart contract gets the MSP ID of the organization that submitted the request, and stores the MSP ID as the owner in the asset key/value in the public chaincode world state. Subsequent smart contract requests to update or transfer the asset will use access control logic to verify that the requesting client is from the same organization. Note that in other scenarios, the ownership could be based on a specific client identity within an organization, rather than an organization itself.</li><li>Also when the asset is created, the smart contract sets a state based endorsement policy for the asset key. The state based policy specifies that a peer from the organization that owns the asset must endorse a subsequent request to update or transfer the asset. This prevents any other organization from updating or transferring the asset using a smart contract that has been maliciously altered on their own peers.</li></ul><p>智能合约使用以下的Fabric功能来确保资产只能由拥有它的组织进行更新和交易：</p><ul><li>在资产创建后，智能合约会获取提交请求的组织的MSP ID ，并且把这个MSP ID作为资产的拥有者存储在公共链码世界状态的key/value中。后续的更新或交易资产的智能合约请求将会使用访问控制逻辑来验证发出请求的客户端来自同一个组织。请注意在其他情况下，所有权可以基于组织内的特定客户端身份，而不是组织本身。</li><li>同样，在创建资产时，智能合约会为资产密钥设置基于状态的背书策略。基于状态的策略指定拥有资产的组织中的peer节点必须认可后续的更新或转让资产的请求。这样可以防止任何其他组织利用恶意更改的智能合约来更改和交易资产。</li></ul><h3 id="Agreeing-to-the-transfer（同意交易）">Agreeing to the transfer（同意交易）</h3><p>After a asset is created, channel members can use the smart contract to agree to transfer the asset:</p><ul><li>The owner of the asset can change the description in the public ownership record, for example to advertise that the asset is for sale. Smart contract access control enforces that this change needs to be submitted from a member of the asset owner organization. The state based endorsement policy enforces that this description change must be endorsed by a peer from the owner’s organization.</li></ul><p>在资产创建之后，通道上的成员可以使用智能合约来同意交易资产：</p><ul><li>资产的拥有者可以更改公共记录上的描述，例如广告说这个资产要卖出。智能合约访问控制强制要求此更改需要从拥有此资产的组织的成员提交。基于状态的背书策略规定，此描述更改必须得到拥有资产的组织的成员确认。</li></ul><p>The asset owner and the asset buyer agree to transfer the asset for a certain price:</p><ul><li>The price agreed to by the buyer and the seller is stored in each organization’s implicit private data collection. The private data collection keeps the agreed price secret from other members of the channel. The endorsement policy of the private data collection ensures that the respective organization’s peer endorsed the price agreement, and the smart contract access control logic ensures that the price agreement was submitted by a client of the associated organization.</li><li>A hash of each price agreement is stored on the ledger. The two hashes will match only if the two organizations have agreed to the same price. This allows the organizations to verify that they have come to agreement on the transfer details before the transfer takes place. A random trade id is added to the price agreement, which serves as a <em>salt</em> to ensure that other channel members can not use the hash on the ledger to guess the price.</li></ul><p>资产所有者和资产购买者同意以一定价格交易资产：</p><ul><li>买卖双方都同意的价格被存储在他们各自的隐式私有数据集合中。私有数据集合保证成交价格对通道上的其他成员来说是私密的。私有数据集合背书策略确保各自组织的peer节点对价格达成了一致，智能合约访问控制逻辑确保价格协议是由与组织有关联的客户端提交的。</li><li>交易双方生成的价格协议的hash值被存储在了账本上。只有在两个组织同意同一个价格时，这两个hash值才会匹配。这使组织能够在转移发生之前验证他们已就转移细节达成协议。价格协议中添加了随机交易ID，这是确保通道其他成员不能使用账本上的哈希值来猜测价格的一种盐。</li></ul><h3 id="Transferring-the-asset（交易资产）">Transferring the asset（交易资产）</h3><p>After the two organizations have agreed to the same price, the asset owner can use the transfer function to transfer the asset to the buyer:</p><ul><li>Smart contract access control ensures that the transfer must be initiated by a member of the organization that owns the asset.</li><li>The transfer function verifies that the asset’s private immutable properties passed to the transfer function matches the on chain hash of the asset data in private collection, to ensure that the asset owner is <em>selling</em> the same asset that they own.</li><li>The transfer function uses the hash of the price agreement on the ledger to ensure that both organizations have agreed to the same price.</li><li>If the transfer conditions are met, the transfer function adds the asset to the implicit private data collection of the buyer, and deletes the asset from the collection of the seller. The transfer also updates the owner in the public ownership record.</li><li>Because of the endorsement policies of the seller and buyer implicit data collections, and the state based endorsement policy of the public record (requiring the seller to endorse), the transfer needs to be endorsed by peers from both buyer and seller.</li><li>The state based endorsement policy of the public asset record is updated so that only a peer of the new owner of the asset can update or sell their new asset.</li><li>The price agreements are also deleted from both the seller and buyer implicit private data collection, and a sales receipt is created in each private data collection.</li></ul><p>在两个组织已经对相同的价格达成一致之后，资产的拥有者可以使用转让方法来把资产转让给买方：</p><ul><li>智能合约访问控制确保转账必须由拥有资产的组织的成员来发起</li><li>转账方法验证传递给它的资产的私有不可变属性是否与私有集合中资产数据的链上哈希匹配，确保资产所有者在出售他们拥有的相同的资产。</li><li>转账方法使用账本上的价格协议的hash值来确保两个组织已经同意了相同的价格。</li><li>如果满足转让条件，则转账函数会将资产添加到买方的隐式私有数据集合中，并且从卖方的集合中删除这个资产。转让还会更新公共所有权记录中的资产的所有者。</li><li>因为买卖双方隐式数据集合的背书策略和公共数据的基于状态的背书策略（要求卖方确认），所以交易需要得到买卖双方节点的认可。</li><li>公共资产记录的基于状态的背书策略需要更新，这样只有新的所有者的peer节点才能够更新和出售他们的新资产。</li><li>价格协议也从买卖双方隐式私人数据集合中删除，并且在每个私人数据集合中创建销售收据。</li></ul><h2 id="Running-the-private-asset-transfer-smart-contract（运行私有资产转账智能合约）">Running the private asset transfer smart contract（运行私有资产转账智能合约）</h2><p>You can use the Fabric test network to run the private asset transfer smart contract. The test network contains two peer organizations, Org1 and Org1, that operate one peer each. In this tutorial, we will deploy the smart contract to a channel of the test network joined by both organizations. We will first create an asset that is owned by Org1. After the two organizations agree on the price, we will transfer the asset from Org1 to Org2.</p><p>我们可以使用Fabric的test网络来运行私有资产转账智能合约。（省略。。。）我们先通过Org1组织创建一个资产，在两个组织对价格达成一致之后，我们把资产由Org1组织交易到Org2组织。</p><h2 id="Deploy-the-test-network（部署测试网络）">Deploy the test network（部署测试网络）</h2><p>请参考：<a href="https://guozhe001.github.io/2020/12/18/blockchain/fabric/Fabric%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8/">Fabric测试网络使用</a></p><h2 id="Deploy-the-smart-contract-部署智能合约">Deploy the smart contract(部署智能合约)</h2><p>You can use the test network script to deploy the secured asset transfer smart contract to the channel. Run the following command to deploy the smart contract to <code>mychannel</code>:</p><p>你可以使用测试网络脚本来部署安全资产交易智能合约到通道上。运行下面的命令来部署智能合约到<code>mychannel</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;network.sh deployCC -ccn secured -ccp ..&#x2F;asset-transfer-secured-agreement&#x2F;chaincode-go&#x2F; -ccl go -ccep &quot;OR(&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;</span><br></pre></td></tr></table></figure><p>Note that we are using the <code>-ccep</code> flag to deploy the smart contract with an endorsement policy of <code>&quot;OR('Org1MSP.peer','Org2MSP.peer')&quot;</code>. This allows either organization to create an asset without receiving an endorsement from the other organization.</p><p>注意我们使用<code>-ccep</code>标志来部署智能合约，这个智能合约有一个背书策略<code>&quot;OR('Org1MSP.peer','Org2MSP.peer')&quot;</code>。者允许任意一个组织在创建一个新的资产时不需要其他组织的确认。</p><h3 id="Set-the-environment-variables-to-operate-as-Org2（设置环境变量以Org2的管理员身份操作）">Set the environment variables to operate as Org2（设置环境变量以Org2的管理员身份操作）</h3><p>略，可以使用两个终端分别以Org1和Org2组织管理员的身份操作peer。环境变量设置参考：[Fabric测试网络使用](<a href="https://guozhe001.github.io/2020/12/18/blockchain/fabric/Fabric%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8/">https://guozhe001.github.io/2020/12/18/blockchain/fabric/Fabric测试网络使用/</a></p><p>[)</p><h2 id="Create-an-asset（创建一个资产）">Create an asset（创建一个资产）</h2><p>Any channel member can use the smart contract to create an asset that is owned by their organization. The details of the asset will be stored in a private data collection, and can only accessed by the organization that owns the asset. A public record of the asset, its owner, and a public description is stored on the channel ledger. Any channel member can access the public ownership record to see who owns the asset, and can read the description to see if the asset is for sale.</p><p>任何一个通道成员都可以使用这个智能合约来创建一个属于组织自己的资产。资产的详情会存储在私有数据集合中，并且只能由拥有资产的组织访问。资产，其所有者和公共描述的公共记录存储在通道账本中。任何通道成员都可以访问公共记录来查看谁拥有这个资产，并且可以查看描述来判断资产是否在出售。</p><h3 id="Operate-from-the-Org1-terminal（通过Org1的终端操作）">Operate from the Org1 terminal（通过Org1的终端操作）</h3><p>Before we create the asset, we need to specify the details of what our asset will be. Issue the following command to create a JSON that will describe the asset. The <code>&quot;salt&quot;</code> parameter is a random string that would prevent another member of the channel from guessing the asset using the hash on the ledger. If there was no salt, a user could theoretically guess asset parameters until the hash of the of the guess and the hash on the ledger matched (this is known as a dictionary attack). This string is encoded in Base64 format so that it can be passed to the creation transaction as transient data.</p><p>在创建资产之前，我们需要指定资产的详细信息。通过下面的命令来创建一个JSON来描述资产。<code>&quot;salt&quot;</code>参数是一个随机字符串来防止通道上的另一个成员通过账本上的hash值来猜测这个资产。如果没有盐，理论上用户可以猜测资产参数，直到猜测的哈希值和账本的哈希值匹配（这称为字典攻击）为止。该字符串以Base64格式编码，因此可以作为临时数据传递给创建交易。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PROPERTIES=$(echo -n "&#123;\"object_type\":\"asset_properties\",\"asset_id\":\"asset1\",\"color\":\"blue\",\"size\":35,\"salt\":\"a94a8fe5ccb19ba61c4c0873d391e987982fbbd3\"&#125;" | base64 | tr -d \\n)</span><br></pre></td></tr></table></figure><p>We can now use the following command to create a asset that belongs to Org1:</p><p>我们现在可以使用下面的命令来创建一个属于Org1组织的资产：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"CreateAsset","Args":["asset1", "A new asset for Org1MSP"]&#125;' --transient "&#123;\"asset_properties\":\"$ASSET_PROPERTIES\"&#125;"</span><br></pre></td></tr></table></figure><p>We can can query the Org1 implicit data collection to see the asset that was created:</p><p>我们可以查询Org1组织的隐私数据集合来查看创建的资产：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"GetAssetPrivateProperties","Args":["asset1"]&#125;'</span><br></pre></td></tr></table></figure><p>When successful, the command will return the following result:</p><p>如果成功，命令会返回下面的结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"object_type"</span>: <span class="string">"asset_properties"</span>,</span><br><span class="line">  <span class="attr">"asset_id"</span>: <span class="string">"asset1"</span>,</span><br><span class="line">  <span class="attr">"color"</span>: <span class="string">"blue"</span>,</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">35</span>,</span><br><span class="line">  <span class="attr">"salt"</span>: <span class="string">"a94a8fe5ccb19ba61c4c0873d391e987982fbbd3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can also query the ledger to see the public ownership record:</p><p>我们还可以查询账本来查看公共记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"ReadAsset","Args":["asset1"]&#125;'</span><br></pre></td></tr></table></figure><p>The command will return the record that the asset1 is owned by Org1:</p><p>这个命令会返回数据说明资产asset1属于Org1：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset1"</span>,</span><br><span class="line">  <span class="attr">"ownerOrg"</span>: <span class="string">"Org1MSP"</span>,</span><br><span class="line">  <span class="attr">"publicDescription"</span>: <span class="string">"A new asset for Org1MSP"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Because the market for assets is hot, Org1 wants to flip this asset and put it up for sale. As the asset owner, Org1 can update the public description to advertise that the asset is for sale. Run the following command to change the asset description:</p><p>因为资产市场很热，所以Org1希望翻转该资产并将其出售。作为资产的拥有者，Org1组织可以更新公共描述来广告说资产在出售。运行下面的命令来更新资产描述：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"ChangePublicDescription","Args":["asset1","This asset is for sale"]&#125;'</span><br></pre></td></tr></table></figure><p>Query the ledger again to see the updated description:</p><p>重新查询账本来查看更新后的描述：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"ReadAsset","Args":["asset1"]&#125;'</span><br></pre></td></tr></table></figure><p>We can now see that the asset is for sale:</p><p>我们现在可以看到这个资产在出售：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset1"</span>,</span><br><span class="line">  <span class="attr">"ownerOrg"</span>: <span class="string">"Org1MSP"</span>,</span><br><span class="line">  <span class="attr">"publicDescription"</span>: <span class="string">"This asset is for sale"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/transfer_assets_1.png" alt="transfer_assets_1"></p><p><em>Figure 1: When Org1 creates an asset that they own, the asset details are stored in the Org1 implicit data collection on the Org1 peer. The public ownership record is stored in the channel world state, and is stored on both the Org1 and Org2 peers. A hash of the asset key and a hash the asset details are also visible in the channel world state and are stored on the peers of both organizations.</em></p><p><em>图片1:当组织Org1创建了一个属于他们的资产时，资产的细节保存在属于组织Org1的peer的隐式数据集合中。公共的记录被保存在通道的世界状态，并且保存在组织Org1和Org2的peer节点。资产的key的hash和资产详情的hash在通道的世界状态是可访问的，并且存储在所有组织的peer节点。</em></p><h3 id="Operate-from-the-Org2-terminal（通过组织Org2的终端操作）">Operate from the Org2 terminal（通过组织Org2的终端操作）</h3><p>If we operate from the Org2 terminal, we can use the smart contract query the public asset data:</p><p>如果我们通过组织Org2的终端操作，我们可以使用智能合约来查询公共的资产数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"ReadAsset","Args":["asset1"]&#125;'</span><br></pre></td></tr></table></figure><p>From this query, Org2 learns that asset1 is for sale（通过这个查询，组织Org2知道了资产asset1正在出售）:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset1"</span>,</span><br><span class="line">  <span class="attr">"ownerOrg"</span>: <span class="string">"Org1MSP"</span>,</span><br><span class="line">  <span class="attr">"publicDescription"</span>: <span class="string">"This asset is for sale"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>In a real chaincode you may want to query for all assets for sale, by using a JSON query, or by creating a different sale key and using a key range query to find the assets currently for sale.</em> Any changes to the public description of the asset owned by Org1 needs to be endorsed by Org1. The endorsement policy is reinforced by an access control policy within the chaincode that any update needs to be submitted by the organization that owns the asset. Lets see what happens if Org2 tried to change the public description as a prank:</p><p>*在真实的链码中，您可能希望通过使用JSON查询或通过创建其他销售密钥并使用密钥的范围来查找当前待售资产，以查询所有待售资产。*所有属于组织Org1的资产的公共描述在进行任何更改时都必须得到组织Org1的认可。链码中的访问控制策略加强了背书策略，任何更新都必须由来自于资产拥有者的组织来提交。让我们看看如果Org2试图以恶作剧方式更改公共描述会发生什么：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"ChangePublicDescription","Args":["asset1","the worst asset"]&#125;'</span><br></pre></td></tr></table></figure><p>The smart contract does not allow Org2 to access the public description of the asset.</p><p>智能合约不允许组织Org2访问这个资产的公共描述。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: endorsement failure during invoke. response: status:500 message:"a client from Org2MSP cannot update the description of a asset owned by Org1MSP"</span><br></pre></td></tr></table></figure><h2 id="Agree-to-sell-the-asset-允许出售资产">Agree to sell the asset(允许出售资产)</h2><p>To sell an asset, both the buyer and the seller must agree on an asset price. Each party stores the price that they agree to in their own private data collection. The private asset transfer smart contract enforces that both parties need to agree to the same price before the asset can be transferred.</p><p>为了出售资产。买卖双方都必须同意相同的资产价格。每一方都需要在他们的私有数据集合中保存他们同意的价格。私有资产交易智能合约强制双方必须同意相同的价格才能转让资产。</p><h2 id="Agree-to-sell-as-Org1（以Org1的身份同意出售）">Agree to sell as Org1（以Org1的身份同意出售）</h2><p>Operate from the Org1 terminal. Org1 will agree to set the asset price as 110 dollars. The <code>trade_id</code> is used as salt to prevent a channel member that is not a buyer or a seller from guessing the price. This value needs to be passed out of band, through email or other communication, between the buyer and the seller. The buyer and the seller can also add salt to the asset key to prevent other members of the channel from guessing which asset is for sale.</p><p>通过组织Org1的终端进行操作。Org1同意将资产价格设置为110美元。trade_id用作盐以防止不是买家或卖家的通道成员猜测价格。这个价格需要通过买卖双方之间以电子邮件或其他通信方式在账本外传递。买卖双方还可以对资产的key进行“加盐”，以防止渠道的其他成员猜测要出售的资产。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PRICE=$(echo -n "&#123;\"asset_id\":\"asset1\",\"trade_id\":\"109f4b3c50d7b0df729d299bc6f8e9ef9066971f\",\"price\":110&#125;" | base64)</span><br><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"AgreeToSell","Args":["asset1"]&#125;' --transient "&#123;\"asset_price\":\"$ASSET_PRICE\"&#125;"</span><br></pre></td></tr></table></figure><p>We can query the Org1 private data collection to read the agreed to selling price:</p><p>我们可以查询组织Org1的私有数据集合来读取同意的销售价格：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"GetAssetSalesPrice","Args":["asset1"]&#125;'</span><br></pre></td></tr></table></figure><h2 id="Agree-to-buy-as-Org2-以Org2的身份同意购买">Agree to buy as Org2(以Org2的身份同意购买)</h2><p>Operate from the Org2 terminal. Run the following command to verify the asset properties before agreeing to buy. The asset properties and salt would be passed out of band, through email or other communication, between the buyer and seller.</p><p>通过Org2的终端操作。运行下面的命令在同意购买之前验证资产的属性。资产的属性和盐会在区块链账本外在买卖双方之间通过邮件或者其他方式进行传递。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PROPERTIES=$(echo -n "&#123;\"object_type\":\"asset_properties\",\"asset_id\":\"asset1\",\"color\":\"blue\",\"size\":35,\"salt\":\"a94a8fe5ccb19ba61c4c0873d391e987982fbbd3\"&#125;" | base64)</span><br><span class="line">peer chaincode query -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"VerifyAssetProperties","Args":["asset1"]&#125;' --transient "&#123;\"asset_properties\":\"$ASSET_PROPERTIES\"&#125;"</span><br></pre></td></tr></table></figure><p>Run the following command to agree to buy asset1 for 100 dollars. As of now, Org2 will agree to a different price than Org2. Don’t worry, the two organizations will agree to the same price in a future step. However, we we can use this temporary disagreement as a test of what happens if the buyer and the seller agree to a different price. Org2 needs to use the same <code>trade_id</code> as Org1.</p><p>使用下面的命令来同意以100刀的价格购买asset1。现在Org2同意了一个与Org1不同的价格。不要担心，这两个组织会在接下来的步骤同意相同的价格。但是我们通过临时的分歧来测试如果买方和卖方同意了不同的价格将会发生什么。Org2需要使用与Org1相同的 <code>trade_id</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PRICE=$(echo -n "&#123;\"asset_id\":\"asset1\",\"trade_id\":\"109f4b3c50d7b0df729d299bc6f8e9ef9066971f\",\"price\":100&#125;" | base64)</span><br><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"AgreeToBuy","Args":["asset1"]&#125;' --transient "&#123;\"asset_price\":\"$ASSET_PRICE\"&#125;"</span><br></pre></td></tr></table></figure><p>You can read the agreed purchase price from the Org2 implicit data collection:</p><p>您可以从Org2隐式数据集合中读取约定的购买价格：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"GetAssetBidPrice","Args":["asset1"]&#125;'</span><br></pre></td></tr></table></figure><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/transfer_assets_2.png" alt="transfer_assets_2"></p><p><em>Figure 2: After Org1 and Org2 agree to transfer the asset, the price agreed to by each organization is stored in their private data collections. A composite key for the seller and the buyer is used to prevent a collision with the asset details and asset ownership record. The price that is agreed to is only stored on the peers of each organization. However, the hash of both agreements is stored in the channel world state on every peer joined to the channel.</em></p><p><em>图2:在Org1和Org2同意交易这个资产，每个组织的同意的价格被存储在他们的私有数据集合中。买卖双方的组合键用于防止与资产详细信息和资产所有权记录发生冲突。已经同意的价格只是存储在双方组织的peer节点。但是两个协议的hash值被存储在加入通道的所有peer节点的通道的世界状态中。</em></p><h2 id="Transfer-the-asset-from-Org1-to-Org2（把资产从Org1交易到Org2）">Transfer the asset from Org1 to Org2（把资产从Org1交易到Org2）</h2><p>After both organizations have agreed to their price, Org1 can attempt to transfer the asset to Org2. The private asset transfer function in the smart contract uses the hash on the ledger to check that both organizations have agreed to the same price. The function will also use the hash of the private asset details to check that the asset that is transferred is the same asset that Org1 owns.</p><p>在双方组织都同意了他们的价格之后，Org1可以尝试将资产交易给Org2。在智能合约中的私有资产交易方法使用账本上的hash来检查两个组织是否同意了相同的价格。这个方法也会使用私有资产详情的hash值来检查被交易的资产与属于Org1的资产是同一笔资产。</p><h3 id="Transfer-the-asset-as-Org1（以Org1的身份交易资产）">Transfer the asset as Org1（以Org1的身份交易资产）</h3><p>Operate from the Org1 terminal. The owner of the asset needs to initiate the transfer. Note that the command below uses the <code>--peerAddresses</code> flag to target the peers of both Org1 and Org2. Both organizations need to endorse the transfer. <em>Also note that the asset properties and price are passed in the transfer request as transient properties. These are passed so that the current owner can be sure that the correct asset is transferred for the correct price. These properties will be checked against the on-chain hashes by both endorsers.</em></p><p>通过Org1的终端操作。资产的所有者需要发起这个交易。注意下面的命令使用<code>--peerAddresses</code> 标志来指定Org1和Org2的peer节点。两个组织都需要确认这个交易。<em>另外请注意，资产属性和价格在交易请求中作为临时属性传递。传递这些是为了当前的拥有者可以确保以当前的价格来转让当前的资产。两个背书者将对照链上哈希检查这些属性。</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"TransferAsset","Args":["asset1","Org2MSP"]&#125;' --transient "&#123;\"asset_properties\":\"$ASSET_PROPERTIES\",\"asset_price\":\"$ASSET_PRICE\"&#125;" --peerAddresses localhost:7051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br></pre></td></tr></table></figure><p>Because the two organizations have not agreed to the same price, the transfer cannot be completed:</p><p>因为两个组织同意的价格不一致，这个交易不能完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: endorsement failure during invoke. response: status:500 message:"failed transfer verification: hash 0fc413250501855af7c9896af00993b973510995fb10d56cddbb85ca47bd5dba for passed price JSON &#123;\"asset_id\":\"asset1\",\"trade_id\":\"109f4b3c50d7b0df729d299bc6f8e9ef9066971f\",\"price\":110&#125; does not match on-chain hash 84b0d57eaa5c77076483ae8f482c96a64912c47df5541451e94fb7698bf37ee9, buyer hasn't agreed to the passed trade id and price"</span><br></pre></td></tr></table></figure><p>As a result, Org1 and Org2 come to a new agreement on the price at which the asset will be purchased. Org1 drops the price of the asset to 100:</p><p>结果，Org1和Org2就购买资产的价格达成了新协议。 Org1将资产价格降至100：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ASSET_PRICE=$(echo -n "&#123;\"asset_id\":\"asset1\",\"trade_id\":\"109f4b3c50d7b0df729d299bc6f8e9ef9066971f\",\"price\":100&#125;" | base64)</span><br><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"AgreeToSell","Args":["asset1"]&#125;' --transient "&#123;\"asset_price\":\"$ASSET_PRICE\"&#125;"</span><br></pre></td></tr></table></figure><p>Now that the buyer and seller have agreed to the same price, Org1 can transfer the asset to Org2.</p><p>现在买卖双方已经同意了相同的价格，Org1可以将资产交易给Org2。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"TransferAsset","Args":["asset1","Org2MSP"]&#125;' --transient "&#123;\"asset_properties\":\"$ASSET_PROPERTIES\",\"asset_price\":\"$ASSET_PRICE\"&#125;" --peerAddresses localhost:7051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br></pre></td></tr></table></figure><p>You can query the asset ownership record to verify that the transfer was successful.</p><p>你可以查询资产的归属信息来验证交易已经成功.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"ReadAsset","Args":["asset1"]&#125;'</span><br></pre></td></tr></table></figure><p>The record now lists Org2 as the asset owner:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"objectType"</span>: <span class="string">"asset"</span>,</span><br><span class="line">  <span class="attr">"assetID"</span>: <span class="string">"asset1"</span>,</span><br><span class="line">  <span class="attr">"ownerOrg"</span>: <span class="string">"Org2MSP"</span>,</span><br><span class="line">  <span class="attr">"publicDescription"</span>: <span class="string">"This asset is for sale"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/transfer_assets_3.png" alt="transfer_assets_3"></p><p><em>Figure 3: After the asset is transferred, the asset details are placed in the Org2 implicit data collection and deleted from the Org1 implicit data collection. As a result, the asset details are now only stored on the Org2 peer. The asset ownership record on the ledger is updated to reflect that the asset is owned by Org1.</em></p><p><em>图3:在资产交易之后，资产细节存在于Org2的隐式数据集合并且从Org1的隐式数据集合中被删除。结果，资产的私有信息值保存在Org2的peer节点。在账本上的资产的归属信息也被更新，以反映资产归Org2所有。</em></p><h3 id="Update-the-asset-description-as-Org2（以Org2的身份更新资产描述）">Update the asset description as Org2（以Org2的身份更新资产描述）</h3><p>Operate from the Org2 terminal. Now that Org2 owns the asset, we can read the asset details from the Org2 implicit data collection:</p><p>通过Org2的终端操作，现在Org2拥有这个资产，我们可以通过Org2的隐式数据集合读取资产的详情：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"GetAssetPrivateProperties","Args":["asset1"]&#125;'</span><br></pre></td></tr></table></figure><p>Org2 can now update the asset public description（Org2现在可以更新资产的公共描述）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"ChangePublicDescription","Args":["asset1","This asset is not for sale"]&#125;'</span><br></pre></td></tr></table></figure><p>Query the ledger to verify that the asset is no longer for sale:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n secured -c '&#123;"function":"ReadAsset","Args":["asset1"]&#125;'</span><br></pre></td></tr></table></figure><h2 id="Clean-up">Clean up</h2><p>When you are finished transferring assets, you can bring down the test network. The command will remove all the nodes of the test network, and delete any ledger data that you created:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;network.sh down</span><br></pre></td></tr></table></figure><h2 id="流程图">流程图</h2><p>自己的理解画的流程图如下：</p><p><img src="/2020/12/31/blockchain/fabric/%E5%9C%A8Fabric%E4%B8%AD%E4%BA%A4%E6%98%93%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E8%B5%84%E4%BA%A7/apple/Desktop/%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%98%93%E5%90%88%E7%BA%A6%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="私有数据交易流程图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在Fabric中交易受保护的资产&quot;&gt;在Fabric中交易受保护的资产&lt;/h1&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/release-2.2/secured_asset_tran</summary>
      
    
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger-Fabric/"/>
    
    
    <category term="blockchain" scheme="https://guozhe001.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Hyperledger-Fabric" scheme="https://guozhe001.github.io/tags/Hyperledger-Fabric/"/>
    
    <category term="Secured" scheme="https://guozhe001.github.io/tags/Secured/"/>
    
  </entry>
  
</feed>
