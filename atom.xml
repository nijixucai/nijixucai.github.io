<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>点击积累</title>
  
  <subtitle>每天进步一点点</subtitle>
  <link href="https://nijixucai.github.io/atom.xml" rel="self"/>
  
  <link href="https://nijixucai.github.io/"/>
  <updated>2020-12-23T10:48:44.161Z</updated>
  <id>https://nijixucai.github.io/</id>
  
  <author>
    <name>guozhe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>blockchain/fabric/添加一个新的组织到channel</title>
    <link href="https://nijixucai.github.io/2020/12/23/blockchain/fabric/%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%BB%84%E7%BB%87%E5%88%B0channel/"/>
    <id>https://nijixucai.github.io/2020/12/23/blockchain/fabric/%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%BB%84%E7%BB%87%E5%88%B0channel/</id>
    <published>2020-12-23T09:58:30.091Z</published>
    <updated>2020-12-23T10:48:44.161Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/channel_update_tutorial.html" target="_blank" rel="noopener">官方文档</a></p><h1 id="添加一个新的组织到channel">添加一个新的组织到channel</h1><p>This tutorial extends the Fabric test network by adding a new organization – Org3 – to an application channel.</p><p>本教程通过向应用程序通道添加新组织Org3扩展了Fabric测试网络。</p><p>While we will focus on adding a new organization to the channel, you can use a similar process to make other channel configuration updates (updating modification policies or altering batch size, for example). To learn more about the process and possibilities of channel config updates in general, check out <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html" target="_blank" rel="noopener">Updating a channel configuration</a>). It’s also worth noting that channel configuration updates like the one demonstrated here will usually be the responsibility of an organization admin (rather than a chaincode or application developer).</p><p>我们将专注于向channel添加新组织，你可以使用相似的流程来进行其他情况的通道配置更新。略</p><h2 id="Setup-the-Environment（启动环境）">Setup the Environment（启动环境）</h2><p>启动测试环境并创建默认的channel，请参考：<a href="Fabric%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8.md">Fabric测试网络使用</a></p><h2 id="Bring-Org3-into-the-Channel-with-the-Script（使用脚本将Org3加入到通道）">Bring Org3 into the Channel with the Script（使用脚本将Org3加入到通道）</h2><p>You should be in the <code>test-network</code> directory. To use the script, simply issue the following commands:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd addOrg3</span><br><span class="line">./addOrg3.sh up</span><br></pre></td></tr></table></figure><p>The output here is well worth reading. You’ll see the Org3 crypto material being generated, the Org3 organization definition being created, and then the channel configuration being updated, signed, and then submitted to the channel.</p><p>这里的输出值的我们一读。你会看到生成Org3组织的加密材料，创建组织Org3的定义然后通道配置会被更新、签名并且提交到通道。</p><p>If everything goes well, you’ll get this message:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">========= Finished adding Org3 to your test network! =========</span><br></pre></td></tr></table></figure><p>Now that we have confirmed we can add Org3 to our channel, we can go through the steps to update the channel configuration that the script completed behind the scenes.</p><p>现在我们已经确认我们可以把组织Org3添加到我们的通道，我们可以按照以下步骤更新通道配置来完成脚本在幕后完成工作。</p><h2 id="Bring-Org3-into-the-Channel-Manually（手动将Org3加入通道）">Bring Org3 into the Channel Manually（手动将Org3加入通道）</h2><p>If you just used the <code>addOrg3.sh</code> script, you’ll need to bring your network down. The following command will bring down all running components and remove the crypto material for all organizations:</p><p>如果你刚才使用了 <code>addOrg3.sh</code>脚本，你需要先把网络关闭。下面的命令会关闭所有正在运行的组件并且移除所有组织的加密材料：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd addOrg3</span><br><span class="line">./addOrg3.sh down</span><br></pre></td></tr></table></figure><p>After the network is brought down, bring it back up again（网络关闭之后，重新启动它）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">./network.sh up createChannel</span><br></pre></td></tr></table></figure><p>This will bring your network back to the same state it was in before you executed the <code>addOrg3.sh</code> script.</p><p>这将使您的网络恢复到执行addOrg3.sh脚本之前的状态。</p><p>Now we’re ready to add Org3 to the channel manually. As a first step, we’ll need to generate Org3’s crypto material.</p><p>现在我们已经准备好手动的将Org3添加到通道中了，第一步，我们需要生成Org3的加密材料。</p><h2 id="Generate-the-Org3-Crypto-Material（生成Org3的加密材料）">Generate the Org3 Crypto Material（生成Org3的加密材料）</h2><p>In another terminal, change into the <code>addOrg3</code> subdirectory from <code>test-network</code>.</p><p>在另一个终端切换到 <code>test-network</code>目录的子目录 <code>addOrg3</code>中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd addOrg3</span><br></pre></td></tr></table></figure><p>First, we are going to create the certificates and keys for the Org3 peer, along with an application and admin user. Because we are updating an example channel, we are going to use the cryptogen tool instead of using a Certificate Authority. The following command uses cryptogen to read the <code>org3-crypto.yaml</code> file and generate the Org3 crypto material in a new <code>org3.example.com</code> folder:</p><p>首先我们会为Org3的peer节点生成证书以及密钥，以及应用程序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/release-2.2/channel_update_tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/fabric/创建一个新的channel</title>
    <link href="https://nijixucai.github.io/2020/12/22/blockchain/fabric/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84channel/"/>
    <id>https://nijixucai.github.io/2020/12/22/blockchain/fabric/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84channel/</id>
    <published>2020-12-22T09:09:41.285Z</published>
    <updated>2020-12-23T09:48:32.656Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/create_channel/create_channel.html" target="_blank" rel="noopener">官方文档</a></p><h1 id="创建一个新的channel">创建一个新的channel</h1><p>You can use this tutorial to learn how to create new channels using the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/configtxgen.html" target="_blank" rel="noopener">configtxgen</a> CLI tool and then use the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerchannel.html" target="_blank" rel="noopener">peer channel</a> commands to join a channel with your peers. While this tutorial will leverage the Fabric test network to create the new channel, the steps in this tutorial can also be used by network operators in a production environment.</p><p>你可以通过这个教程来学习通过 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/configtxgen.html" target="_blank" rel="noopener">configtxgen</a>CLI工具来创建新的通道，然后通过 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerchannel.html" target="_blank" rel="noopener">peer channel</a> 命令将peer节点加入通道。尽管本教程将利用Fabric测试网络来创建新渠道，网络操作人员也可以在生产环境中使用本教程中的步骤。</p><p>In the process of creating the channel, this tutorial will take you through the following steps and concepts:</p><p>在创建频道的过程中，本教程将带您完成以下步骤和概念：</p><ul><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/create_channel/create_channel.html#setting-up-the-configtxgen-tool" target="_blank" rel="noopener">Setting up the configtxgen tool</a>：设置configtxgen工具</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/create_channel/create_channel.html#the-configtx-yaml-file" target="_blank" rel="noopener">Using the configtx.yaml file</a>：使用configtx.yaml配置文件</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/create_channel/create_channel.html#the-orderer-system-channel" target="_blank" rel="noopener">The orderer system channel</a>：排序的系统通道介绍</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/create_channel/create_channel.html#creating-an-application-channel" target="_blank" rel="noopener">Creating an application channel</a>：创建一个应用通道</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/create_channel/create_channel.html#join-peers-to-the-channel" target="_blank" rel="noopener">Joining peers to the channel</a>：将peer节点加入通道</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/create_channel/create_channel.html#set-anchor-peers" target="_blank" rel="noopener">Setting anchor peers</a>：设置锚节点</li></ul><h3 id="Setting-up-the-configtxgen-tool（设置configtxgen工具）">Setting up the configtxgen tool（设置configtxgen工具）</h3><p>Channels are created by building a channel creation transaction and submitting the transaction to the ordering service. The channel creation transaction specifies the initial configuration of the channel and is used by the ordering service to write the channel genesis block. While it is possible to build the channel creation transaction file manually, it is easier to use the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/configtxgen.html" target="_blank" rel="noopener">configtxgen</a> tool. The tool works by reading a <code>configtx.yaml</code> file that defines the configuration of your channel, and then writing the relevant information into the channel creation transaction. Before we discuss the <code>configtx.yaml</code> file in the next section, we can get started by downloading and setting up the <code>configtxgen</code> tool.</p><p>通道的创建是通过构建一个创建通道的交易然后将此交易提交给排序服务来完成的。“创建通道的交易”指明了此通道的初始化配置并且由排序服务写入通道的创世纪区块中。尽管可以手动构建“创建通道的交易”，但使用configtxgen工具更容易。configtxgen工具读取定义了channle配置的<code>configtx.yaml</code>文件，然后将相关信息写入“创建通道的交易”中。在我们讨论 <code>configtx.yaml</code> 文件之前，我们先开始下载并设置<code>configtxgen</code> 工具。</p><p>You can download the <code>configtxgen</code> binaries by following the steps to <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/install.html" target="_blank" rel="noopener">install the samples, binaries and Docker images</a>. <code>configtxgen</code> will be downloaded to the <code>bin</code> folder of your local clone of the <code>fabric-samples</code> repository along with other Fabric tools.</p><p>你可以跟着 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/install.html" target="_blank" rel="noopener">install the samples, binaries and Docker images</a>的步骤来下载 <code>configtxgen</code> 。 <code>configtxgen</code> 会下载到<code>fabric-samples</code>仓库的<code>bin</code>目录下。</p><p>For the purposes of this tutorial, we will want to operate from the <code>test-network</code> directory inside <code>fabric-samples</code>. Navigate to that directory using the following command:</p><p>为了本教程的目的，我们会想要在<code>fabric-samples</code>下面的 <code>test-network</code> 目录下进行操作，使用下面的命令切换到此目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd fabric-samples/test-network</span><br></pre></td></tr></table></figure><p>We will operate from the <code>test-network</code> directory for the remainder of the tutorial. Use the following command to add the configtxgen tool to your CLI path:</p><p>在本教程的其余部分中，我们将从test-network目录进行操作。使用以下命令将configtxgen工具添加到您的CLI路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;PWD&#125;/../bin:$PATH</span><br></pre></td></tr></table></figure><p>In order to use <code>configtxgen</code>, you need to the set the <code>FABRIC_CFG_PATH</code> environment variable to the path of the directory that contains your local copy of the <code>configtx.yaml</code> file. For this tutorial, we will reference the <code>configtx.yaml</code> used to setup the Fabric test network in the <code>configtx</code> folder:</p><p>为了使用<code>configtxgen</code>，您需要将<code>FABRIC_CFG_PATH</code>环境变量设置为包含<code>configtx.yaml</code>的本地目录。对于本教程，我们将在此环境变量设置为在Fabric test network目录下的包含<code>configtx.yaml</code>的<code>configtx</code> 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export FABRIC_CFG_PATH=$&#123;PWD&#125;/configtx</span><br></pre></td></tr></table></figure><p>You can check that you can are able to use the tool by printing the <code>configtxgen</code> help text:</p><p>你可以通过打印 <code>configtxgen</code>工具的help来检查是否已经设置好:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configtxgen --help</span><br></pre></td></tr></table></figure><h2 id="The-configtx-yaml-file（configtx-yaml文件）">The configtx.yaml file（configtx.yaml文件）</h2><p>The <code>configtx.yaml</code> file specifies the <strong>channel configuration</strong> of new channels. The information that is required to build the channel configuration is specified in a readable and editable form in the <code>configtx.yaml</code> file. The <code>configtxgen</code> tool uses the channel profiles defined in the <code>configtx.yaml</code> file to create the channel configuration and write it to the <a href="https://developers.google.com/protocol-buffers" target="_blank" rel="noopener">protobuf format</a> that can be read by Fabric.</p><p><code>configtx.yaml</code> 文件指明了一个新的通道的通道配置。在<code>configtx.yaml</code>文件中可以读取和编辑构建通道配置所需的信息。 <code>configtxgen</code> 工具通过使用 <code>configtx.yaml</code>文件中的通道属性的定义来创建通道配置，并将其写入可由Fabric读取的 <a href="https://developers.google.com/protocol-buffers" target="_blank" rel="noopener">protobuf格式</a>。</p><p>You can find the <code>configtx.yaml</code> file that is used to deploy the test network in the <code>configtx</code> folder in the <code>test-network</code> directory. The file contains the following information that we will use to create our new channel:</p><p>你可以在<code>test-network</code>目录的<code>configtx</code> 文件夹下面看到 <code>configtx.yaml</code> 文件，这个文件包含在创建新通道时会用到的下面的信息：</p><ul><li><p><strong>Organizations:</strong> The organizations that can become members of your channel. Each organization has a reference to the cryptographic material that is used to build the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/membership/membership.html" target="_blank" rel="noopener">channel MSP</a>.</p><ul><li>可以成为你的通道成员的组织信息，每一个组织都有对用于构建<a href="%5D(https://hyperledger-fabric.readthedocs.io/en/release-2.2/membership/membership.html)">通道MSP</a>的加密材料的引用。</li></ul></li><li><p><strong>Ordering service:</strong> Which ordering nodes will form the ordering service of the network, and consensus method they will use to agree to a common order of transactions. The file also contains the organizations that will become the ordering service administrators.</p><ul><li>哪些排序节点将形成网络中的排序服务，以及它们用于同意交易顺序的共识方法。此文件还包含了会成为排序服务管理员的组织的信息。</li></ul></li><li><p><strong>Channel policies：</strong> Different sections of the file work together to define the policies that will govern how organizations interact with the channel and which organizations need to approve channel updates. For the purposes of this tutorial, we will use the default policies used by Fabric.</p><ul><li>文件的不同部分一起定义通道策略，这些策略将控制组织与通道的交互方式以及哪些组织需要批准渠道更新。就本教程而言，我们将使用Fabric使用的默认策略。</li></ul></li><li><p><strong>Channel profiles</strong> Each channel profile references information from other sections of the <code>configtx.yaml</code> file to build a channel configuration. The profiles are used the create the genesis block of the orderer system channel and the channels that will be used by peer organizations. To distinguish them from the system channel, the channels used by peer organizations are often referred to as application channels.</p><ul><li>每个通道的配置信息都引用<code>configtx.yaml</code>文件的其他部分来构建通道配置。这些配置信息是用来创建<strong>orderer system channel</strong> 的创世纪区块的，然后通道会被同等的其他组织所使用。为了将它们（<strong>orderer system channel</strong>）与系统通道区分开来，组织使用的通道通常称为应用程序通道。</li></ul><p>The <code>configtxgen</code> tool uses <code>configtx.yaml</code> file to create a complete genesis block for the system channel. As a result, the system channel profile needs to specify the full system channel configuration. The channel profile used to create the channel creation transaction only needs to contain the additional configuration information required to create an application channel.</p></li></ul><p><code>configtxgen</code>工具使用<code>configtx.yaml</code>文件为系统通道创建完整的创世块。结果，系统通道配置文件需要指定完整的系统通道配置。用于创建“创建通道的交易”使用的通道配置仅需要包含创建应用程序通道所需的其他配置信息。</p><p>You can visit the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/create_channel/create_channel_genesis.html" target="_blank" rel="noopener">Using configtx.yaml to create a channel genesis block</a> tutorial to learn more about this file. For now, we will return to the operational aspects of creating the channel, though we will reference parts of this file in future steps.</p><p>你可以访问 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/create_channel/create_channel_genesis.html" target="_blank" rel="noopener">Using configtx.yaml to create a channel genesis block</a> 教程来学习此文件的更多信息。现在我们回到创建通道的操作方面。</p><h2 id="Start-the-network（启动网络）">Start the network（启动网络）</h2><p>参考<a href="Fabric%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8.md">Fabric测试网络使用</a></p><p>Our instance of the test network was deployed without creating an application channel. However, the test network script creates the system channel when you issue the <code>./network.sh up</code> command. Under the covers, the script uses the <code>configtxgen</code> tool and the <code>configtx.yaml</code> file to build the genesis block of the system channel. Because the system channel is used to create other channels, we need to take some time to understand the orderer system channel before we can create an application channel.</p><p>我们部署的测试网络实例未创建应用程序通道。但是测试网络脚本在你运行<code>./network.sh up</code> 命令时创建了系统通道。在幕后，脚本使用<code>configtxgen</code>工具和<code>configtx.yaml</code>文件来构建系统通道的创世纪块。因为系统通道是用来创建其他通道的，所以我们在创建一个应用通道之前需要花一些时间去了解排序系统通道（ <strong>orderer system channel</strong> ）</p><h2 id="The-orderer-system-channel（排序系统通道）">The orderer system channel（排序系统通道）</h2><p>略</p><h2 id="Creating-an-application-channel（创建一个应用通道）">Creating an application channel（创建一个应用通道）</h2><p>Now that we have deployed the nodes of the network and created the orderer system channel using the <code>network.sh</code> script, we can start the process of creating a new channel for our peer organizations. We have already set the environment variables that are required to use the <code>configtxgen</code> tool. Run the following command to create a channel creation transaction for <code>channel1</code>:</p><p>现在我们已经使用<code>network.sh</code>脚本在测试网络中部署了节点，并且创建了排序系统通道。我们现在可以开始为我们的组织创建一个新通道的程序了。我们已经设置了使用<code>configtxgen</code>工具所需的环境变量。运行下面的程序来为<code>channel1</code>通道创建一个“创建通道的交易”：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel1.tx -channelID channel1</span><br></pre></td></tr></table></figure><p>The <code>-channelID</code> will be the name of the future channel. Channel names must be all lower case, less than 250 characters long and match the regular expression <code>[a-z][a-z0-9.-]*</code>. The command uses the uses the <code>-profile</code> flag to reference the <code>TwoOrgsChannel:</code> profile from <code>configtx.yaml</code> that is used by the test network to create application channels:</p><p><code>-channelID</code>标志制定了创建的通道的名称，通道的名称必须全是小写，不超过250个字符并且符合正则表达式<code>[a-z][a-z0-9.-]*</code>。该命令使用<code>-profile</code>标志来引用<code>configtx.yaml</code>文件中的<code>TwoOrgsChannel：</code>配置，测试网络使用它来创建应用程序通道：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">TwoOrgsChannel:</span></span><br><span class="line">    <span class="attr">Consortium:</span> <span class="string">SampleConsortium</span></span><br><span class="line">    <span class="string">&lt;&lt;:</span> <span class="meta">*ChannelDefaults</span></span><br><span class="line">    <span class="attr">Application:</span></span><br><span class="line">        <span class="string">&lt;&lt;:</span> <span class="meta">*ApplicationDefaults</span></span><br><span class="line">        <span class="attr">Organizations:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="meta">*Org1</span></span><br><span class="line">            <span class="bullet">-</span> <span class="meta">*Org2</span></span><br><span class="line">        <span class="attr">Capabilities:</span></span><br><span class="line">            <span class="string">&lt;&lt;:</span> <span class="meta">*ApplicationCapabilities</span></span><br></pre></td></tr></table></figure><p>The profile references the name of the <code>SampleConsortium</code> from the system channel, and includes both peer organizations from the consortium as channel members. Because the system channel is used as a template to create the application channel, the ordering nodes defined in the system channel become the default <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#consenter-set" target="_blank" rel="noopener">consenter set</a> of the new channel, while the administrators of the ordering service become the orderer administrators of the channel. Ordering nodes and ordering organizations can be added or removed from the consenter set using channel updates.</p><p>该配置文件从系统通道引用<code>SampleConsortium</code>的名称，并且包含来自该联盟的两个组织作为通道成员。因为系统通道被用作模版来创建应用通道，系统通道中定义的排序节点成为新渠道的默认<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#consenter-set" target="_blank" rel="noopener">consenter set</a>，而排序服务的管理员将成为新渠道的排序管理员。可以使用通道更新在<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/glossary.html#consenter-set" target="_blank" rel="noopener">consenter set</a>中添加或删除排序节点和排序组织。</p><p>If the command successful, you will see logs of <code>configtxgen</code> loading the <code>configtx.yaml</code> file and printing a channel creation transaction:</p><p>如果上面的命令执行成功，你会看到<code>configtxgen</code> 工具加载 <code>configtx.yaml</code> 文件并且打印了一个创建通道的交易：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-12-23 14:25:49.175 CST [common.tools.configtxgen] main -&gt; INFO 001 Loading configuration</span><br><span class="line">2020-12-23 14:25:49.185 CST [common.tools.configtxgen.localconfig] Load -&gt; INFO 002 Loaded configuration: /Users/apple/code/open-source/blockchain/hyperledger/fabric-samples/test-network/configtx/configtx.yaml</span><br><span class="line">2020-12-23 14:25:49.185 CST [common.tools.configtxgen] doOutputChannelCreateTx -&gt; INFO 003 Generating new channel configtx</span><br><span class="line">2020-12-23 14:25:49.188 CST [common.tools.configtxgen] doOutputChannelCreateTx -&gt; INFO 004 Writing new channel tx</span><br></pre></td></tr></table></figure><p>We can use the <code>peer</code> CLI to submit the channel creation transaction to the ordering service. To use the <code>peer</code> CLI, we need to set the <code>FABRIC_CFG_PATH</code> to the <code>core.yaml</code> file located in the <code>fabric-samples/config</code> directory. Set the <code>FABRIC_CFG_PATH</code> environment variable by running the following command:</p><p>你可以使用 <code>peer</code>CLI来把这个“创建通道的交易”提交到排序服务。为了使用<code>peer</code> CLI，我们需要设置环境变量<code>FABRIC_CFG_PATH</code>为 <code>fabric-samples/config</code> 目录下的<code>core.yaml</code>文件，运行下面的命令来设置<code>FABRIC_CFG_PATH</code>环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export FABRIC_CFG_PATH=$PWD/../config/</span><br></pre></td></tr></table></figure><p>Before the ordering service creates the channel, the ordering service will check the permission of the identity that submitted the request. By default, only admin identities of organizations that belong to the system channel consortium can create a new channel. Issue the commands below to operate the <code>peer</code> CLI as the admin user from Org1:</p><p>在排序服务创建通道时，排序服务会检查提交请求的身份的权限。默认情况下，只有属于系统通道联盟的组织的管理员身份才能创建新的通道。运行下面的命令来以Org1的管理员身份操作 <code>peer</code> CLI:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export CORE_PEER_TLS_ENABLED=true</span><br><span class="line">export CORE_PEER_LOCALMSPID="Org1MSP"</span><br><span class="line">export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line">export CORE_PEER_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line">export CORE_PEER_ADDRESS=localhost:7051</span><br></pre></td></tr></table></figure><p>You can now create the channel by using the following command:</p><p>你现在可以使用下面的命令来创建通道了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel create -o localhost:7050  --ordererTLSHostnameOverride orderer.example.com -c channel1 -f ./channel-artifacts/channel1.tx --outputBlock ./channel-artifacts/channel1.block --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure><p>The command above provides the path to the channel creation transaction file using the <code>-f</code> flag and uses the <code>-c</code> flag to specify the channel name. The <code>-o</code> flag is used to select the ordering node that will be used to create the channel. The <code>--cafile</code> is the path to the TLS certificate of the ordering node. When you run the <code>peer channel create</code> command, the <code>peer</code> CLI will generate the following response:</p><p>上面的命令使用 <code>-f</code>标志来指定“创建通道的交易”的文件，并且使用 <code>-c</code> 标志来指定通道名称。<code>-o</code>标志是用来选择用来创建通道的排序节点的。<code>--cafile</code> 标志是排序节点的TLS证书路径。当你运行 <code>peer channel create</code>命令时， <code>peer</code> CLI会生成下面的响应：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-12-23 14:36:09.386 CST [channelCmd] InitCmdFactory -&gt; INFO 00b Endorser and orderer connections initialized</span><br><span class="line">2020-12-23 14:36:09.595 CST [cli.common] readBlock -&gt; INFO 00c Received block: 0</span><br></pre></td></tr></table></figure><p>Because we are using a Raft ordering service, you may get some status unavailable messages that you can safely ignore. The command will return the genesis block of the new channel to the location specified by the <code>--outputBlock</code> flag.</p><p>因为我们使用一个Raft策略的排序服务，你可能会收到一些状态不可用的信息你可以放心的忽略他们。该命令会将新通道的创世纪区块输出到<code>--outputBlock</code>标志指定的位置。</p><h2 id="Join-peers-to-the-channel（把节点加入通道中）">Join peers to the channel（把节点加入通道中）</h2><p>After the channel has been created, we can join the channel with our peers. Organizations that are members of the channel can fetch the channel genesis block from the ordering service using the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerchannel.html#peer-channel-fetch" target="_blank" rel="noopener">peer channel fetch</a> command. The organization can then use the genesis block to join the peer to the channel using the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerchannel.html#peer-channel-join" target="_blank" rel="noopener">peer channel join</a> command. Once the peer is joined to the channel, the peer will build the blockchain ledger by retrieving the other blocks on the channel from the ordering service.</p><p>在通道创建之后，我们可以把我们的peer节点加入到通道。属于通道成员的组织可以使用 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerchannel.html#peer-channel-fetch" target="_blank" rel="noopener">peer channel fetch</a>命令从排序服务那里获取通道的创世纪区块。然后这个组织就可以使用这个创世纪区块来通过 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerchannel.html#peer-channel-join" target="_blank" rel="noopener">peer channel join</a> 命令将peer节点加入到通道了。一旦peer节点加入了通道，peer节点将通过从排序服务中检索其他区块来构建区块链账本了。</p><p>Since we are already operating the <code>peer</code> CLI as the Org1 admin, let’s join the Org1 peer to the channel. Since Org1 submitted the channel creation transaction, we already have the channel genesis block on our file system. Join the Org1 peer to the channel using the command below.</p><p>因为我们已经通过Org1的管理员操作了 <code>peer</code> CLI ，让我们把Org1的peer节点加入到通道。因为是Org1组织提交的“创建通道的交易”，我们已经在我们本地的文件系统中拥有了通道的创世纪区块。使用下面的命令将组织Org1的peer节点加入到通道中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel join -b ./channel-artifacts/channel1.block</span><br></pre></td></tr></table></figure><p>The <code>CORE_PEER_ADDRESS</code> environment variable has been set to target <code>peer0.org1.example.com</code>. A successful command will generate a response from <code>peer0.org1.example.com</code> joining the channel:</p><p>环境变量<code>CORE_PEER_ADDRESS</code>已经设置为指向了<code>peer0.org1.example.com</code>，如果命令成功的话会获取 <code>peer0.org1.example.com</code> 加入通道的响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-03-06 17:49:09.903 EST [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">2020-03-06 17:49:10.060 EST [channelCmd] executeJoin -&gt; INFO 002 Successfully submitted proposal to join channel</span><br></pre></td></tr></table></figure><p>我本地的运行报错如下，记录TODO，最终使用最新2.3.0的版本就没有这个问题。2.2.0版本没有成功启动org1的peer。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) apple@WHOAMIdeMacBook-Pro:~/code/open-source/blockchain/hyperledger/fabric-samples/test-network$     peer channel join -b ./channel-artifacts/channel1.block</span><br><span class="line">2020-12-23 14:59:02.760 CST [comm.tls] ClientHandshake -&gt; ERRO 001 Client TLS handshake failed after 2.782623ms with error: EOF remoteaddress=[::1]:7051</span><br><span class="line">2020-12-23 14:59:03.768 CST [comm.tls] ClientHandshake -&gt; ERRO 002 Client TLS handshake failed after 2.438885ms with error: EOF remoteaddress=[::1]:7051</span><br><span class="line">2020-12-23 14:59:05.075 CST [comm.tls] ClientHandshake -&gt; ERRO 003 Client TLS handshake failed after 1.857716ms with error: EOF remoteaddress=[::1]:7051</span><br><span class="line">Error: error getting endorser client for channel: endorser client failed to connect to localhost:7051: failed to create new connection: context deadline exceeded</span><br></pre></td></tr></table></figure><p>You can verify that the peer has joined the channel using the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerchannel.html#peer-channel-getinfo" target="_blank" rel="noopener">peer channel getinfo</a> command:</p><p>你可以使用 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerchannel.html#peer-channel-getinfo" target="_blank" rel="noopener">peer channel getinfo</a> 命令来验证peer节点已经加入了通道：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel getinfo -c channel1</span><br></pre></td></tr></table></figure><p>The command will list the block height of the channel and the hash of the most recent block. Because the genesis block is the only block on the channel, the height of the channel will be 1:</p><p>这个命令会列出通道区块的高度和最新的区块的hash值，因为这个通道上只有一个创世纪区块，所以这个通道上的区块高度是1:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-03-13 10:50:06.978 EDT [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">Blockchain info: &#123;"height":1,"currentBlockHash":"kvtQYYEL2tz0kDCNttPFNC4e6HVUFOGMTIDxZ+DeNQM="&#125;</span><br></pre></td></tr></table></figure><p>We can now join the Org2 peer to the channel. Set the following environment variables to operate the <code>peer</code> CLI as the Org2 admin. The environment variables will also set the Org2 peer, <code>peer0.org1.example.com</code>, as the target peer.</p><p>我们现在可以把组织Org2的peer节点加入通道了。设置下面的环境变量来使用Org2的管理员操作<code>peer</code> CLI。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export CORE_PEER_TLS_ENABLED=true</span><br><span class="line">export CORE_PEER_LOCALMSPID="Org2MSP"</span><br><span class="line">export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br><span class="line">export CORE_PEER_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span><br><span class="line">export CORE_PEER_ADDRESS=localhost:9051</span><br></pre></td></tr></table></figure><p>While we still have the channel genesis block on our file system, in a more realistic scenario, Org2 would have the fetch the block from the ordering service. As an example, we will use the <code>peer channel fetch</code> command to get the genesis block for Org2:</p><p>然而在我们本地系统中仍然存在通道的创世纪区块，在一个更真实的情形中，组织Org2应该从排序服务获取这个区块。例如，我们将使用 <code>peer channel fetch</code>命令来为组织Org2获取创世纪区块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel fetch 0 ./channel-artifacts/channel_org2.block -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com -c channel1 --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure><p>The command uses <code>0</code> to specify that it needs to fetch the genesis block that is required to join the channel. If the command is successful, you should see the following output:</p><p>该命令使用<code>0</code>来指明它需要获取创世纪块，该创世纪区块用于加入通道。如果命令执行成功，你会看到下面的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-03-13 11:32:06.309 EDT [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">2020-03-13 11:32:06.336 EDT [cli.common] readBlock -&gt; INFO 002 Received block: 0</span><br></pre></td></tr></table></figure><p>The command returns the channel genesis block and names it <code>channel_org2.block</code> to distinguish it from the block pulled by org1. You can now use the block to join the Org2 peer to the channel:</p><p>这个命令会获取到名为 <code>channel_org2.block</code> 的通道创世纪区块，以与Org1的区块作区分。你现在可以使用这个区块把Org2的peer节点加入到通道：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel join -b ./channel-artifacts/channel_org2.block</span><br></pre></td></tr></table></figure><h2 id="Set-anchor-peers（设置锚节点）">Set anchor peers（设置锚节点）</h2><p>After an organizations has joined their peers to the channel, they should select at least one of their peers to become an anchor peer. <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/gossip.html#anchor-peers" target="_blank" rel="noopener">Anchor peers</a> are required in order to take advantage of features such as private data and service discovery. Each organization should set multiple anchor peers on a channel for redundancy. For more information about gossip and anchor peers, see the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/gossip.html" target="_blank" rel="noopener">Gossip data dissemination protocol</a>.</p><p>在一个组织将他们的peer节点加入到通道之后，他们还需要在他们的组织内部选择至少一个peer节点作为锚节点。<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/gossip.html#anchor-peers" target="_blank" rel="noopener">Anchor peers</a> 需要锚节点的好处是他能够利用私有数据以及做服务发现。每个组织都应在一个通道上设置多个锚节点以实现冗余。</p><p>The endpoint information of the anchor peers of each organization is included in the channel configuration. Each channel member can specify their anchor peers by updating the channel. We will use the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/configtxlator.html" target="_blank" rel="noopener">configtxlator</a> tool to update the channel configuration and select an anchor peer for Org1 and Org2. The process for setting an anchor peer is similar to the steps that are required to make other channel updates and provides an introduction to how to use <code>configtxlator</code> to <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html" target="_blank" rel="noopener">update a channel configuration</a>. You will also need to install the <a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">jq tool</a> on your local machine.</p><p>通道配置中包含每个组织的锚节点的终点信息。每个组织都可以通过更新通道配置来知名他们的锚节点。我们会使用 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/configtxlator.html" target="_blank" rel="noopener">configtxlator</a>工具来更新通道配置并且为组织Org1和Org2各选择一个锚节点。设置锚节点的流程与教程<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html" target="_blank" rel="noopener">update a channel configuration</a>的步骤很类似。你还需要在你的本地安装<a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">jq</a> 工具。</p><p>We will start by selecting an anchor peer as Org1. The first step is to pull the most recent channel configuration block using the <code>peer channel fetch</code> command. Set the following environment variables to operate the <code>peer</code> CLI as the Org1 admin:</p><p>我们先以Org1的身份来选择一个锚节点。第一步是使用<code>peer channel fetch</code> 命令拉去最新的通道配置区块。设置环境变量以Org1管理员的身份操作 <code>peer</code> CLI ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export FABRIC_CFG_PATH=$PWD/../config/</span><br><span class="line">export CORE_PEER_TLS_ENABLED=true</span><br><span class="line">export CORE_PEER_LOCALMSPID="Org1MSP"</span><br><span class="line">export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line">export CORE_PEER_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line">export CORE_PEER_ADDRESS=localhost:7051</span><br></pre></td></tr></table></figure><p>You can use the following command to fetch the channel configuration:</p><p>你可以通过下面的命令来获取通道配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel fetch config channel-artifacts/config_block.pb -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com -c channel1 --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure><p>Because the most recent channel configuration block is the channel genesis block, you will see the command return block 0 from the channel.</p><p>因为最新的通道配置区块是通道的创世纪区块，你会看到该命令会返回通道上的0区块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-12-23 16:37:33.686 CST [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">2020-12-23 16:37:33.689 CST [cli.common] readBlock -&gt; INFO 002 Received block: 0</span><br><span class="line">2020-12-23 16:37:33.689 CST [channelCmd] fetch -&gt; INFO 003 Retrieving last config block: 0</span><br><span class="line">2020-12-23 16:37:33.693 CST [cli.common] readBlock -&gt; INFO 004 Received block: 0</span><br></pre></td></tr></table></figure><p>The channel configuration block was stored in the <code>channel-artifacts</code> folder to keep the update process separate from other artifacts. Change into the <code>channel-artifacts</code> folder to complete the next steps:</p><p>通道配置区块被存储在channel-artifacts目录下，以使更新流程与其他的组件区分开。进入 <code>channel-artifacts</code> 目录下来完成接下来的步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd channel-artifacts</span><br></pre></td></tr></table></figure><p>We can now start using the <code>configtxlator</code> tool to start working with the channel configuration. The first step is to decode the block from protobuf into a JSON object that can be read and edited. We also strip away the unnecessary block data, leaving only the channel configuration.</p><p>我们现在开始使用 <code>configtxlator</code> 工具和通道配置一起工作。第一步是将来自区块的protobuf格式解码为可以读取和编辑的JSON格式。我们还将去除不必要的块数据，仅保留通道配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.json</span><br><span class="line">jq .data.data[0].payload.data.config config_block.json &gt; config.json</span><br></pre></td></tr></table></figure><p>These commands convert the channel configuration block into a streamlined JSON, <code>config.json</code>, that will serve as the baseline for our update. Because we don’t want to edit this file directly, we will make a copy that we can edit. We will use the original channel config in a future step.</p><p>这些命令将通道配置区块转换为简化的JSON格式的文件<code>config.json</code>，它将作为我们更新的基准。因为我们不想直接编辑这个文件，我们会先创建一个可以编辑的副本。我们将在以后的步骤中使用原始的通道配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp config.json config_copy.json</span><br></pre></td></tr></table></figure><p>You can use the <code>jq</code> tool to add the Org1 anchor peer to the channel configuration.</p><p>你可以使用<code>jq</code> 工具来添加Org1组织的锚节点到通道配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jq '.channel_group.groups.Application.groups.Org1MSP.values += &#123;"AnchorPeers":&#123;"mod_policy": "Admins","value":&#123;"anchor_peers": [&#123;"host": "peer0.org1.example.com","port": 7051&#125;]&#125;,"version": "0"&#125;&#125;' config_copy.json &gt; modified_config.json</span><br></pre></td></tr></table></figure><p>After this step, we have an updated version of channel configuration in JSON format in the <code>modified_config.json</code> file. We can now convert both the original and modified channel configurations back into protobuf format and calculate the difference between them.</p><p>完成此步骤后，我们在<code>modified_config.json</code>文件中以JSON格式获取了通道配置的更新版本。现在，我们可以将原始的和修改后的通道配置都转换回protobuf格式，并计算它们之间的差异。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configtxlator proto_encode --input config.json --type common.Config --output config.pb</span><br><span class="line">configtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pb</span><br><span class="line">configtxlator compute_update --channel_id channel1 --original config.pb --updated modified_config.pb --output config_update.pb</span><br></pre></td></tr></table></figure><p>The new protobuf named <code>channel_update.pb</code> contains the anchor peer update that we need to apply to the channel configuration. We can wrap the configuration update in a transaction envelope to create the channel configuration update transaction.</p><p>格式为protobuf的新的<code>channel_update.pb</code>文件包含我们需要应用于通道配置上的锚节点更新。我们可以将配置更新包装在交易信封中以创建通道配置更新交易。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.json</span><br><span class="line">echo '&#123;"payload":&#123;"header":&#123;"channel_header":&#123;"channel_id":"channel1", "type":2&#125;&#125;,"data":&#123;"config_update":'$(cat config_update.json)'&#125;&#125;&#125;' | jq . &gt; config_update_in_envelope.json</span><br><span class="line">configtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</span><br></pre></td></tr></table></figure><p>We can now use the final artifact, <code>config_update_in_envelope.pb</code>, that can be used to update the channel. Navigate back to the <code>test-network</code> directory:</p><p>现在，我们可以使用最终工件<code>config_update_in_envelope.pb</code>，该工件可以用于更新通道。回到<code>test-network</code> 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>We can add the anchor peer by providing the new channel configuration to the <code>peer channel update</code> command. Because we are updating a section of the channel configuration that only affects Org1, other channel members do not need to approve the channel update.</p><p>我们可以通过向<code>peer channel update</code>命令提供新的通道配置来添加锚节点。因为我们正在更新仅影响Org1的部分通道配置，所以其他通道成员不需要批准通道更新。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel update -f channel-artifacts/config_update_in_envelope.pb -c channel1 -o localhost:7050  --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure><p>When the channel update is successful, you should see the following response:</p><p>当渠道更新成功后，你会看到下面的响应：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-12-23 17:05:48.187 CST [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">2020-12-23 17:05:48.222 CST [channelCmd] update -&gt; INFO 002 Successfully submitted channel update</span><br></pre></td></tr></table></figure><p>We can set the anchor peers for Org2. Because we are going through the process a second time, we will go through the steps more quickly. Set the environment variables to operate the <code>peer</code> CLI as the Org2 admin:</p><p>我们可以为Org2设置锚节点。因为我们是第二次进行该过程，所以我们将更快地完成这些步骤。设置环境变量以Org2管理员的身份操作 <code>peer</code> CLI ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export CORE_PEER_TLS_ENABLED=true</span><br><span class="line">export CORE_PEER_LOCALMSPID="Org2MSP"</span><br><span class="line">export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br><span class="line">export CORE_PEER_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span><br><span class="line">export CORE_PEER_ADDRESS=localhost:9051</span><br></pre></td></tr></table></figure><p>Pull the latest channel configuration block, which is now the second block on the channel:</p><p>拉去最新的通道配置区块，即目前通道上的第二个区块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel fetch config channel-artifacts/config_block.pb -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com -c channel1 --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure><p>Navigate back to the <code>channel-artifacts</code> directory（切换回 <code>channel-artifacts</code> 目录）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd channel-artifacts</span><br></pre></td></tr></table></figure><p>You can then decode and copy the configuration block.（你可以解码并复制配置区块）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.json</span><br><span class="line">jq .data.data[0].payload.data.config config_block.json &gt; config.json</span><br><span class="line">cp config.json config_copy.json</span><br></pre></td></tr></table></figure><p>Add the Org2 peer that is joined to the channel as the anchor peer in the channel configuration:</p><p>在通道配置中添加Org2的已经加入通道的节点作为锚节点:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jq '.channel_group.groups.Application.groups.Org2MSP.values += &#123;"AnchorPeers":&#123;"mod_policy": "Admins","value":&#123;"anchor_peers": [&#123;"host": "peer0.org2.example.com","port": 9051&#125;]&#125;,"version": "0"&#125;&#125;' config_copy.json &gt; modified_config.json</span><br></pre></td></tr></table></figure><p>We can now convert both the original and updated channel configurations back into protobuf format and calculate the difference between them.</p><p>我们可以将原始的和修改后的通道配置都转换回protobuf格式，并计算它们之间的差异。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configtxlator proto_encode --input config.json --type common.Config --output config.pb</span><br><span class="line">configtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pb</span><br><span class="line">configtxlator compute_update --channel_id channel1 --original config.pb --updated modified_config.pb --output config_update.pb</span><br></pre></td></tr></table></figure><p>Wrap the configuration update in a transaction envelope to create the channel configuration update transaction:</p><p>将配置更新包装在交易信封中以创建通道配置更新交易：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.json</span><br><span class="line">echo '&#123;"payload":&#123;"header":&#123;"channel_header":&#123;"channel_id":"channel1", "type":2&#125;&#125;,"data":&#123;"config_update":'$(cat config_update.json)'&#125;&#125;&#125;' | jq . &gt; config_update_in_envelope.json</span><br><span class="line">configtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</span><br></pre></td></tr></table></figure><p>Navigate back to the <code>test-network</code> directory.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>Update the channel and set the Org2 anchor peer by issuing the following command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel update -f channel-artifacts/config_update_in_envelope.pb -c channel1 -o localhost:7050  --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure><p>You can confirm that the channel has been updated successfully by running the <code>peer channel info</code> command:</p><p>你可以使用 <code>peer channel info</code>命令来确认通道已经成功更新。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer channel getinfo -c channel1</span><br></pre></td></tr></table></figure><p>Now that the channel has been updated by adding two channel configuration blocks to the channel genesis block, the height of the channel will have grown to three:</p><p>现在已经通过在创世纪区块上添加两个通道配置区块更新了通道，通道的区块高度会增长到3:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-12-23 17:19:08.620 CST [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">Blockchain info: &#123;"height":3,"currentBlockHash":"0xMLgGnvbUE+gfDpxjbfB1OsxROF3djLzPX9S76ai2I=","previousBlockHash":"6oIrHH8zjeOuhlj2/rrpzxh0pNmGOdPTDjiphJwCXcQ="&#125;</span><br></pre></td></tr></table></figure><h2 id="Deploy-a-chaincode-to-the-new-channel（部署链码到新通道上）">Deploy a chaincode to the new channel（部署链码到新通道上）</h2><p>We can confirm that the channel was created successfully by deploying a chaincode to the channel. We can use the <code>network.sh</code> script to deploy the Basic asset transfer chaincode to any test network channel. Deploy a chaincode to our new channel using the following command:</p><p>我们可以通过在通道上部署链码来确认通道已经创建成功。我们可以使用 <code>network.sh</code> 脚本部署Basic asset transfer 链码到任何测试通道，使用下面的命令将链码部署到新通道上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go/ -ccl go -c channel1 -cci InitLedger</span><br></pre></td></tr></table></figure><p>After you run the command, you should see the chaincode being deployed to the channel in your logs. The chaincode is invoked to add data to the channel ledger.</p><p>运行命令后，您应该在日志中看到链码已部署到通道。调用链码将数据添加到通道账本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C channel1 -n basic -c '&#123;"Args":["getAllAssets"]&#125;'</span><br></pre></td></tr></table></figure><p>After you run the query, you should see the assets that were added to the channel ledger.</p><p>在运行查询之后，你会看到已经添加到通道账本上的资产列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;"ID":"asset1","color":"blue","size":5,"owner":"Tomoko","appraisedValue":300&#125;,&#123;"ID":"asset2","color":"red","size":5,"owner":"Brad","appraisedValue":400&#125;,&#123;"ID":"asset3","color":"green","size":10,"owner":"Jin Soo","appraisedValue":500&#125;,&#123;"ID":"asset4","color":"yellow","size":10,"owner":"Max","appraisedValue":600&#125;,&#123;"ID":"asset5","color":"black","size":15,"owner":"Adriana","appraisedValue":700&#125;,&#123;"ID":"asset6","color":"white","size":15,"owner":"Michel","appraisedValue":800&#125;]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/release-2.2/create_channel/create_channel.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/fabric/通过供应链金融练习Fabric</title>
    <link href="https://nijixucai.github.io/2020/12/22/blockchain/fabric/%E9%80%9A%E8%BF%87%E4%BE%9B%E5%BA%94%E9%93%BE%E9%87%91%E8%9E%8D%E7%BB%83%E4%B9%A0Fabric/"/>
    <id>https://nijixucai.github.io/2020/12/22/blockchain/fabric/%E9%80%9A%E8%BF%87%E4%BE%9B%E5%BA%94%E9%93%BE%E9%87%91%E8%9E%8D%E7%BB%83%E4%B9%A0Fabric/</id>
    <published>2020-12-22T08:15:02.071Z</published>
    <updated>2020-12-23T11:30:05.804Z</updated>
    
    <content type="html"><![CDATA[<p>通过供应链金融练习Fabric</p><p>开发与部署步骤：</p><ol><li>启动测试网络</li><li>添加组织，</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/create_channel/create_channel.html" target="_blank" rel="noopener">创建新的channel</a><ol><li>核心企业与一级供应商的channel</li><li>一级供应商与二级供应商的channel</li></ol></li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/chaincode4ade.html" target="_blank" rel="noopener">开发“发行智能合约”链码</a></li><li><a href="%E5%B0%86%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%83%A8%E7%BD%B2%E5%88%B0%E9%80%9A%E9%81%93.md">部署“发行智能合约”到channel</a></li><li>开发“转账凭证智能合约”</li><li>部署“转账凭证智能合约”到channel</li></ol><p>测试：</p><ol><li>核心企业发行凭证资产，并交易给一级供应商</li><li>一级供应商转账给二级供应商</li><li>查看交易、资产归属</li></ol><h2 id="1-启动测试网络">1.启动测试网络</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 因为使用2.2.0和1.4.9版本启动时org1无法启动，所以先使用最新版本</span></span><br><span class="line">./network.sh up</span><br></pre></td></tr></table></figure><h2 id="2-添加组织">2.添加组织</h2><p>参考：<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/channel_update_tutorial.html" target="_blank" rel="noopener">添加组织并将组织添加到现有的channel</a></p><h2 id="3-创建Channel">3. 创建Channel</h2><p>参考：<a href="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84channel.md">创建一个新的channel</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过供应链金融练习Fabric&lt;/p&gt;
&lt;p&gt;开发与部署步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动测试网络&lt;/li&gt;
&lt;li&gt;添加组织，&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/release</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/fabric/编写您的第一个Chaincode</title>
    <link href="https://nijixucai.github.io/2020/12/21/blockchain/fabric/%E7%BC%96%E5%86%99%E6%82%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAChaincode/"/>
    <id>https://nijixucai.github.io/2020/12/21/blockchain/fabric/%E7%BC%96%E5%86%99%E6%82%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAChaincode/</id>
    <published>2020-12-21T10:35:52.258Z</published>
    <updated>2020-12-22T08:15:56.622Z</updated>
    
    <content type="html"><![CDATA[<p>编写您的第一个Chaincode</p><h2 id="Asset-Transfer-Chaincode（资产交易智能合约）">Asset Transfer Chaincode（资产交易智能合约）</h2><p>Our application is a basic sample chaincode to initialize a ledger with assets, create, read, update, and delete assets, check to see if an asset exists, and transfer assets from one owner to another.</p><p>我们的程序是一个基本简单的链码，利用资产初始化账本，创建、读取，更新以及更新资产，检查一个资产是否存在并且把资产从一个所有者交易给另一个所有者。</p><h3 id="Choosing-a-Location-for-the-Code（给代码选一个位置）">Choosing a Location for the Code（给代码选一个位置）</h3><p>If you haven’t been doing programming in Go, you may want to make sure that you have <a href="https://golang.org/" target="_blank" rel="noopener">Go</a> installed and your system properly configured. We assume you are using a version that supports modules.</p><p>如果你还没有使用过Go，你需要确认你的环境已经安装了 <a href="https://golang.org/" target="_blank" rel="noopener">Go</a>并配置好了环境变量。我们假设你使用的是支持模块的版本。</p><p>Now, you will want to create a directory for your chaincode application.</p><p>To keep things simple, let’s use the following command:</p><p>现在你想要为你的链码程序创建一个目录，简单起见，我们使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// atcc is shorthand for asset transfer chaincode</span><br><span class="line">mkdir atcc &amp;&amp; cd atcc</span><br></pre></td></tr></table></figure><p>Now, let’s create the module and the source file that we’ll fill in with code:</p><p>现在让我们创建模块和源文件，并用代码填充它们：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod init atcc</span><br><span class="line">touch atcc.go</span><br></pre></td></tr></table></figure><h3 id="Housekeeping-整理工作">Housekeeping(整理工作)</h3><p>First, let’s start with some housekeeping. As with every chaincode, it implements the <a href="https://godoc.org/github.com/hyperledger/fabric-contract-api-go/contractapi" target="_blank" rel="noopener">fabric-contract-api interface</a>, so let’s add the Go import statements for the necessary dependencies for our chaincode. We’ll import the fabric contract api package and define our SmartContract.</p><p>首先让我们做一些整理工作。所有的链码都实现了<a href="https://godoc.org/github.com/hyperledger/fabric-contract-api-go/contractapi" target="_blank" rel="noopener">fabric-contract-api interface</a>，所以让我们为Go程序添加必要的依赖。我们会导入fabric合同API包来定义我们的智能合约。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">  <span class="string">"github.com/hyperledger/fabric-contract-api-go/contractapi"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SmartContract provides functions for managing an Asset</span></span><br><span class="line">   <span class="keyword">type</span> SmartContract <span class="keyword">struct</span> &#123;</span><br><span class="line">   contractapi.Contract</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Next, let’s add a struct <code>Asset</code> to represent simple assets on the ledger. Note the JSON annotations, which will be used to marshal the asset to JSON which is stored on the ledger.</p><p>下一步让我们增加一个<code>Asset</code> 类来表示账本上的简单的资产。请注意JSON注释，该注释将用于将资产编组为存储在分类帐中的JSON。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Asset describes basic details of what makes up a simple asset</span></span><br><span class="line">   <span class="keyword">type</span> Asset <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID             <span class="keyword">string</span> <span class="string">`json:"ID"`</span></span><br><span class="line">    Color          <span class="keyword">string</span> <span class="string">`json:"color"`</span></span><br><span class="line">    Size           <span class="keyword">int</span>    <span class="string">`json:"size"`</span></span><br><span class="line">    Owner          <span class="keyword">string</span> <span class="string">`json:"owner"`</span></span><br><span class="line">    AppraisedValue <span class="keyword">int</span>    <span class="string">`json:"appraisedValue"`</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Initializing-the-Chaincode-初始化链码">Initializing the Chaincode(初始化链码)</h3><p>Next, we’ll implement the <code>InitLedger</code> function to populate the ledger with some initial data.</p><p>接下来我们实现<code>InitLedger</code> 方法，这个方法使用一些初始化的数据来填充账本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InitLedger adds a base set of assets to the ledger</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">InitLedger</span><span class="params">(ctx contractapi.TransactionContextInterface)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">      assets := []Asset&#123;</span><br><span class="line">        &#123;ID: <span class="string">"asset1"</span>, Color: <span class="string">"blue"</span>, Size: <span class="number">5</span>, Owner: <span class="string">"Tomoko"</span>, AppraisedValue: <span class="number">300</span>&#125;,</span><br><span class="line">        &#123;ID: <span class="string">"asset2"</span>, Color: <span class="string">"red"</span>, Size: <span class="number">5</span>, Owner: <span class="string">"Brad"</span>, AppraisedValue: <span class="number">400</span>&#125;,</span><br><span class="line">        &#123;ID: <span class="string">"asset3"</span>, Color: <span class="string">"green"</span>, Size: <span class="number">10</span>, Owner: <span class="string">"Jin Soo"</span>, AppraisedValue: <span class="number">500</span>&#125;,</span><br><span class="line">        &#123;ID: <span class="string">"asset4"</span>, Color: <span class="string">"yellow"</span>, Size: <span class="number">10</span>, Owner: <span class="string">"Max"</span>, AppraisedValue: <span class="number">600</span>&#125;,</span><br><span class="line">        &#123;ID: <span class="string">"asset5"</span>, Color: <span class="string">"black"</span>, Size: <span class="number">15</span>, Owner: <span class="string">"Adriana"</span>, AppraisedValue: <span class="number">700</span>&#125;,</span><br><span class="line">        &#123;ID: <span class="string">"asset6"</span>, Color: <span class="string">"white"</span>, Size: <span class="number">15</span>, Owner: <span class="string">"Michel"</span>, AppraisedValue: <span class="number">800</span>&#125;,</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, asset := <span class="keyword">range</span> assets &#123;</span><br><span class="line">      assetJSON, err := json.Marshal(asset)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      err = ctx.GetStub().PutState(asset.ID, assetJSON)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to put to world state. %v"</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Next, we write a function to create an asset on the ledger that does not yet exist. When writing chaincode, it is a good idea to check for the existence of something on the ledger prior to taking an action on it, as is demonstrated in the <code>CreateAsset</code> function below.</p><p>接下来，我们写一个创建一个账本上不存在的资产的方法。当编写链码时，最好先对分类帐进行检查，然后再对其进行操作，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编写您的第一个Chaincode&lt;/p&gt;
&lt;h2 id=&quot;Asset-Transfer-Chaincode（资产交易智能合约）&quot;&gt;Asset Transfer Chaincode（资产交易智能合约）&lt;/h2&gt;
&lt;p&gt;Our application is a basic sa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>others/Docker常用命令记录</title>
    <link href="https://nijixucai.github.io/2020/12/21/others/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
    <id>https://nijixucai.github.io/2020/12/21/others/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</id>
    <published>2020-12-21T03:52:27.579Z</published>
    <updated>2020-12-22T08:15:49.314Z</updated>
    
    <content type="html"><![CDATA[<p>Docker常用命令记录</p><h3 id="删除本地所有没有被使用的卷：">删除本地所有没有被使用的卷：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure><p>WARNING! This will remove all local volumes not used by at least one container.</p><h3 id="查看本地的所有卷：">查看本地的所有卷：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><h3 id="查看所有的容器，包括没有运行中的">查看所有的容器，包括没有运行中的</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Docker常用命令记录&lt;/p&gt;
&lt;h3 id=&quot;删除本地所有没有被使用的卷：&quot;&gt;删除本地所有没有被使用的卷：&lt;/h3&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/fabric/将智能合约部署到通道</title>
    <link href="https://nijixucai.github.io/2020/12/18/blockchain/fabric/%E5%B0%86%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%83%A8%E7%BD%B2%E5%88%B0%E9%80%9A%E9%81%93/"/>
    <id>https://nijixucai.github.io/2020/12/18/blockchain/fabric/%E5%B0%86%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%83%A8%E7%BD%B2%E5%88%B0%E9%80%9A%E9%81%93/</id>
    <published>2020-12-18T02:58:46.693Z</published>
    <updated>2020-12-21T10:29:47.294Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deploy_chaincode.html" target="_blank" rel="noopener">参考文档</a></p><h1 id="Deploying-a-smart-contract-to-a-channel（将智能合约部署到通道）">Deploying a smart contract to a channel（将智能合约部署到通道）</h1><p>最终用户通过调用智能合约与区块链账本进行交互。在Hyperledger Fabric中，智能合约通过称为chaincode的软件包进行部署。一个组织想要验证交易或者查询账本的内容，就需要在其peer节点上部署chaincode。当一个已经安装了chaincode的节点加入channel之后，channel的成员就可以把chaincode部署到channel上，然后使用chaincode上的智能合约来创建和更新chanel账本上的资产。</p><p>我们使用一个叫做Fabric链码生命周期的程序来将chaincode部署到channel上；在链码可以被使用于交易之前，Fabric链码生命周期需要多个组织同意链码将如何操作。（<em>个人理解：需要组织同意智能合约的内容，智能合约才能部署到channel上</em>）举个例子，当一个背书策略制定哪些组织需要执行chaincode来验证一个交易时，channel上的成员需要使用Fabric链码生命周期来同意链码的背书策略。有关如何在通道上部署和管理链码的更深入的概述，请参阅<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/chaincode_lifecycle.html" target="_blank" rel="noopener">Fabric chaincode lifecycle</a>。</p><p>你可以使用 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html" target="_blank" rel="noopener">peer lifecycle chaincode commands</a>这个教程来学习在Fabric测试网络中如何使用peer lifecycle chaincode commands来部署链码到channel。了解命令后，您可以使用本教程中的步骤将自己的链码部署到测试或生产网络。在这个教程中，你会部署教程<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/write_first_app.html" target="_blank" rel="noopener">Writing your first application tutorial</a>使用的链码程序。</p><p>**注意：**当前教程使用v2.0版本中引入的Fabric链码生命周期。</p><h2 id="Start-the-network（启动测试网络）">Start the network（启动测试网络）</h2><p>启动测试网络并创建channel，具体步骤参考<a href="Fabric%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8.md">Fabric测试网络使用</a>。</p><p>你可以根据以下步骤使用节点的CLI来部署 asset-transfer (basic) 链码到channel中：</p><ul><li>[第一步：打包智能合约]</li><li>[第二步：安装链码包]</li><li>[第三步：批准链码定义]</li><li>[第四部：提交链码定义到channel中]</li></ul><h2 id="Setup-Logspout-optional-（启动日志输出，可选）">Setup Logspout (optional)（启动日志输出，可选）</h2><p>此步骤不是必需的，但是对于故障排除链码非常有用。要监视智能合约的日志，管理员可以使用<a href="https://logdna.com/blog/what-is-logspout/" target="_blank" rel="noopener">logspout</a>查看一组Docker容器的聚合输出。这个工具收集不同的Docker容器的输出流到一个位置，这样就可以在一个窗口看这些容器都发生了什么。这可以帮助管理员在安装智能合约或者是开发人员调用智能合约时调试问题。因为某些容器的创建纯粹是为了启动智能合约，并且仅存在很短的时间，所以从网络中收集所有日志将很有帮助。</p><p><a href="http://xn--FabricLogspoutmonitordocker-8c86b0p99fdhu31ag34avvicndd5i2t1e0etn22cmk5an23jl6lva1361ad0b263jzdgipw4t2gbf9d.sh" target="_blank" rel="noopener">Fabric的商业票据示例中已经包含了用于安装和配置Logspout的脚本monitordocker.sh</a>。在本教程中，我们还将使用相同的脚本。Logspout工具将持续向您的终端流式传输日志，因此您将需要使用新的终端窗口。打开一个新终端，然后导航到test-network目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd fabric-samples/test-network</span><br></pre></td></tr></table></figure><p>你可以在任何目录下运行 <code>monitordocker.sh</code>脚本，为了方便使用我们把 <code>monitordocker.sh</code> 从<code>commercial-paper</code>拷贝到你的工作目录(test-network)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ../commercial-paper/organization/digibank/configuration/cli/monitordocker.sh .</span><br></pre></td></tr></table></figure><p>你可以使用下面的命令来启动Logspout：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./monitordocker.sh net_test</span><br></pre></td></tr></table></figure><p>你会看到类似下面的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Starting monitoring on all containers on the network net_basic</span><br><span class="line">Unable to find image 'gliderlabs/logspout:latest' locally</span><br><span class="line">latest: Pulling from gliderlabs/logspout</span><br><span class="line">4fe2ade4980c: Pull complete</span><br><span class="line">decca452f519: Pull complete</span><br><span class="line">ad60f6b6c009: Pull complete</span><br><span class="line">Digest: sha256:374e06b17b004bddc5445525796b5f7adb8234d64c5c5d663095fccafb6e4c26</span><br><span class="line">Status: Downloaded newer image for gliderlabs/logspout:latest</span><br><span class="line">1f99d130f15cf01706eda3e1f040496ec885036d485cb6bcc0da4a567ad84361</span><br></pre></td></tr></table></figure><p>在我们部署链码之前你不会看到太多的日志。</p><h2 id="Package-the-smart-contract（打包智能合约）">Package the smart contract（打包智能合约）</h2><p>We need to package the chaincode before it can be installed on our peers. The steps are different if you want to install a smart contract written in <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deploy_chaincode.html#go" target="_blank" rel="noopener">Go</a>, <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deploy_chaincode.html#javascript" target="_blank" rel="noopener">JavaScript</a>, or <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deploy_chaincode.html#typescript" target="_blank" rel="noopener">Typescript</a>.</p><p>在把智能合约安装到我们的节点之前需要先将其打包。根据编写智能合约的语言的不同，其步骤也是不一样的。（<em>本次只使用Go，其他语言如<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deploy_chaincode.html#go" target="_blank" rel="noopener">Go</a>, <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deploy_chaincode.html#javascript" target="_blank" rel="noopener">JavaScript</a>, or <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deploy_chaincode.html#typescript" target="_blank" rel="noopener">Typescript</a>请参考官方文档</em>）</p><h3 id="Go">Go</h3><p>在我们打包链码之前，我们需要先安装链码的依赖。切换到Go版本的 asset-transfer (basic) 项目目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd fabric-samples/asset-transfer-basic/chaincode-go</span><br></pre></td></tr></table></figure><p>该示例使用Go模块来安装chaincode依赖项。依赖关系列在asset-transfer-basic / chaincode-go目录的go.mod文件中。您应该花一点时间来检查此文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module github.com/hyperledger/fabric-samples/asset-transfer-basic/chaincode-<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        github.com/golang/protobuf v1<span class="number">.3</span><span class="number">.2</span></span><br><span class="line">        github.com/hyperledger/fabric-chaincode-<span class="keyword">go</span> v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200424173110</span>-d7076418f212</span><br><span class="line">        github.com/hyperledger/fabric-contract-api-<span class="keyword">go</span> v1<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">        github.com/hyperledger/fabric-protos-<span class="keyword">go</span> v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200424173316</span>-dd554ba3746e</span><br><span class="line">        github.com/stretchr/testify v1<span class="number">.5</span><span class="number">.1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>go.mod文件将Fabric合约API导入到智能合约包中。你可以打开<code>asset-transfer-basic/chaincode-go/chaincode/smartcontract.go</code>来查看在智能合约的最开始是如使用contract API来定义<code>SmartContract</code>类的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SmartContract provides functions for managing an Asset</span></span><br><span class="line"><span class="keyword">type</span> SmartContract <span class="keyword">struct</span> &#123;</span><br><span class="line">    contractapi.Contract</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将SmartContract类型用于为智能合约中定义的方法创建交易上下文，该方法可将数据读取和写入区块链账本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// CreateAsset issues a new asset to the world state with given details.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartContract)</span> <span class="title">CreateAsset</span><span class="params">(ctx contractapi.TransactionContextInterface, id <span class="keyword">string</span>, color <span class="keyword">string</span>, size <span class="keyword">int</span>, owner <span class="keyword">string</span>, appraisedValue <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">exists, err := s.AssetExists(ctx, id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"the asset %s already exists"</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asset := Asset&#123;</span><br><span class="line">ID:             id,</span><br><span class="line">Color:          color,</span><br><span class="line">Size:           size,</span><br><span class="line">Owner:          owner,</span><br><span class="line">AppraisedValue: appraisedValue,</span><br><span class="line">&#125;</span><br><span class="line">assetJSON, err := json.Marshal(asset)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx.GetStub().PutState(id, assetJSON)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以通过访问 <a href="https://github.com/hyperledger/fabric-contract-api-go" target="_blank" rel="noopener">API documentation</a> 和 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/developapps/smartcontract.html" target="_blank" rel="noopener">smart contract processing topic</a>来学习更多的关于合约API的内容。</p><p>为了安装智能合约的依赖，在<code>asset-transfer-basic/chaincode-go</code> 目录下运行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GO111MODULE=on go mod vendor</span><br></pre></td></tr></table></figure><p>如果命令成功，则go软件包将安装vendor文件夹中。</p><p>现在我们已经有了依赖的包，我们可以创建chaincode的包了。把当前目录切换到<code>test-network</code> 以便我们可以将链码于其他网络组件打包在一起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..&#x2F;..&#x2F;test-network</span><br></pre></td></tr></table></figure><p>You can use the <code>peer</code> CLI to create a chaincode package in the required format. The <code>peer</code> binaries are located in the <code>bin</code> folder of the <code>fabric-samples</code> repository. Use the following command to add those binaries to your CLI Path:</p><p>您可以使用<code>peer</code>CLI创建所需格式的链码包。<code>peer</code>二进制文件位于fabric-samples存储库的bin文件夹中。可以使用下面的命令添加到你的环境变量中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;PWD&#125;/../bin:$PATH</span><br></pre></td></tr></table></figure><p>您还需要将FABRIC_CFG_PATH设置为指向fabric-samples存储库中的core.yaml文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export FABRIC_CFG_PATH=$PWD/../config/</span><br></pre></td></tr></table></figure><p>使用下面的命令来查看peer的版本，如果输出正常说明你已经可以使用<code>peer</code>CLI了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer version</span><br></pre></td></tr></table></figure><p>You can now create the chaincode package using the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-package" target="_blank" rel="noopener">peer lifecycle chaincode package</a> command:</p><p>现在你可以通过 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-package" target="_blank" rel="noopener">peer lifecycle chaincode package</a> 命令来创建链码包了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode package basic.tar.gz --path ../asset-transfer-basic/chaincode-go/ --lang golang --label basic_1.0</span><br></pre></td></tr></table></figure><p>This command will create a package named <code>basic.tar.gz</code> in your current directory. The <code>--lang</code> flag is used to specify the chaincode language and the <code>--path</code> flag provides the location of your smart contract code. The path must be a fully qualified path or a path relative to your present working directory. The <code>--label</code> flag is used to specify a chaincode label that will identity your chaincode after it is installed. It is recommended that your label include the chaincode name and version.</p><p>这个命令会在你的当前目录下创建一个名为<code>basic.tar.gz</code>的压缩包。<code>--lang</code>标志是制定chaincode的语言，而<code>--path</code> 标志用于提供智能合约代码的位置。该路径必须是标准路径或相对于您当前工作目录的路径。<code>--label</code>标志用于指定一个链码标签，该标签将在安装链码后对其进行标识。建议您的标签包含链码名称和版本。</p><p>Now that we created the chaincode package, we can <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deploy_chaincode.html#install-the-chaincode-package" target="_blank" rel="noopener">install the chaincode</a> on the peers of the test network.</p><p>现在我们已经创建了链码包，我们可以把链码安装到网络上的节点上了。</p><h2 id="Install-the-chaincode-package（安装链码包）">Install the chaincode package（安装链码包）</h2><p>After we package the asset-transfer (basic) smart contract, we can install the chaincode on our peers. The chaincode needs to be installed on every peer that will endorse a transaction. Because we are going to set the endorsement policy to require endorsements from both Org1 and Org2, we need to install the chaincode on the peers operated by both organizations:</p><p>在我们打包了 asset-transfer (basic) 的智能合约之后，我们就可以将此链码安装到我们的peer节点上了。需要在所有的交易背书节点上安装链码。因为我们将设置背书策略要求来自Org1和Org2的背书，所以我们需要在两个组织运营的对等方上安装链码：</p><ul><li><a href="http://peer0.org1.example.com" target="_blank" rel="noopener">peer0.org1.example.com</a></li><li><a href="http://peer0.org2.example.com" target="_blank" rel="noopener">peer0.org2.example.com</a></li></ul><p>Let’s install the chaincode on the Org1 peer first. Set the following environment variables to operate the <code>peer</code> CLI as the Org1 admin user. The <code>CORE_PEER_ADDRESS</code> will be set to point to the Org1 peer, <code>peer0.org1.example.com</code>.</p><p>让我们先把链码安装到Org1的节点上。设置以下环境变量来使用Org1的admin用户的身份运行<code>peer</code>CLI。将CORE_PEER_ADDRESS设置为指向Org1的节点的<code>peer0.org1.example.com</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export CORE_PEER_TLS_ENABLED=true</span><br><span class="line">export CORE_PEER_LOCALMSPID="Org1MSP"</span><br><span class="line">export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line">export CORE_PEER_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line">export CORE_PEER_ADDRESS=localhost:7051</span><br></pre></td></tr></table></figure><p>Issue the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-install" target="_blank" rel="noopener">peer lifecycle chaincode install</a> command to install the chaincode on the peer:</p><p>发出在peer节点上安装链码的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode install basic.tar.gz</span><br></pre></td></tr></table></figure><p>If the command is successful, the peer will generate and return the package identifier. This package ID will be used to approve the chaincode in the next step. You should see output similar to the following:</p><p>如果命令执行成功，则peer将生成并返回安装包的标识符。这个包的ID会在下一步批准这个链码时使用。你会看到类似下面的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-12-21 14:46:18.360 CST [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 001 Installed remotely: response:&lt;status:200 payload:"\nJbasic_1.0:2c47b5b060a64aafa3c878b4bcb0ca680bdb2417ca8855b5440fa595562517d2\022\tbasic_1.0" &gt;</span><br><span class="line">2020-12-21 14:46:18.361 CST [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 002 Chaincode code package identifier: basic_1.0:2c47b5b060a64aafa3c878b4bcb0ca680bdb2417ca8855b5440fa595562517d2</span><br></pre></td></tr></table></figure><p>在运行<code>monitordocker.sh</code>的终端可以看到下面的日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peer0.org1.example.com|2020-12-21 06:46:18.363 UTC [lifecycle] InstallChaincode -&gt; INFO 046 Successfully installed chaincode with package ID 'basic_1.0:2c47b5b060a64aafa3c878b4bcb0ca680bdb2417ca8855b5440fa595562517d2'</span><br><span class="line">peer0.org1.example.com|2020-12-21 06:46:18.363 UTC [endorser] callChaincode -&gt; INFO 047 finished chaincode: _lifecycle duration: 35751ms channel= txID=26a66cb7</span><br><span class="line">peer0.org1.example.com|2020-12-21 06:46:18.363 UTC [comm.grpc.server] 1 -&gt; INFO 048 unary call completed grpc.service=protos.Endorser grpc.method=ProcessProposal grpc.peer_address=172.19.0.1:62970 grpc.code=OK grpc.call_duration=35.752599039s</span><br></pre></td></tr></table></figure><p>We can now install the chaincode on the Org2 peer. Set the following environment variables to operate as the Org2 admin and target target the Org2 peer, <a href="http://peer0.org2.example.com" target="_blank" rel="noopener">peer0.org2.example.com</a>.</p><p>现在我们把链码安装到Org2组织的peer节点上。先设置环境变量让我们可以以Org2的管理员身份来操作Org2的节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export CORE_PEER_LOCALMSPID="Org2MSP"</span><br><span class="line">export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br><span class="line">export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br><span class="line">export CORE_PEER_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span><br><span class="line">export CORE_PEER_ADDRESS=localhost:9051</span><br></pre></td></tr></table></figure><p>Issue the following command to install the chaincode（发出以下命令来安装链码）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode install basic.tar.gz</span><br></pre></td></tr></table></figure><p>The chaincode is built by the peer when the chaincode is installed. The install command will return any build errors from the chaincode if there is a problem with the smart contract code.</p><p>在安装链码时，由peer节点来构建链码。如果智能合约有问题，安装命令会把所有构建的错误返回。</p><h2 id="Approve-a-chaincode-definition（批准链码定义）">Approve a chaincode definition（批准链码定义）</h2><p>After you install the chaincode package, you need to approve a chaincode definition for your organization. The definition includes the important parameters of chaincode governance such as the name, version, and the chaincode endorsement policy.</p><p>在安装链码包之后，需要你所在的组织批准链码的定义。这个定义包括链码管理的重要参数，例如名称、版本以及链码的背书策略。</p><p>The set of channel members who need to approve a chaincode before it can be deployed is governed by the <code>Application/Channel/lifeycleEndorsement</code> <a href="http://policy.By" target="_blank" rel="noopener">policy.By</a> default, this policy requires that a majority of channel members need to approve a chaincode before it can used on a channel.Because we have only two organizations on the channel, and a majority of 2 is 2, we need approve a chaincode definition of asset-transfer (basic) as Org1 and Org2.</p><p>在channel上的哪些成员需要在其可以部署链码之前批准，是定义在<code>Application/Channel/lifeycleEndorsement</code>策略中。默认情况下，此策略要求大多数channel的成员需要批准链码后才能在频道上使用。因为在我们的channel上只有两个组织，并且大多数就是2，我们需要以Org1和Org2的身份来批准asset-transfer (basic)的链码定义。</p><p>If an organization has installed the chaincode on their peer, they need to include the packageID in the chaincode definition approved by their organization. The package ID is used to associate the chaincode installed on a peer with an approved chaincode definition, and allows an organization to use the chaincode to endorse transactions. You can find the package ID of a chaincode by using the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-queryinstalled" target="_blank" rel="noopener">peer lifecycle chaincode queryinstalled</a> command to query your peer.</p><p>如果一个组织已经在其peer节点上安装了链码，这个组织需要在其批准的链码定义中包含packageID。packageID是用来把安装在节点上的chaincode和已经批准通过的链码定义关联起来的，并且允许一个组织在背书节点使用这个链码。你可以使用<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-queryinstalled" target="_blank" rel="noopener">peer lifecycle chaincode queryinstalled</a> 命令在你的peer节点上查询一个链码的packageID。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode queryinstalled</span><br></pre></td></tr></table></figure><p>The package ID is the combination of the chaincode label and a hash of the chaincode binaries. Every peer will generate the same package ID. You should see output similar to the following:</p><p>packageID是链码标签和链码二进制文件的哈希值的组合。每个peer将生成相同的程序包ID。您应该看到类似于以下内容的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Installed chaincodes on peer:</span><br><span class="line">Package ID: basic_1.0:2c47b5b060a64aafa3c878b4bcb0ca680bdb2417ca8855b5440fa595562517d2, Label: basic_1.0</span><br></pre></td></tr></table></figure><p>We are going to use the package ID when we approve the chaincode, so let’s go ahead and save it as an environment variable. Paste the package ID returned by <code>peer lifecycle chaincode queryinstalled</code> into the command below. <strong>Note:</strong> The package ID will not be the same for all users, so you need to complete this step using the package ID returned from your command window in the previous step.</p><p>在我们批准链码时我们需要使用这个 package ID，所以让我们先把它保存为一个环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CC_PACKAGE_ID=basic_1.0:2c47b5b060a64aafa3c878b4bcb0ca680bdb2417ca8855b5440fa595562517d2</span><br></pre></td></tr></table></figure><p>Because the environment variables have been set to operate the <code>peer</code> CLI as the Org2 admin, we can approve the chaincode definition of asset-transfer (basic) as Org2. Chaincode is approved at the organization level, so the command only needs to target one peer. The approval is distributed to the other peers within the organization using gossip. Approve the chaincode definition using the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-approveformyorg" target="_blank" rel="noopener">peer lifecycle chaincode approveformyorg</a> command:</p><p>因为当前的环境变量已经设置为以Org2组织的管理员来操作<code>peer</code>CLI，我们可以以组织Org2的身份批准这个asset-transfer (basic)的链码定义。链码是在组织的级别进行批准的，所以这个命令只需要针对一个peer节点即可。这个批准的动作会使用gossip来在组织内部传播。使用 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-approveformyorg" target="_blank" rel="noopener">peer lifecycle chaincode approveformyorg</a>命令来批准链码定义：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id $CC_PACKAGE_ID --sequence 1 --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure><p>The command above uses the <code>--package-id</code> flag to include the package identifier in the chaincode definition. The <code>--sequence</code> parameter is an integer that keeps track of the number of times a chaincode has been defined or updated. Because the chaincode is being deployed to the channel for the first time, the sequence number is 1. When the asset-transfer (basic) chaincode is upgraded, the sequence number will be incremented to 2. If you are using the low level APIs provided by the Fabric Chaincode Shim API, you could pass the <code>--init-required</code> flag to the command above to request the execution of the Init function to initialize the chaincode. The first invoke of the chaincode would need to target the Init function and include the <code>--isInit</code> flag before you could use the other functions in the chaincode to interact with the ledger.</p><p>上面的命令使用<code>--package-id</code>标志将软件包标识符包含在链码定义中。<code>--sequence</code>参数是一个整数，用于跟踪定义或更新链码的次数；由于链码是第一次部署到channel，因此序列号为1。当asset-transfer (basic) 的链码在更新时，这个序列号会增加到2。链代码的首次调用需要使用<code>--isInit</code>来指明调用链码的Init函数，然后才能使用链代码中的其他函数与账本进行交互。</p><p>We could have provided a <code>--signature-policy</code> or <code>--channel-config-policy</code> argument to the <code>approveformyorg</code> command to specify a chaincode endorsement policy. The endorsement policy specifies how many peers belonging to different channel members need to validate a transaction against a given chaincode. Because we did not set a policy, the definition of asset-transfer (basic) will use the default endorsement policy, which requires that a transaction be endorsed by a majority of channel members present when the transaction is submitted. This implies that if new organizations are added or removed from the channel, the endorsement policy is updated automatically to require more or fewer endorsements. In this tutorial, the default policy will require a majority of 2 out of 2 and transactions will need to be endorsed by a peer from Org1 and Org2. If you want to specify a custom endorsement policy, you can use the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/endorsement-policies.html" target="_blank" rel="noopener">Endorsement Policies</a> operations guide to learn about the policy syntax.</p><p>我们可以在<code>approveformyorg</code>命令中提供<code>--signature-policy</code>或<code>--channel-config-policy</code>参数，以指定链码背书策略。背书策略指定需要多少个属于不同渠道成员的peer根据给定的链码验证来交易。因为我们没有指定合格策略，asset-transfer (basic) 的定义会使用默认的背书策略，该政策要求在提交交易时，该交易必须得到channel中大多数成员的认可。这意味着，如果在channel中添加或删除组织，则背书政策会自动更新，以要求更多或更少的认可。在本教程中，默认策略需要2个中的大多数也就是2，并且交易需要由来自Org1和Org2的peer认可。如果要指定自定义认可策略，则可以使用 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/endorsement-policies.html" target="_blank" rel="noopener">Endorsement Policies</a> 操作指南来了解策略语法。</p><p>You need to approve a chaincode definition with an identity that has an admin role. As a result, the <code>CORE_PEER_MSPCONFIGPATH</code> variable needs to point to the MSP folder that contains an admin identity. You cannot approve a chaincode definition with a client user. The approval needs to be submitted to the ordering service, which will validate the admin signature and then distribute the approval to your peers.</p><p>你需要使用具有管理员角色的身份来批准的链码定义。即<code>CORE_PEER_MSPCONFIGPATH</code>变量需要指向包含管理员身份的MSP文件夹。你不能使用客户端用户的身份来批准链码。这个审批结果需要提交给排序服务，排序服务会验证管理员的签名，然后分发这个验证结果到你的peer节点。</p><p>We still need to approve the chaincode definition as Org1. Set the following environment variables to operate as the Org1 admin:</p><p>你还需要在组织Org1上批准这个链码定义，把环境变量修改为以组织Org1的管理员身份来操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export CORE_PEER_LOCALMSPID="Org1MSP"</span><br><span class="line">export CORE_PEER_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line">export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line">export CORE_PEER_ADDRESS=localhost:7051</span><br></pre></td></tr></table></figure><p>You can now approve the chaincode definition as Org1.</p><p>现在你可以以组织Org1的身份批准链码定义了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id $CC_PACKAGE_ID --sequence 1 --tls --cafile $&#123;PWD&#125;&#x2F;organizations&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure><p>We now have the majority we need to deploy the asset-transfer (basic) the chaincode to the channel. While only a majority of organizations need to approve a chaincode definition (with the default policies), all organizations need to approve a chaincode definition to start the chaincode on their peers. If you commit the definition before a channel member has approved the chaincode, the organization will not be able to endorse transactions. As a result, it is recommended that all channel members approve a chaincode before committing the chaincode definition.</p><p>现在我们已经有了将asset-transfer (basic) 的链码部署到渠道的大多数的批准。在将链码定义部署到channel上时，我们需要大多数组织的批准（使用默认的策略）；但是所有的组织都需批准链码定义才能在其peer启动这个链码。如果你在一个channel成员批准定义之前将链码定义提交到channel，那么这个组织将无法批准交易。结果，建议所有通道成员在提交链码定义之前批准链码。</p><h2 id="Committing-the-chaincode-definition-to-the-channel（将链码定义提交到通道）">Committing the chaincode definition to the channel（将链码定义提交到通道）</h2><p>After a sufficient number of organizations have approved a chaincode definition, one organization can commit the chaincode definition to the channel. If a majority of channel members have approved the definition, the commit transaction will be successful and the parameters agreed to in the chaincode definition will be implemented on the channel.</p><p>在有足够数量的组织批准链码定义之后，其中一个组织就可以把链码定义提交到通道中了。如果大多数通道成员已批准该定义，则提交定义的交易将会成功，并且链码定义中同意的参数将在该通道上实现。</p><p>You can use the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-checkcommitreadiness" target="_blank" rel="noopener">peer lifecycle chaincode checkcommitreadiness</a> command to check whether channel members have approved the same chaincode definition. The flags used for the <code>checkcommitreadiness</code> command are identical to the flags used to approve a chaincode for your organization. However, you do not need to include the <code>--package-id</code> flag.</p><p>你可以使用 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-checkcommitreadiness" target="_blank" rel="noopener">peer lifecycle chaincode checkcommitreadiness</a>命令来检查channel上侧成员是否已经批准了相同的链码定义。用于<code>checkcommitreadiness</code>命令的标志与您的组织批准链码的标志相同；但是不需要包括<code>--package-id</code>标志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --output json</span><br></pre></td></tr></table></figure><p>The command will produce a JSON map that displays if a channel member has approved the parameters that were specified in the <code>checkcommitreadiness</code> command:</p><p>这个命令会生成一个JSON来显示通道成员是否已经批准了定义。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">          <span class="attr">"Approvals"</span>: &#123;</span><br><span class="line">                  <span class="attr">"Org1MSP"</span>: <span class="literal">true</span>,</span><br><span class="line">                  <span class="attr">"Org2MSP"</span>: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Since both organizations that are members of the channel have approved the same parameters, the chaincode definition is ready to be committed to the channel. You can use the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-commit" target="_blank" rel="noopener">peer lifecycle chaincode commit</a> command to commit the chaincode definition to the channel. The commit command also needs to be submitted by an organization admin.</p><p>因为channel上的两个成员都已经批准了相同的参数，因此链码定义已准备好提交给channel。你可以使用<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-commit" target="_blank" rel="noopener">peer lifecycle chaincode commit</a> 命令将链码定义提交到channel。commit命令依然需要由组织管理员来发起。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --peerAddresses localhost:7051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br></pre></td></tr></table></figure><p>The transaction above uses the <code>--peerAddresses</code> flag to target <code>peer0.org1.example.com</code> from Org1 and <code>peer0.org2.example.com</code> from Org2. The <code>commit</code> transaction is submitted to the peers joined to the channel to query the chaincode definition that was approved by the organization that operates the peer. The command needs to target the peers from a sufficient number of organizations to satisfy the policy for deploying a chaincode. Because the approval is distributed within each organization, you can target any peer that belongs to a channel member.</p><p>上面的交易使用<code>--peerAddresses</code>标志来指定Org1中的<code>peer0.org1.example.com</code>和Org2中的<code>peer0.org2.example.com</code>。 <code>commit</code> 交易会提交给已经加入通道的peer节点，用于peer节点查询同组织内其他节点批准的链码定义。该命令需要指明来自足够数量的组织中的peer节点，以满足部署链码的策略。因为批准操作已经在每个组织内部进行广播，所以你可以指定属于一个通道成员的任意的peer节点。</p><p>The chaincode definition endorsements by channel members are submitted to the ordering service to be added to a block and distributed to the channel. The peers on the channel then validate whether a sufficient number of organizations have approved the chaincode definition. The <code>peer lifecycle chaincode commit</code> command will wait for the validations from the peer before returning a response.</p><p>通道成员对链码定义的认可会提交给排序服务，以添加到区块并分发给渠道。然后通道上的peer节点验证是否有足够数量的组织批准了链码定义。<code>peer lifecycle chaincode commit</code>命令在返回相应之前会等待peer节点的验证。</p><p>You can use the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-querycommitted" target="_blank" rel="noopener">peer lifecycle chaincode querycommitted</a> command to confirm that the chaincode definition has been committed to the channel.</p><p>你可以使用 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-querycommitted" target="_blank" rel="noopener">peer lifecycle chaincode querycommitted</a> 命令来确认链码定义已经提交到通道。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode querycommitted --channelID mychannel --name basic --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure><p>If the chaincode was successful committed to the channel, the <code>querycommitted</code> command will return the sequence and version of the chaincode definition:</p><p>如果链码已经成功提交到通道，<code>querycommitted</code> 命令会返回该链码定义的序列号和版本号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Committed chaincode definition for chaincode 'basic' on channel 'mychannel':</span><br><span class="line">Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</span><br></pre></td></tr></table></figure><h2 id="Invoking-the-chaincode（调用链码）">Invoking the chaincode（调用链码）</h2><p>After the chaincode definition has been committed to a channel, the chaincode will start on the peers joined to the channel where the chaincode was installed. The asset-transfer (basic) chaincode is now ready to be invoked by client applications. Use the following command create an initial set of assets on the ledger. Note that the invoke command needs target a sufficient number of peers to meet chaincode endorsement policy.</p><p>在链码定义提交到通道之后，链码可以由加入了通道并且安装了此链码的peer节点来启动。 asset-transfer (basic) 的链码已经可以由客户端程序进行调用。使用以下命令在账本上创建和初始化资产。请注意，invoke命令需要以足够数量的peer为目标，以满足链码的背书策略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c '&#123;"function":"InitLedger","Args":[]&#125;'</span><br></pre></td></tr></table></figure><p>If the command is successful, you should be able to a response similar to the following:</p><p>如果命令执行成功，你会看到类似下面的响应：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-12-21 16:51:11.086 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</span><br></pre></td></tr></table></figure><p>We can use a query function to read the set of cars that were created by the chaincode:</p><p>我们使用查询方法来查看我们通过链码创建的车：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C mychannel -n basic -c '&#123;"Args":["GetAllAssets"]&#125;'</span><br></pre></td></tr></table></figure><p>The response to the query should be the following list of assets:</p><p>下面的资产列表就是查询的响应结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;"ID":"asset1","color":"blue","size":5,"owner":"Tomoko","appraisedValue":300&#125;,&#123;"ID":"asset2","color":"red","size":5,"owner":"Brad","appraisedValue":400&#125;,&#123;"ID":"asset3","color":"green","size":10,"owner":"Jin Soo","appraisedValue":500&#125;,&#123;"ID":"asset4","color":"yellow","size":10,"owner":"Max","appraisedValue":600&#125;,&#123;"ID":"asset5","color":"black","size":15,"owner":"Adriana","appraisedValue":700&#125;,&#123;"ID":"asset6","color":"white","size":15,"owner":"Michel","appraisedValue":800&#125;]</span><br></pre></td></tr></table></figure><h2 id="Upgrading-a-smart-contract（更新智能合约）">Upgrading a smart contract（更新智能合约）</h2><p>You can use the same Fabric chaincode lifecycle process to upgrade a chaincode that has already been deployed to a channel. Channel members can upgrade a chaincode by installing a new chaincode package and then approving a chaincode definition with the new package ID, a new chaincode version, and with the sequence number incremented by one. The new chaincode can be used after the chaincode definition is committed to the channel. This process allows channel members to coordinate on when a chaincode is upgraded, and ensure that a sufficient number of channel members are ready to use the new chaincode before it is deployed to the channel.</p><p>您可以使用相同的Fabric链码生命周期流程来升级已经部署到通道的链码。通道成员可以通过以下方式升级链码：安装新的链码包，然后批准这个具有新packageID、新链码版本以及序列号加1的链码定义。在链码定义被提交给通道后新的链码就可以被使用。此过程允许通道成员在升级链码时进行协调，并确保在将新链码部署到通道之前，有足够数量的通道成员准备使用新链码。</p><p>Channel members can also use the upgrade process to change the chaincode endorsement policy. By approving a chaincode definition with a new endorsement policy and committing the chaincode definition to the channel, channel members can change the endorsement policy governing a chaincode without installing a new chaincode package.</p><p>通道成员也可以使用这个更新流程来修改链码的背书策略。通过批准具有新背书策略的链码定义并将其提交给渠道，渠道成员可以更改背书策略而无需安装新的链码包。</p><p>To provide a scenario for upgrading the asset-transfer (basic) chaincode that we just deployed,let’s assume that Org1 and Org2 would like to install a version of the chaincode that is written in another language. They will use the Fabric chaincode lifecycle to update the chaincode version and ensure that both organizations have installed the new chaincode before it becomes active on the channel.</p><p>为了提供一个我们刚才部署的asset-transfer (basic) 链码升级的情景，让我们假设Org1和Org2想要安装一个通过其他语言编写的链码版本。他们会使用Fabric链码生命周期来更新链码的版本并且在新链码可用于通道之前确保所有的组织已经安装了新的链码。</p><p>We are going to assume that Org1 and Org2 initially installed the GO version of the asset-transfer (basic) chaincode, but would be more comfortable working with a chaincode written in JavaScript. The first step is to package the JavaScript version of the asset-transfer (basic) chaincode. If you used the JavaScript instructions to package your chaincode when you went through the tutorial, you can install new chaincode binaries by following the steps for packaging a chaincode written in <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deploy_chaincode.html#go" target="_blank" rel="noopener">Go</a> or <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/deploy_chaincode.html#typescript" target="_blank" rel="noopener">TypeScript</a>.</p><p>我们假设Org1和Org2最初安装了asset-transfer (basic) GO版本的链码，但使用JavaScript编写的链码会更舒适。第一步就是打包JavaScript版本的asset-transfer (basic) 链码。</p><p>Issue the following commands from the <code>test-network</code> directory to install the chaincode dependences.</p><p>在<code>test-network</code> 目录下运行下面的命令来安装链码的依赖。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ../asset-transfer-basic/chaincode-javascript</span><br><span class="line">npm install</span><br><span class="line">cd ../../test-network</span><br></pre></td></tr></table></figure><p>You can then issue the following commands to package the JavaScript chaincode from the <code>test-network</code> directory. We will set the environment variables needed to use the <code>peer</code> CLI again in case you closed your terminal.</p><p>然后你可以在<code>test-network</code> 目录下运行下面的命令来打包JavaScript版本的链码。在运行命令之前先参考前面的内容来设置可以操作Org1的环境变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode package basic_2.tar.gz --path ../asset-transfer-basic/chaincode-javascript/ --lang node --label basic_2.0</span><br></pre></td></tr></table></figure><p>We can now use the following command to install the new chaincode package on the Org1 peer.</p><p>你可以在Org1组织的peer节点通过下面的命令来安装一个新的链码包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode install basic_2.tar.gz</span><br></pre></td></tr></table></figure><p>The new chaincode package will create a new package ID. We can find the new package ID by querying our peer.</p><p>新的链码包会创建一个新的package ID，我们通过查询peer来获取新的package ID。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode queryinstalled</span><br></pre></td></tr></table></figure><p>The <code>queryinstalled</code> command will return a list of the chaincode that have been installed on your peer similar to this output.</p><p><code>queryinstalled</code> 命令会返回你的peer已经安装的链码，输出类似如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Installed chaincodes on peer:</span><br><span class="line">Package ID: basic_1.0:2c47b5b060a64aafa3c878b4bcb0ca680bdb2417ca8855b5440fa595562517d2, Label: basic_1.0</span><br><span class="line">Package ID: basic_2.0:59cb45985332d79a903ef39d710eeb23a1c63bddaf8cd999481071457d22acbd, Label: basic_2.0</span><br></pre></td></tr></table></figure><p>You can use the package label to find the package ID of the new chaincode and save it as a new environment variable. This output is for example only – your package ID will be different, so DO NOT COPY AND PASTE!</p><p>你可以把新的 package ID保存为一个新的环境变量。下面的命令只是一个例子，不要直接copy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export NEW_CC_PACKAGE_ID&#x3D;basic_2.0:59cb45985332d79a903ef39d710eeb23a1c63bddaf8cd999481071457d22acbd</span><br></pre></td></tr></table></figure><p>Org1 can now approve a new chaincode definition（Org1现在可以批准这个新的链码定义）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 2.0 --package-id $NEW_CC_PACKAGE_ID --sequence 2 --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure><p>The new chaincode definition uses the package ID of the JavaScript chaincode package and updates the chaincode version. Because the sequence parameter is used by the Fabric chaincode lifecycle to keep track of chaincode upgrades, Org1 also needs to increment the sequence number from 1 to 2. You can use the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-querycommitted" target="_blank" rel="noopener">peer lifecycle chaincode querycommitted</a> command to find the sequence of the chaincode that was last committed to the channel.</p><p>新的链码定义使用JavaScript版本的链码包的packageID以及新的链码版本。由于Fabric链码生命周期使用序列号来跟踪链码升级，因此Org1还需要将序列号从1递增到2。你可以使用 <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-querycommitted" target="_blank" rel="noopener">peer lifecycle chaincode querycommitted</a>命令来查询链码上次提交到通道的序列号。</p><p>We now need to install the chaincode package and approve the chaincode definition as Org2 in order to upgrade the chaincode. Run the following commands to operate the <code>peer</code> CLI as the Org2 admin:</p><p>我们现在需要以Org2组织的身份来安装链码并且批准链码定义来更新链码，运行下面的命令来使用Org2组织的管理员进行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export CORE_PEER_LOCALMSPID="Org2MSP"</span><br><span class="line">export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br><span class="line">export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br><span class="line">export CORE_PEER_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span><br><span class="line">export CORE_PEER_ADDRESS=localhost:9051</span><br></pre></td></tr></table></figure><p>We can now use the following command to install the new chaincode package on the Org2 peer.</p><p>我们现在就可以使用下面的命令来安装新的链码包到Org2组织的peer上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode install basic_2.tar.gz</span><br></pre></td></tr></table></figure><p>You can now approve the new chaincode definition for Org2.</p><p>我们现在可以为Org2组织批准这个新的链码定义。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 2.0 --package-id $NEW_CC_PACKAGE_ID --sequence 2 --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br></pre></td></tr></table></figure><p>Use the <a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-checkcommitreadiness" target="_blank" rel="noopener">peer lifecycle chaincode checkcommitreadiness</a> command to check if the chaincode definition with sequence 2 is ready to be committed to the channel:</p><p>使用<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#peer-lifecycle-chaincode-checkcommitreadiness" target="_blank" rel="noopener">peer lifecycle chaincode checkcommitreadiness</a> 敏玲来检查序列号为2的链码定义是否已经准备好被提交到channel上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 2.0 --sequence 2 --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --output json</span><br></pre></td></tr></table></figure><p>The chaincode is ready to be upgraded if the command returns the following JSON:</p><p>如果这个命令返回以下内容，说明已经准备好更新了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">"approvals": &#123;</span><br><span class="line">"Org1MSP": true,</span><br><span class="line">"Org2MSP": true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The chaincode will be upgraded on the channel after the new chaincode definition is committed. Until then, the previous chaincode will continue to run on the peers of both organizations. Org2 can use the following command to upgrade the chaincode:</p><p>在新的链码定义提交后，通道上的链码将会升级。在此之前，先前的链码将继续在两个组织的peer上运行。Org2组织可以使用下面的命令来更新链码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 2.0 --sequence 2 --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --peerAddresses localhost:7051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br></pre></td></tr></table></figure><p>A successful commit transaction will start the new chaincode right away. If the chaincode definition changed the endorsement policy, the new policy would be put in effect.</p><p>成功的提交的交易将立即启动新的链码。如果链码定义更改了背书策略，则新政策将生效。</p><p>You can use the <code>docker ps</code> command to verify that the new chaincode has started on your peers:</p><p>你现在可以使用 <code>docker ps</code> 命令来验证新的链码已经在你的peer节点启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE                                                                                                                                                                    COMMAND                  CREATED         STATUS         PORTS                              NAMES</span><br><span class="line">2e253d5141c3   dev-peer0.org2.example.com-basic_2.0-59cb45985332d79a903ef39d710eeb23a1c63bddaf8cd999481071457d22acbd-c00efc2e7c009601f23247ba3330c47fc5b737d476f8233da9b404c28681847b   "docker-entrypoint.s…"   2 minutes ago   Up 2 minutes                                      dev-peer0.org2.example.com-basic_2.0-59cb45985332d79a903ef39d710eeb23a1c63bddaf8cd999481071457d22acbd</span><br><span class="line">cb7260fc3aa6   dev-peer0.org1.example.com-basic_2.0-59cb45985332d79a903ef39d710eeb23a1c63bddaf8cd999481071457d22acbd-ececda85b7ddf5cad9e5cbca808ffe76bc0b4b0d3067c345afa365a764b062ff   "docker-entrypoint.s…"   2 minutes ago   Up 2 minutes                                      dev-peer0.org1.example.com-basic_2.0-59cb45985332d79a903ef39d710eeb23a1c63bddaf8cd999481071457d22acbd</span><br><span class="line">ee12e6769e93   gliderlabs/logspout                                                                                                                                                      "/bin/logspout"          6 hours ago     Up 6 hours     127.0.0.1:8000-&gt;80/tcp             logspout</span><br><span class="line">628b12f2b3f0   hyperledger/fabric-peer:latest                                                                                                                                           "peer node start"        6 hours ago     Up 6 hours     7051/tcp, 0.0.0.0:9051-&gt;9051/tcp   peer0.org2.example.com</span><br><span class="line">e47cbd1b0b15   hyperledger/fabric-peer:latest                                                                                                                                           "peer node start"        6 hours ago     Up 6 hours     0.0.0.0:7051-&gt;7051/tcp             peer0.org1.example.com</span><br><span class="line">e67946f412a7   hyperledger/fabric-orderer:latest                                                                                                                                        "orderer"                6 hours ago     Up 6 hours     0.0.0.0:7050-&gt;7050/tcp             orderer.example.com</span><br></pre></td></tr></table></figure><p>If you used the <code>--init-required</code> flag, you need to invoke the Init function before you can use the upgraded chaincode. Because we did not request the execution of Init, we can test our new JavaScript chaincode by creating a new car:</p><p>我们现在可以通过创建一个新的汽车来测试我们新的JavaScript版本的链码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c '&#123;"function":"CreateAsset","Args":["asset8","blue","16","Kelley","750"]&#125;'</span><br></pre></td></tr></table></figure><p>You can query all the cars on the ledger again to see the new car:</p><p>你可以查询账本上所有的车来看新创建的car：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C mychannel -n basic -c '&#123;"Args":["GetAllAssets"]&#125;'</span><br></pre></td></tr></table></figure><p>You should see the following result from the JavaScript chaincode:</p><p>通过JavaScript版本的链码，你会看到下面的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;"Key":"asset1","Record":&#123;"ID":"asset1","color":"blue","size":5,"owner":"Tomoko","appraisedValue":300&#125;&#125;,&#123;"Key":"asset2","Record":&#123;"ID":"asset2","color":"red","size":5,"owner":"Brad","appraisedValue":400&#125;&#125;,&#123;"Key":"asset3","Record":&#123;"ID":"asset3","color":"green","size":10,"owner":"Jin Soo","appraisedValue":500&#125;&#125;,&#123;"Key":"asset4","Record":&#123;"ID":"asset4","color":"yellow","size":10,"owner":"Max","appraisedValue":600&#125;&#125;,&#123;"Key":"asset5","Record":&#123;"ID":"asset5","color":"black","size":15,"owner":"Adriana","appraisedValue":700&#125;&#125;,&#123;"Key":"asset6","Record":&#123;"ID":"asset6","color":"white","size":15,"owner":"Michel","appraisedValue":800&#125;&#125;,&#123;"Key":"asset8","Record":&#123;"ID":"asset8","Color":"blue","Size":"16","Owner":"Kelley","AppraisedValue":"750"&#125;&#125;]</span><br></pre></td></tr></table></figure><h2 id="Clean-up（清理）">Clean up（清理）</h2><p>When you are finished using the chaincode, you can also use the following commands to remove the Logspout tool.</p><p>当你使用链码结束之后，你可以通过下面的命令来移除Logspout tool。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop logspout</span><br><span class="line">docker rm logspout</span><br></pre></td></tr></table></figure><p>You can then bring down the test network by issuing the following command from the <code>test-network</code> directory:</p><p>你现在可以在<code>test-network</code> 目录下使用下面的命令来关闭测试网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh down</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/release-2.2/deploy_chaincode.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/fabric/Hyberledger-Fabric学习总结</title>
    <link href="https://nijixucai.github.io/2020/12/18/blockchain/fabric/Hyberledger-Fabric%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://nijixucai.github.io/2020/12/18/blockchain/fabric/Hyberledger-Fabric%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2020-12-18T02:53:46.444Z</published>
    <updated>2020-12-22T08:15:50.750Z</updated>
    
    <content type="html"><![CDATA[<p><a href="Fabric%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%A2%B3%E7%90%86.md">Fabric核心概念学习与梳理</a></p><p><a href="Fabric%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8.md">Fabric测试网络使用</a></p><p><a href="%E5%B0%86%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%83%A8%E7%BD%B2%E5%88%B0%E9%80%9A%E9%81%93.md">将智能合约部署到通道</a></p><p><a href="Frbirc%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95.md">Frbirc测试环境错误记录</a></p><p><a href="%E7%BC%96%E5%86%99%E6%82%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAChaincode.md">编写您的第一个Chaincode</a></p><p><a href="%E9%80%9A%E8%BF%87%E4%BE%9B%E5%BA%94%E9%93%BE%E9%87%91%E8%9E%8D%E7%BB%83%E4%B9%A0Fabric.md">通过供应链金融练习Fabric</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;Fabric%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%A2%B3%E7%90%86.md&quot;&gt;Fabric核心概念学习与梳理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/fabric/Fabric测试网络使用</title>
    <link href="https://nijixucai.github.io/2020/12/18/blockchain/fabric/Fabric%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8/"/>
    <id>https://nijixucai.github.io/2020/12/18/blockchain/fabric/Fabric%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8/</id>
    <published>2020-12-18T02:22:59.740Z</published>
    <updated>2020-12-23T10:48:41.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fabric测试网络使用">Fabric测试网络使用</h2><h3 id="2-2-1下载样例源码">2.2.1下载样例源码</h3><p>运行命令下载最新版的<strong>Fabric</strong>和<strong>Fabric CA</strong>以及 <a href="https://github.com/hyperledger/fabric-samples" target="_blank" rel="noopener">hyperledger/fabric-samples</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://bit.ly/2ysbOFE | bash -s</span><br></pre></td></tr></table></figure><p>上面的命令干了这些事情：</p><ul><li>下载 <a href="https://github.com/hyperledger/fabric-samples" target="_blank" rel="noopener">hyperledger/fabric-samples</a></li><li>签出适当的版本标签</li><li>将Hyperledger Fabric平台特定的二进制文件和配置文件安装到Fabric-samples的/ bin和/ config目录中指定的版本</li><li>下载指定版本的Hyperledger Fabric docker镜像，包括：<ul><li>hyperledger/fabric-peer</li><li>hyperledger/fabric-orderer</li><li>hyperledger/fabric-ccenv</li><li>hyperledger/fabric-tools</li><li>hyperledger/fabric-baseos</li><li>hyperledger/fabric-ca</li></ul></li></ul><h3 id="2-2-2使用Fabric测试网络">2.2.2使用Fabric测试网络</h3><h4 id="启动Fabric测试网络">启动Fabric测试网络</h4><p>1.进入fabric-samples/test-network，可以看到network.sh文件,可以运行<code>./network.sh -h</code>来显示帮助</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd fabric-samples/test-network</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(base) apple@WHOAMIdeMacBook-Pro:~/code/open-source/blockchain/hyperledger/fabric-samples/test-network$     ll</span><br><span class="line">total 72</span><br><span class="line">-rw-r--r--   1 apple  staff    777 Dec 14 18:36 README.md</span><br><span class="line">drwxr-xr-x  12 apple  staff    384 Dec 14 18:36 addOrg3</span><br><span class="line">drwxr-xr-x   3 apple  staff     96 Dec 14 18:36 configtx</span><br><span class="line">drwxr-xr-x   5 apple  staff    160 Dec 14 18:36 docker</span><br><span class="line">-rwxr-xr-x   1 apple  staff  18645 Dec 14 18:36 network.sh</span><br><span class="line">drwxr-xr-x   7 apple  staff    224 Dec 14 18:36 organizations</span><br><span class="line">-rwxr-xr-x   1 apple  staff   8202 Dec 14 18:36 scriptUtils.sh</span><br><span class="line">drwxr-xr-x   6 apple  staff    192 Dec 14 18:36 scripts</span><br><span class="line">drwxr-xr-x   3 apple  staff     96 Dec 14 18:36 system-genesis-block</span><br></pre></td></tr></table></figure><p>2.停止原来正在运行的docker容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh down</span><br></pre></td></tr></table></figure><p>3.启动网络</p><p>**注意事项：**必须在<code>$USER/fabric-samples/test-network</code>目录下执行此脚本，否则会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh up</span><br></pre></td></tr></table></figure><p>这个脚本启动两个peer节点，一个ordering节点。这个脚本不会创建channel，我的脚本运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Creating network "net_test" with the default driver</span><br><span class="line">Creating volume "net_orderer.example.com" with default driver</span><br><span class="line">Creating volume "net_peer0.org1.example.com" with default driver</span><br><span class="line">Creating volume "net_peer0.org2.example.com" with default driver</span><br><span class="line">Creating orderer.example.com    ... done</span><br><span class="line">Creating peer0.org1.example.com ... done</span><br><span class="line">Creating peer0.org2.example.com ... done</span><br><span class="line">CONTAINER ID   IMAGE                               COMMAND                  CREATED        STATUS                    PORTS                              NAMES</span><br><span class="line">31c36a007eb0   hyperledger/fabric-peer:latest      "peer node start"        1 second ago   Up Less than a second     7051/tcp, 0.0.0.0:9051-&gt;9051/tcp   peer0.org2.example.com</span><br><span class="line">42f314195c64   hyperledger/fabric-orderer:latest   "orderer"                1 second ago   Up Less than a second     0.0.0.0:7050-&gt;7050/tcp             orderer.example.com</span><br><span class="line">de62f2f44a03   hyperledger/fabric-peer:latest      "peer node start"        1 second ago   Up Less than a second     0.0.0.0:7051-&gt;7051/tcp             peer0.org1.example.com</span><br><span class="line">e9af4c11538c   cordite/network-map:latest          "/usr/bin/java -cp /…"   5 days ago     Exited (143) 3 days ago                                      network-map</span><br><span class="line">5128423bb8d7   redis:5.0                           "docker-entrypoint.s…"   5 months ago   Exited (0) 7 weeks ago                                       redis</span><br><span class="line">6796aadc5173   mysql                               "docker-entrypoint.s…"   7 months ago   Exited (0) 7 weeks ago                                       mysql</span><br><span class="line">66c3ac55f920   neo4j                               "/sbin/tini -g -- /d…"   7 months ago   Exited (0) 7 months ago</span><br></pre></td></tr></table></figure><p>docker面板显示如下：</p><p><img src="https://gitee.com/guozhe001/images/raw/master/image-20201214185835819.png" alt="image-20201214185835819"></p><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/peers/peers.html" target="_blank" rel="noopener">Peers</a>是Fabric network的组成部分，Peers存储区块链账本并在提交之前验证交易。Peers运行包含业务逻辑的智能合约，智能合约用于管理区块链上的账本。</p><p>在网络上的每个Peer都属于一个团体，上图显示的测试网络中的两个peer分别属于组织<code>peer0.org1.example.com</code>和组织<code>peer0.org2.example.com</code>。</p><p>每个Fabric network同样包含<a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/orderer/ordering_service.html" target="_blank" rel="noopener">ordering service</a>，Peers在验证交易和提交交易到区块链的时候，他们不自己决定交易的顺序和区块中包含哪些交易。在分布式网络中，peers可能分布的特别远，所以让peers对交易顺序达成共识的成本是很高的。</p><p>ordering service的存在是为了让peers专注于交易验证和提交到账本中。在接收到客户端提交的交易时，ordering service会对其进行排序，然后把这些交易添加到区块中。然后将这些区块分发给peer节点，peer节点再把区块写入区块链。Ordering节点还运行系统通道，该通道定义了Fabric network的能力，像如何制作区块以及节点可以使用哪些版本的Fabric。系统通道还定义了哪些组织是属于该联盟的。</p><p>上面的测试网络只运行了一个Ordering节点，在实际的网络中可能存在多个Ordering节点，由一个或多个组织进行操作。不同的Ordering节点使用Raft共识算法来就网络上的交易顺序达成一致。</p><h4 id="创建channel">创建channel</h4><p>通道是特定网络成员之间的专用通信层。通道只能由被邀请加入通道的的组织使用，并且对网络上的其他成员不可见。每个通道都有一个单独的区块链账单，被邀请的组织加入通道上的其他peer以存储channel账本和验证通道上的交易。</p><p>在org2和org2之间创建通道，默认的channel名称为mychannel。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh createChannel</span><br></pre></td></tr></table></figure><p>如果运行成功，则会看到如下日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel successfully joined</span><br></pre></td></tr></table></figure><p>也可以指定channel的名称，并且你可以创建多个channel。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh createChannel -c channel1</span><br></pre></td></tr></table></figure><p>如果你想一步启动测试网络并创建channel，可以使用下面的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh up createChannel</span><br></pre></td></tr></table></figure><h4 id="在channel上启动chaincode">在channel上启动chaincode</h4><p>启动成功之后，就可以开始使用智能合约来操作channel账本了。智能合约包含了管理区块链账本上资产的业务逻辑。运行在网络上的程序可以调用智能合约在账本上创建、修改、交易资产，这些程序也查询智能合约以读取账本上的数据。</p><p>为了确保交易的有效性，使用智能合约创建的交易通常需要通道上的多个组织签名才能被提交到channel账本。交易也需要多次背书，来防止渠道上的某个组织篡改账本或使用未经过同意的逻辑。要签署交易，每个组织都需要在其peer上调用并执行智能合约，然后再签署交易的output。如果output一致并且收集到了足够的签名，交易就可以被提交到账本。指定需要哪些组织执行智能合约的策略叫做背书策略，该策略是为每个chaincode设置的，作为chaincode定义的一部分。</p><p>在Fabric中，智能合约以称为chaincode的软件包部署在网络上。chaincode安装在组织的peers上，然后部署到channel，然后就可以在该渠道中用于认可交易并与区块链账本进行交互。在讲chaincode部署到channel上之前，channel上的组织需要对chaincode的内容达成共识。当所需数量的组织达成共识之后，chaincode就可以被提交到channel上，然后chaincode就准备好可以使用了。</p><p>搭建完成测试环境之后，可以使用下面的命令来启动chaincode：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh deployCC</span><br></pre></td></tr></table></figure><p>我本地的运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Chaincode definition committed on channel 'mychannel'</span><br><span class="line">Using organization 1</span><br><span class="line">Querying chaincode definition on peer0.org1 on channel 'mychannel'...</span><br><span class="line">Attempting to Query committed status on peer0.org1, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode querycommitted --channelID mychannel --name basic</span><br><span class="line">+ res=0</span><br><span class="line">Committed chaincode definition for chaincode 'basic' on channel 'mychannel':</span><br><span class="line">Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</span><br><span class="line">Query chaincode definition successful on peer0.org1 on channel 'mychannel'</span><br><span class="line">Using organization 2</span><br><span class="line">Querying chaincode definition on peer0.org2 on channel 'mychannel'...</span><br><span class="line">Attempting to Query committed status on peer0.org2, Retry after 3 seconds.</span><br><span class="line">+ peer lifecycle chaincode querycommitted --channelID mychannel --name basic</span><br><span class="line">+ res=0</span><br><span class="line">Committed chaincode definition for chaincode 'basic' on channel 'mychannel':</span><br><span class="line">Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</span><br><span class="line">Query chaincode definition successful on peer0.org2 on channel 'mychannel'</span><br><span class="line">Chaincode initialization is not required</span><br></pre></td></tr></table></figure><h4 id="与网络互动">与网络互动</h4><p>在启用测试网络之后，你可以使用peerCLI与测试网络进行互动。peerCLI允许你调用已经部署的智能合约、更新channels；也可以通过CLI更新或者部署新的智能合约。</p><p>请确保你的操作在test-network目录下进行。</p><p>1、把<code>fabric-samples</code>的<code>bin</code>目录下的二进制命令安装到你的客户端环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;PWD&#125;/../bin:$PATH</span><br></pre></td></tr></table></figure><p>2、还需要将FABRIC_CFG_PATH设置为指向fabric-samples存储库中的core.yaml文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export FABRIC_CFG_PATH=$PWD/../config/</span><br></pre></td></tr></table></figure><p>3、现在设置环境变量允许你使用Org1的身份操作peerCLI。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export CORE_PEER_TLS_ENABLED=true</span><br><span class="line">export CORE_PEER_LOCALMSPID="Org1MSP"</span><br><span class="line">export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line">export CORE_PEER_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line">export CORE_PEER_ADDRESS=localhost:7051</span><br></pre></td></tr></table></figure><p>4、使用下面的命令用资产初始化账本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c '&#123;"function":"InitLedger","Args":[]&#125;'</span><br></pre></td></tr></table></figure><p>如果成功你会看到像下面的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-12-16 15:35:41.511 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</span><br></pre></td></tr></table></figure><p>5、现在你可以使用下面的命令查询账本上的资产</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C mychannel -n basic -c '&#123;"Args":["GetAllAssets"]&#125;'</span><br></pre></td></tr></table></figure><p>如果成功你会看到下面的结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;<span class="attr">"ID"</span>: <span class="string">"asset1"</span>, <span class="attr">"color"</span>: <span class="string">"blue"</span>, <span class="attr">"size"</span>: <span class="number">5</span>, <span class="attr">"owner"</span>: <span class="string">"Tomoko"</span>, <span class="attr">"appraisedValue"</span>: <span class="number">300</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">"ID"</span>: <span class="string">"asset2"</span>, <span class="attr">"color"</span>: <span class="string">"red"</span>, <span class="attr">"size"</span>: <span class="number">5</span>, <span class="attr">"owner"</span>: <span class="string">"Brad"</span>, <span class="attr">"appraisedValue"</span>: <span class="number">400</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">"ID"</span>: <span class="string">"asset3"</span>, <span class="attr">"color"</span>: <span class="string">"green"</span>, <span class="attr">"size"</span>: <span class="number">10</span>, <span class="attr">"owner"</span>: <span class="string">"Jin Soo"</span>, <span class="attr">"appraisedValue"</span>: <span class="number">500</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">"ID"</span>: <span class="string">"asset4"</span>, <span class="attr">"color"</span>: <span class="string">"yellow"</span>, <span class="attr">"size"</span>: <span class="number">10</span>, <span class="attr">"owner"</span>: <span class="string">"Max"</span>, <span class="attr">"appraisedValue"</span>: <span class="number">600</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">"ID"</span>: <span class="string">"asset5"</span>, <span class="attr">"color"</span>: <span class="string">"black"</span>, <span class="attr">"size"</span>: <span class="number">15</span>, <span class="attr">"owner"</span>: <span class="string">"Adriana"</span>, <span class="attr">"appraisedValue"</span>: <span class="number">700</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">"ID"</span>: <span class="string">"asset6"</span>, <span class="attr">"color"</span>: <span class="string">"white"</span>, <span class="attr">"size"</span>: <span class="number">15</span>, <span class="attr">"owner"</span>: <span class="string">"Michel"</span>, <span class="attr">"appraisedValue"</span>: <span class="number">800</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>6、网络上的成员想要交易资产或者更新资产时就会调用chaincode，使用下面的命令来调用资产转移chaincode来更改资产的owner。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles $&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c '&#123;"function":"TransferAsset","Args":["asset6","Christopher"]&#125;'</span><br></pre></td></tr></table></figure><p>如果成功结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-12-16 15:43:18.062 CST [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</span><br></pre></td></tr></table></figure><p>重新查询可以发现asset6的owner已经更改。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;<span class="attr">"ID"</span>:<span class="string">"asset1"</span>,<span class="attr">"color"</span>:<span class="string">"blue"</span>,<span class="attr">"size"</span>:<span class="number">5</span>,<span class="attr">"owner"</span>:<span class="string">"Tomoko"</span>,<span class="attr">"appraisedValue"</span>:<span class="number">300</span>&#125;,</span><br><span class="line">&#123;<span class="attr">"ID"</span>:<span class="string">"asset2"</span>,<span class="attr">"color"</span>:<span class="string">"red"</span>,<span class="attr">"size"</span>:<span class="number">5</span>,<span class="attr">"owner"</span>:<span class="string">"Brad"</span>,<span class="attr">"appraisedValue"</span>:<span class="number">400</span>&#125;,&#123;<span class="attr">"ID"</span>:<span class="string">"asset3"</span>,<span class="attr">"color"</span>:<span class="string">"green"</span>,<span class="attr">"size"</span>:<span class="number">10</span>,<span class="attr">"owner"</span>:<span class="string">"Jin Soo"</span>,<span class="attr">"appraisedValue"</span>:<span class="number">500</span>&#125;,</span><br><span class="line">&#123;<span class="attr">"ID"</span>:<span class="string">"asset4"</span>,<span class="attr">"color"</span>:<span class="string">"yellow"</span>,<span class="attr">"size"</span>:<span class="number">10</span>,<span class="attr">"owner"</span>:<span class="string">"Max"</span>,<span class="attr">"appraisedValue"</span>:<span class="number">600</span>&#125;,</span><br><span class="line">&#123;<span class="attr">"ID"</span>:<span class="string">"asset5"</span>,<span class="attr">"color"</span>:<span class="string">"black"</span>,<span class="attr">"size"</span>:<span class="number">15</span>,<span class="attr">"owner"</span>:<span class="string">"Adriana"</span>,<span class="attr">"appraisedValue"</span>:<span class="number">700</span>&#125;,</span><br><span class="line">&#123;<span class="attr">"ID"</span>:<span class="string">"asset6"</span>,<span class="attr">"color"</span>:<span class="string">"white"</span>,<span class="attr">"size"</span>:<span class="number">15</span>,<span class="attr">"owner"</span>:<span class="string">"Christopher"</span>,<span class="attr">"appraisedValue"</span>:<span class="number">800</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>7、我们在调用chaincode之后，我们来查一下这个调用是如何改变资产的。我们使用Org2来操作，配置环境变量如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export CORE_PEER_TLS_ENABLED=true</span><br><span class="line">export CORE_PEER_LOCALMSPID="Org2MSP"</span><br><span class="line">export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br><span class="line">export CORE_PEER_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span><br><span class="line">export CORE_PEER_ADDRESS=localhost:9051</span><br></pre></td></tr></table></figure><p>执行<code>peer chaincode query -C mychannel -n basic -c '{&quot;Args&quot;:[&quot;ReadAsset&quot;,&quot;asset6&quot;]}'</code>命令结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"ID"</span>:<span class="string">"asset6"</span>,<span class="attr">"color"</span>:<span class="string">"white"</span>,<span class="attr">"size"</span>:<span class="number">15</span>,<span class="attr">"owner"</span>:<span class="string">"Christopher"</span>,<span class="attr">"appraisedValue"</span>:<span class="number">800</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="中断网络">中断网络</h4><p>通过执行<code>./network.sh down</code>来中断网络，该命令会停止并删除peer河chaincode的容器；删除org的密钥等数据并从Docker中remove掉chaincode的镜像。该命令还会删除网路上的channel，如果有任何问题可以继续运行<code>./network.sh up</code>。</p><h2 id="问题处理">问题处理</h2><p>创建channel失败，日志如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Channel 'mychannel' created</span><br><span class="line">Join Org1 peers to the channel...</span><br><span class="line">Using organization 1</span><br><span class="line">+ peer channel join -b ./channel-artifacts/mychannel.block</span><br><span class="line">+ res=1</span><br><span class="line">+ peer channel join -b ./channel-artifacts/mychannel.block</span><br><span class="line">+ res=1</span><br><span class="line">+ peer channel join -b ./channel-artifacts/mychannel.block</span><br><span class="line">+ res=1</span><br><span class="line">+ peer channel join -b ./channel-artifacts/mychannel.block</span><br><span class="line">+ res=1</span><br><span class="line">2020-12-21 11:22:02.781 CST [comm.tls] ClientHandshake -&gt; ERRO 001 Client TLS handshake failed after 1.769196ms with error: EOF remoteaddress=[::1]:7051</span><br><span class="line">2020-12-21 11:22:03.785 CST [comm.tls] ClientHandshake -&gt; ERRO 002 Client TLS handshake failed after 2.054333ms with error: EOF remoteaddress=[::1]:7051</span><br><span class="line">2020-12-21 11:22:05.113 CST [comm.tls] ClientHandshake -&gt; ERRO 003 Client TLS handshake failed after 2.849348ms with error: EOF remoteaddress=[::1]:7051</span><br><span class="line">Error: error getting endorser client for channel: endorser client failed to connect to localhost:7051: failed to create new connection: context deadline exceeded</span><br><span class="line">After 5 attempts, peer0.org1 has failed to join channel 'mychannel'</span><br><span class="line">Create channel failed</span><br></pre></td></tr></table></figure><p>解决方案：</p><ul><li>删除所有的测试网络相关的容器</li><li>运行<code>./network.sh down</code></li><li>删除docker本地未使用的volume</li><li>重试</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Fabric测试网络使用&quot;&gt;Fabric测试网络使用&lt;/h2&gt;
&lt;h3 id=&quot;2-2-1下载样例源码&quot;&gt;2.2.1下载样例源码&lt;/h3&gt;
&lt;p&gt;运行命令下载最新版的&lt;strong&gt;Fabric&lt;/strong&gt;和&lt;strong&gt;Fabric CA&lt;/strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/fabric/7如何使用Hyperledger-Fabric搭建一个区块链项目</title>
    <link href="https://nijixucai.github.io/2020/12/16/blockchain/fabric/7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hyperledger-Fabric%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/"/>
    <id>https://nijixucai.github.io/2020/12/16/blockchain/fabric/7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hyperledger-Fabric%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-12-16T09:58:48.767Z</published>
    <updated>2020-12-18T02:55:51.045Z</updated>
    
    <content type="html"><![CDATA[<p>如何使用Hyperledger-Fabric搭建一个区块链项目</p><p>步骤如下：</p><ol><li>创建一个ordering service</li><li>添加其他的组织</li><li>创建联盟，创建channel</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何使用Hyperledger-Fabric搭建一个区块链项目&lt;/p&gt;
&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个ordering service&lt;/li&gt;
&lt;li&gt;添加其他的组织&lt;/li&gt;
&lt;li&gt;创建联盟，创建channel&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux/linux常用命令记录</title>
    <link href="https://nijixucai.github.io/2020/12/15/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
    <id>https://nijixucai.github.io/2020/12/15/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</id>
    <published>2020-12-15T09:40:43.965Z</published>
    <updated>2020-12-18T02:23:48.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tar">tar</h1><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf</span><br></pre></td></tr></table></figure><p>压缩</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tar&quot;&gt;tar&lt;/h1&gt;
&lt;p&gt;解压&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/fabric/Frbirc测试环境错误记录</title>
    <link href="https://nijixucai.github.io/2020/12/15/blockchain/fabric/Frbirc%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/"/>
    <id>https://nijixucai.github.io/2020/12/15/blockchain/fabric/Frbirc%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/</id>
    <published>2020-12-15T08:00:42.955Z</published>
    <updated>2020-12-18T02:55:22.198Z</updated>
    
    <content type="html"><![CDATA[<p>Hyperledger-Frbirc测试环境错误记录</p><p>在部署chaincode（<code>./network.sh deployCC</code>）的时候报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">(base) apple@WHOAMIdeMacBook-Pro:~/code/open-source/blockchain/hyperledger/fabric-samples/test-network$     ./network.sh deployCC</span><br><span class="line">deploying chaincode on channel 'mychannel'</span><br><span class="line">executing with the following</span><br><span class="line">- CHANNEL_NAME: mychannel</span><br><span class="line">- CC_NAME: basic</span><br><span class="line">- CC_SRC_PATH: NA</span><br><span class="line">- CC_SRC_LANGUAGE: go</span><br><span class="line">- CC_VERSION: 1.0</span><br><span class="line">- CC_SEQUENCE: 1</span><br><span class="line">- CC_END_POLICY: NA</span><br><span class="line">- CC_COLL_CONFIG: NA</span><br><span class="line">- CC_INIT_FCN: NA</span><br><span class="line">- DELAY: 3</span><br><span class="line">- MAX_RETRY: 5</span><br><span class="line">- VERBOSE: false</span><br><span class="line">Determining the path to the chaincode</span><br><span class="line">asset-transfer-basic</span><br><span class="line">Vendoring Go dependencies at ../asset-transfer-basic/chaincode-go/</span><br><span class="line">~/code/open-source/blockchain/hyperledger/fabric-samples/asset-transfer-basic/chaincode-go ~/code/open-source/blockchain/hyperledger/fabric-samples/test-network</span><br><span class="line">~/code/open-source/blockchain/hyperledger/fabric-samples/test-network</span><br><span class="line">Finished vendoring Go dependencies</span><br><span class="line">+ peer lifecycle chaincode package basic.tar.gz --path ../asset-transfer-basic/chaincode-go/ --lang golang --label basic_1.0</span><br><span class="line">+ res=0</span><br><span class="line">Chaincode is packaged</span><br><span class="line">Installing chaincode on peer0.org1...</span><br><span class="line">Using organization 1</span><br><span class="line">+ peer lifecycle chaincode install basic.tar.gz</span><br><span class="line">+ res=1</span><br><span class="line">Error: failed to retrieve endorser client for install: endorser client failed to connect to localhost:7051: failed to create new connection: context deadline exceeded</span><br><span class="line">Usage:</span><br><span class="line">  peer lifecycle chaincode install [flags]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">      --connectionProfile string       The fully qualified path to the connection profile that provides the necessary connection information for the network. Note: currently only supported for providing peer connection information</span><br><span class="line">  -h, --help                           help for install</span><br><span class="line">      --peerAddresses stringArray      The addresses of the peers to connect to</span><br><span class="line">      --tlsRootCertFiles stringArray   If TLS is enabled, the paths to the TLS root cert files of the peers to connect to. The order and number of certs specified should match the --peerAddresses flag</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">      --cafile string                       Path to file containing PEM-encoded trusted certificate(s) for the ordering endpoint</span><br><span class="line">      --certfile string                     Path to file containing PEM-encoded X509 public key to use for mutual TLS communication with the orderer endpoint</span><br><span class="line">      --clientauth                          Use mutual TLS when communicating with the orderer endpoint</span><br><span class="line">      --connTimeout duration                Timeout for client to connect (default 3s)</span><br><span class="line">      --keyfile string                      Path to file containing PEM-encoded private key to use for mutual TLS communication with the orderer endpoint</span><br><span class="line">  -o, --orderer string                      Ordering service endpoint</span><br><span class="line">      --ordererTLSHostnameOverride string   The hostname override to use when validating the TLS connection to the orderer</span><br><span class="line">      --tls                                 Use TLS when communicating with the orderer endpoint</span><br><span class="line">      --tlsHandshakeTimeShift duration      The amount of time to shift backwards for certificate expiration checks during TLS handshakes with the orderer endpoint</span><br><span class="line"></span><br><span class="line">Chaincode installation on peer0.org1 has failed</span><br><span class="line">Deploying chaincode failed</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hyperledger-Frbirc测试环境错误记录&lt;/p&gt;
&lt;p&gt;在部署chaincode（&lt;code&gt;./network.sh deployCC&lt;/code&gt;）的时候报错如下：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>language/java/线程池无法捕获线程的异常踩坑复盘</title>
    <link href="https://nijixucai.github.io/2020/12/15/language/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%97%A0%E6%B3%95%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E8%B8%A9%E5%9D%91%E5%A4%8D%E7%9B%98/"/>
    <id>https://nijixucai.github.io/2020/12/15/language/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%97%A0%E6%B3%95%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E8%B8%A9%E5%9D%91%E5%A4%8D%E7%9B%98/</id>
    <published>2020-12-15T02:24:42.056Z</published>
    <updated>2020-12-15T02:24:42.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><h3 id="需求信息">需求信息</h3><p>最近在工作中有个需求，先在A服务页面增加一条数据，然后去B服务查询此数据的详细信息</p><h3 id="解决方案">解决方案</h3><p>为了使A服务的新增数据接口快速响应，在查询B服务数据详情的地方使用了线程池异步查询与更新。</p><h3 id="问题现象">问题现象</h3><p>在验证时发现数据库中的数据字段不全，经分析缺少的都是需要从B服务查询并更新的字段</p><h3 id="初步定位">初步定位</h3><p>猜测应该是查询B服务时出了一些异常，而由于不规范使用线程池导致异常没有抛出，直接打到了控制台，故A服务的日志系统并看不到错误日志。</p><h2 id="问题解决">问题解决</h2><ol><li>查询B服务数据详情时暂时去掉使用线程池，改为同步调用</li><li>增加容错定时任务，定时查询需要从B服务获取缺失字段的数据进行更新</li></ol><p>上线后观察，新增的数据不再有部分字段缺失的情况；问题解决。</p><h2 id="问题复盘">问题复盘</h2><h3 id="A服务线程池的使用">A服务线程池的使用</h3><p>线程池定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询B服务数据详情的线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0L</span>, TimeUnit.MICROSECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(), <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"queryDataDetail-%d"</span>).build());</span><br></pre></td></tr></table></figure><p>线程池使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">add</span>(<span class="title">String</span> <span class="title">contract</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 0、检查合同必须不存在</span></span><br><span class="line">    checkIfExist(contract);</span><br><span class="line">    <span class="comment">// 1、保存合同数据</span></span><br><span class="line">    Entity entity = saveData(contract);</span><br><span class="line">    <span class="comment">// 2、从B服务查询缺失信息</span></span><br><span class="line">    executorService.execute(() -&gt; queryDataDetail(entity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如此使用有何问题">如此使用有何问题</h3><p>我重新写了一个测试方法如下：</p><p>1、定义一个会一直抛异常的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引入SystemOutRule，监听程序日志输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Rule</span></span><br><span class="line"><span class="keyword">public</span> SystemOutRule systemOutRule = <span class="keyword">new</span> SystemOutRule().enableLog();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引入SystemOutRule，监听程序日志输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">runWithException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    log.info(<span class="string">"thread is &#123;&#125;"</span>, thread);</span><br><span class="line">    log.info(<span class="string">"eh=&#123;&#125;"</span>, thread.getUncaughtExceptionHandler());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NicaiException(<span class="string">"出错啦！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用线程池调用上面的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(<span class="keyword">this</span>::runWithException);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100L</span>);</span><br><span class="line">    <span class="comment">// 断言程序打印的日志不包含“出错啦！”</span></span><br><span class="line">    Assert.assertFalse(systemOutRule.getLog().contains(<span class="string">"出错啦！"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、上面的单测断言是成功的，那么异常跑哪里去了？上面的单测在控制台的输出如下：</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200807110851677.png" alt="image-20200807110851677"></p><p>4、可以看出上面的异常信息是直接输出到了控制台，而不是由程序输出到控制台，主要原因是主程序没有捕获到此异常导致的。（具体原因还没有深入）</p><h3 id="如何解决线程池的异常捕获问题">如何解决线程池的异常捕获问题</h3><p>上面的测试可以说明到为什么日志里面查不到错误日志，那么如何捕获线程里的异常呢？</p><h4 id="方法1-使用UncaughtExceptionHandler">方法1:使用UncaughtExceptionHandler</h4><p>1、在创建线程池的时候，设置传入的ThreadFactory的UncaughtExceptionHandler属性，此UncaughtExceptionHandler会处理线程中的异常；下面的例子我直接打印了出来异常原因和异常栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWithUncaughtExceptionHandler</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool(</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                    .setUncaughtExceptionHandler((t, e) -&gt; log.info(<span class="string">"UncaughtExceptionHandler caught, error_message=&#123;&#125;"</span>, e.getMessage(), e))</span><br><span class="line">                    .build());</span><br><span class="line">    executorService.execute(<span class="keyword">this</span>::runWithException);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100L</span>);</span><br><span class="line">    Assert.assertTrue(systemOutRule.getLog().contains(<span class="string">"出错啦！"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、上面的单测运行结果如下：（可以和上面的运行结果进行比对）</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200807111728213.png" alt="image-20200807111728213"></p><p>3、从上面的运行结果可以看出异常信息是由程序捕获后再输出出来，这样就不会导致查不到异常日志了。</p><h4 id="方法2-使用guava扩展的FutureCallback">方法2:使用guava扩展的FutureCallback</h4><p>1、guava对jdk的线程做了一些扩展，其中一个就是FutureCallback，使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWithGuavaThreadPool</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newCachedThreadPool());</span><br><span class="line">    ListenableFuture&lt;String&gt; listenableFuture = executorService.submit(<span class="keyword">this</span>::runWithException);</span><br><span class="line">    Futures.addCallback(listenableFuture, <span class="keyword">new</span> FutureCallback&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"success! result = &#123;&#125;"</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            log.error(<span class="string">"guava FutureCallback caught, error_message=&#123;&#125;"</span>, t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100L</span>);</span><br><span class="line">    Assert.assertTrue(systemOutRule.getLog().contains(<span class="string">"出错啦！"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、上面的单测运行结果如下：</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200807112535447.png" alt="image-20200807112535447"></p><h2 id="问题总结">问题总结</h2><p>1、通过上面的测试，优化A服务的线程池定义，使之在遇到异常时能够正常被捕获，能输出，方便问题定位；补偿定时任务也能对第一次查询异常进行容错，保证数据能够同步过来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询B服务数据详情的线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0L</span>, TimeUnit.MICROSECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(), <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">        .setUncaughtExceptionHandler((t, e) -&gt; log.error(<span class="string">"查询数据详情的线程池异常,error_message=&#123;&#125;"</span>, e.getMessage(), e))</span><br><span class="line">        .setNameFormat(<span class="string">"queryDataDetail-%d"</span>).build());</span><br></pre></td></tr></table></figure><p>2、当然此问题更深层的问题还没有完全解答</p><ul><li>为什么线程里的异常不会被捕获？</li><li>UncaughtExceptionHandler的运行原理是什么？</li><li>Guava的FutureCallback是如何运行的？</li></ul><p>3、<a href="https://github.com/nijixucai/my-tools/blob/master/my-learn/my-experience/src/test/java/com/nicai/experience/concurrency/ExceptionThreadTest.java" target="_blank" rel="noopener">测试代码源码地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;h3 id=&quot;需求信息&quot;&gt;需求信息&lt;/h3&gt;
&lt;p&gt;最近在工作中有个需求，先在A服务页面增加一条数据，然后去B服务查询此数据的详细信息&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;为了使A服务的新增数据接口快速响</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>language/java/使用redis自增特性创建唯一id生成器</title>
    <link href="https://nijixucai.github.io/2020/12/15/language/java/%E4%BD%BF%E7%94%A8redis%E8%87%AA%E5%A2%9E%E7%89%B9%E6%80%A7%E5%88%9B%E5%BB%BA%E5%94%AF%E4%B8%80id%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://nijixucai.github.io/2020/12/15/language/java/%E4%BD%BF%E7%94%A8redis%E8%87%AA%E5%A2%9E%E7%89%B9%E6%80%A7%E5%88%9B%E5%BB%BA%E5%94%AF%E4%B8%80id%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2020-12-15T02:24:42.055Z</published>
    <updated>2020-12-15T02:24:42.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求说明">需求说明</h1><h2 id="产品要求实现一个订单编号，此编号规则如下">产品要求实现一个订单编号，此编号规则如下</h2><h3 id="订单编号规则：">订单编号规则：</h3><p>“字母” + “日期” + “自增ID”</p><h3 id="订单编号举例">订单编号举例</h3><p>比如业务A，在2020-08-04日有三个订单，那么订单编号如下：</p><ul><li>A202008040001</li><li>A202008040002</li><li>A202008040003</li></ul><p>比如业务A，在2020-08-05日有4个订单，那么订单编号如下：</p><ul><li>A202008050001</li><li>A202008050002</li><li>A202008050003</li><li>A202008050003</li></ul><p>通过上面的例子可以看到，后面的“自增ID”每天都会从1开始增加，在一个分布式系统中，要做到每天从1开始不重复并且自增的效果；想到的第一个实现方案就是redis的Incr命令（Redis Incr 命令将 key 中储存的数字值增一）。</p><h1 id="需求实现">需求实现</h1><h2 id="配置redis">配置redis</h2><h3 id="依赖redis相关jar包">依赖redis相关jar包</h3><p>因为此模块继承了spring-boot-starter-parent，所以不需要指定版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写配置redis的config">编写配置redis的config</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nicai.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.data.redis.RedisProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisClusterConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis集群配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guozhe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/08/04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(RedisProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RedisClusterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisProperties redisProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisClusterConfig</span><span class="params">(RedisProperties redisProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisProperties = redisProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread-safe factory of Redis connections配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> factory of Redis</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisClusterConfiguration redisClusterConfiguration = <span class="keyword">new</span> RedisClusterConfiguration(redisProperties.getCluster().getNodes());</span><br><span class="line">        redisClusterConfiguration.setPassword(redisProperties.getPassword());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory(redisClusterConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建String类型的redis模板</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisConnectionFactory factory of Redis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String-focused extension of RedisTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate(redisConnectionFactory);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是配置范型的RedisTemplate，需要设置值的序列化规则为：<strong>StringRedisSerializer</strong>，原因可以参考此文章：<a href="https://blog.csdn.net/tyyh08/article/details/80267261" target="_blank" rel="noopener">Spring Boot中使用RedisTemplate优雅的操作Redis，并且解决RedisTemplate泛型注入失败的问题</a></p><h3 id="测试redis的config代码">测试redis的config代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nicai.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yuanfeng.accounting.BaseAdminSpringTest;</span><br><span class="line"><span class="keyword">import</span> com.yuanfeng.accounting.Constants;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guozhe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/08/04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= AdminApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RedisClusterConfigTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_KEY = Constants.REDIS_KEY_PREFIX + <span class="string">"test:hello"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_VALUE = <span class="string">"world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringRedisTemplateGetAndSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(TEST_KEY, TEST_VALUE);</span><br><span class="line">        String value = stringRedisTemplate.opsForValue().get(TEST_KEY);</span><br><span class="line">        Assert.assertEquals(TEST_VALUE, value);</span><br><span class="line">        stringRedisTemplate.delete(TEST_KEY);</span><br><span class="line">        Assert.assertNull(stringRedisTemplate.opsForValue().get(TEST_KEY));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIncr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String key = TEST_KEY;</span><br><span class="line">        ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue();</span><br><span class="line">        valueOperations.set(key, <span class="string">"1"</span>, <span class="number">24</span>, TimeUnit.HOURS);</span><br><span class="line">        String initValue = valueOperations.get(key);</span><br><span class="line">        log.info(<span class="string">"key=&#123;&#125;, init value=&#123;&#125;"</span>, key, initValue);</span><br><span class="line">        Assert.assertEquals(<span class="string">"1"</span>, initValue);</span><br><span class="line">        Long increment = valueOperations.increment(key);</span><br><span class="line">        log.info(<span class="string">"key=&#123;&#125;, after increment=&#123;&#125;"</span>, key, increment);</span><br><span class="line">        Assert.assertEquals(Long.valueOf(<span class="number">2</span>), increment);</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">        Assert.assertNull(valueOperations.get(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于redis编写唯一ID生成服务">基于redis编写唯一ID生成服务</h2><h3 id="添加抽象的唯一id生成服务">添加抽象的唯一id生成服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nicai.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.BooleanUtil;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分布式ID生成服务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guozhe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/08/04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRedisDistributedIDGenerateService</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">AbstractRedisDistributedIDGenerateService</span>.<span class="title">Context</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化key时的默认值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_VALUE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractRedisDistributedIDGenerateService</span><span class="params">(StringRedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个ID，直接从redis中获取自增后的值；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个ID, 如果redis出现异常则返回null，请使用者自行处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Optional&lt;Long&gt; <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从redis中获取自增id</span></span><br><span class="line">        Long id = incr(getKey());</span><br><span class="line">        <span class="keyword">return</span> Objects.isNull(id) ? Optional.empty() : Optional.of(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个ID，根据传入的上下文和redis中自增后的值最终组装成下一个ID；</span></span><br><span class="line"><span class="comment">     * 获取之后会交给子类检查此ID是否重复，如果重复会从子类中获取最新的ID，然后更新redis中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 拼装id时需要的上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">nextId</span><span class="params">(T context)</span> </span>&#123;</span><br><span class="line">        Optional&lt;Long&gt; id = nextId();</span><br><span class="line">        <span class="comment">// 如果可以从redis中获取值，则说明redis服务正常，需要判重；否则直接从数据库中获取下一个id</span></span><br><span class="line">        String nextId = id.isPresent() ? ifDuplicatedThenUpdate(context, assemblyNextId(context, id.get())) :</span><br><span class="line">                getNewIdFromDbAndUpdateRedis(context, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"context=&#123;&#125;,redisIncrId=&#123;&#125; nextId=&#123;&#125;"</span>, JSON.toJSONString(context), id, nextId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查获取到的ID是否重复</span></span><br><span class="line"><span class="comment">     * 如果重复则说明由于redis的一些原因导致的重复，返回最新的redis中应该存在的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nextId 下一个ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果当前ID没有重复，则返回null，否则如果重复了则返回redis中应该有的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">checkIfDuplicated</span><span class="params">(String nextId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库获取下一个id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> duplicatedId 重复的id，此入参可能为null，子类需要自己处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数据库获取下一个id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Long <span class="title">maxIdFromDatabase</span><span class="params">(String duplicatedId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类根据redis当前的值自行组装最终的ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context    上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisValue redis当前的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最终的ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">assemblyNextId</span><span class="params">(T context, Long redisValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取redis自增的key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> redis自增的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用redis的自增方法</span></span><br><span class="line"><span class="comment">     * 如果key不存在则先设置key，再调用自增方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 需要自增的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 自增之后的值，如果redis出现异常则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">incr</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Long increment = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先检查redis中是否有key,如果没有,先设置key并且设置过期时间</span></span><br><span class="line">            <span class="keyword">if</span> (BooleanUtil.isFalse(redisTemplate.hasKey(key))) &#123;</span><br><span class="line">                initOrUpdateValue(key, getKeyInitValue());</span><br><span class="line">            &#125;</span><br><span class="line">            increment = redisTemplate.opsForValue().increment(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"调用redis的自增方法异常，error_message=&#123;&#125;"</span>, e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">"key = &#123;&#125;, increment=&#123;&#125;"</span>, key, increment);</span><br><span class="line">        <span class="keyword">return</span> increment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取初始化key时的value值，默认是0，自增之后id从1开始；</span></span><br><span class="line"><span class="comment">     * 如果子类想从其他数字开始则自己覆盖此方法即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 初始化key时的value值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">getKeyInitValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取key的超时时间，单位是小时，由子类设置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 超时时间，单位小时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getTimeOutHours</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否重复，如果重复则从别的渠道（由子类自己决定从哪个渠道）更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 拼装id时需要的上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nextId  下一个id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果重复则返回新的nextId，否则返回入参传入的nextId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">ifDuplicatedThenUpdate</span><span class="params">(T context, String nextId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否重复，如果重复则从数据库中获取，否则直接返回当前值</span></span><br><span class="line">        <span class="keyword">return</span> checkIfDuplicated(nextId) ? getNewIdFromDbAndUpdateRedis(context, nextId) : nextId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库获取新id并更新redis中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 拼装id时需要的上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nextId  下一个id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 根据数据库的id获得的新id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getNewIdFromDbAndUpdateRedis</span><span class="params">(T context, String nextId)</span> </span>&#123;</span><br><span class="line">        Long maxIdFromDatabase = maxIdFromDatabase(nextId);</span><br><span class="line">        String newId = assemblyNextId(context, maxIdFromDatabase);</span><br><span class="line">        log.warn(<span class="string">"nextId=&#123;&#125; 在数据库中已经存在，maxIdFromDatabase=&#123;&#125; 重新获取新的newId=&#123;&#125;"</span>, nextId, maxIdFromDatabase, newId);</span><br><span class="line">        initOrUpdateValue(getKey(), maxIdFromDatabase);</span><br><span class="line">        <span class="keyword">return</span> newId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化或者更新redis中的自增的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   redis中的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要设置的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initOrUpdateValue</span><span class="params">(String key, Long value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, String.valueOf(value), getTimeOutHours(), TimeUnit.HOURS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"设置redis值异常，value=&#123;&#125; error_message=&#123;&#125;"</span>, value, e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上下文；子类自己定义上下文，然后根据上下文的数据来最终组装ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 凭证编号上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AContext</span> <span class="keyword">implements</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 业务类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String businessType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加一个A服务的唯一id生成服务实现">添加一个A服务的唯一id生成服务实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nicai.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.date.DatePattern;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.date.DateUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> com.yuanfeng.accounting.Constants;</span><br><span class="line"><span class="keyword">import</span> com.yuanfeng.accounting.dao.ManualVoucherDAO;</span><br><span class="line"><span class="keyword">import</span> com.yuanfeng.accounting.entity.ManualVoucherEntity;</span><br><span class="line"><span class="keyword">import</span> com.yuanfeng.accounting.exception.AccountingException;</span><br><span class="line"><span class="keyword">import</span> com.yuanfeng.accounting.service.AbstractRedisDistributedIDGenerateService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分布式唯一ID生成-A实现类</span></span><br><span class="line"><span class="comment"> * 编号规则：用途+日期+自增ID，如：A202007310001；A202007310002；A202008070001；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guozhe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/08/04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedIDGenerateServiceAImpl</span> <span class="keyword">extends</span> <span class="title">AbstractRedisDistributedIDGenerateService</span>&lt;<span class="title">AbstractRedisDistributedIDGenerateService</span>.<span class="title">AContext</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUSINESS_TYPE = <span class="string">"A:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ID长度不足4位时在前面填充的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> FILLED_CHAR = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后的自增ID的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INCREMENT_LENGTH = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期小时数，即在24小时候过期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXPIRATION_HOURS = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistributedIDGenerateServiceAImpl</span><span class="params">(StringRedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(redisTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkIfDuplicated</span><span class="params">(String nextId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">maxIdFromDatabase</span><span class="params">(String duplicatedId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">assemblyNextId</span><span class="params">(VoucherNumberContext context, Long redisValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.join(Constants.BLANK, context.getBusinessType(), getDatePeriod(),</span><br><span class="line">                StrUtil.fillBefore(String.valueOf(redisValue), FILLED_CHAR, INCREMENT_LENGTH));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.join(Constants.REDIS_KEY_DELIMITER, Constants.REDIS_KEY_PREFIX, BUSINESS_TYPE, getDatePeriod());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">getTimeOutHours</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EXPIRATION_HOURS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;需求说明&quot;&gt;需求说明&lt;/h1&gt;
&lt;h2 id=&quot;产品要求实现一个订单编号，此编号规则如下&quot;&gt;产品要求实现一个订单编号，此编号规则如下&lt;/h2&gt;
&lt;h3 id=&quot;订单编号规则：&quot;&gt;订单编号规则：&lt;/h3&gt;
&lt;p&gt;“字母” + “日期” + “自增ID”&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为什么我们在使用Spring的时候应该使用构造方法注入bean</title>
    <link href="https://nijixucai.github.io/2020/12/15/language/java/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%E8%80%8C%E4%B8%8D%E6%98%AF@Autoware/"/>
    <id>https://nijixucai.github.io/2020/12/15/language/java/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%E8%80%8C%E4%B8%8D%E6%98%AF@Autoware/</id>
    <published>2020-12-15T02:24:42.055Z</published>
    <updated>2020-12-15T02:24:42.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题">问题</h1><p>对于使用Spring框架的java开发人员对下面的代码应该很熟悉：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HelloService helloService;</span><br></pre></td></tr></table></figure><p>但是对于上面的代码，Sonar会提示：<code>Remove this annotation and use constructor injection instead.</code></p><p>翻译成中文即：移除<code>@Autowired</code>注解使用构造器注入方式替代。</p><p>IntelliJ IDEA也会提示<code>Field injection is not recommended</code></p><p>翻译成中文即：不推荐使用字段注入</p><h1 id="那么他们为什么这么建议呢？">那么他们为什么这么建议呢？</h1><h2 id="首先我们先看一下Spring有哪些注入bean的方式">首先我们先看一下Spring有哪些注入bean的方式</h2><ol><li>构造方法注入</li><li>set方法注入</li><li>字段注入，即<code>@Autowired</code>注解</li></ol><h2 id="如何使用这些方式">如何使用这些方式</h2><h3 id="构造方法注入">构造方法注入</h3><p>在Spring4.3版本之前，我们必须要在构造方法上加<code>@Autowired</code>注解；在新版本中如果当前类只有一个构造方法<code>@Autowired</code>注解就是可选的。</p><p>只有一个构造方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValidationController</span><span class="params">(HelloService helloService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloService = helloService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个构造方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValidationController</span><span class="params">(HelloService helloService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloService = helloService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValidationController</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set方法注入">set方法注入</h3><p>这种方式Spring会找到 <code>@Autowired</code> 注解并且调用set方法来注入所需的依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">getHelloService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHelloService</span><span class="params">(HelloService helloService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloService = helloService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段注入">字段注入</h3><p>通过基于字段的注入，Spring在使用<code>@Autowired</code>注释进行注释时，直接将所需的依赖项分配给字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="这些方式有什么优缺点">这些方式有什么优缺点</h2><p>既然要<em><strong>移除<code>@Autowired</code>注解使用构造器注入方式替代</strong></em>，那么我们主要讨一下这些方式的优缺点。</p><h3 id="字段注入方式的优点">字段注入方式的优点</h3><p>相比较另外两种方式，字段注入方式的代码量更少、更整齐、更简洁</p><h3 id="构造方法注入的优点">构造方法注入的优点</h3><h4 id="容易发现代码的坏味道">容易发现代码的坏味道</h4><p>set方法注入和字段注入会<em><strong>间接</strong></em>违反<strong>单一职责原则</strong>。</p><p>因为在一个类依赖很多其他类的时候，如果使用构造方法注入就会发现构造方法的参数太多，这会让开发人员反思这个类真的需要这么多依赖吗？当前类是不是职责过多？</p><p>而使用字段注入时，就会把一些例如sonar的提示屏蔽掉，让开发人员误以为这样做没有问题</p><h4 id="可以创建不可变类">可以创建不可变类</h4><p>在使用构造方法注入时因为构造方法是创建依赖对象的唯一方式，这非常有助于让我们创建不可变的对象。</p><p>想象一下创建一个bean之后你可以通过set方法随意修改此类的依赖，在出现问题时是很难定位的。</p><p><code>@Autowired</code>的源码有一段注释如下：<code>Fields are injected right after construction of a bean, before any config methods are invoked. Such a config field does not have to be public.</code><br>大意是使用<code>@Autowired</code>注解时，bean是在构造当前的bean之后，并且在任何的其他方法调用之前注入，因此无法设置成final类型的字段。</p><h4 id="更明显的声明所有的依赖">更明显的声明所有的依赖</h4><p>使用构造方法注入，在使用这个类时就会暴露给使用者说我要依赖构造方法中的类。</p><p>但是使用字段注入时，使用者其实并不知道这个类依赖了哪些类，除非我到此类中查看这个类有多少个字段是有<code>@Autowired</code>注解。</p><h4 id="不方便迁移">不方便迁移</h4><p>spring实现了DI（控制反转），但并非是DI本身；<br>使用构造方法注入时，除了在类上面有<code>@Service</code>、<code>@Component</code>等的注解，没有其他的Spring相关的更多的注解。</p><p>使用字段注入时，除了在类上面有<code>@Service</code>、<code>@Component</code>等的注解之外又使用了Spring的<code>@Autowired</code>注解，如果把此类迁移到其他没有spring的环境时是完成不了注入的。</p><h4 id="不方便测试">不方便测试</h4><p>在使用构造方法注入时，单元测试时开发人员可以直接传入一个mock的类或者其他的任何被测试类依赖的子类；</p><p>当然我们也可以使用set方式注入一个mock的类，但是如果代码修改了新增了一个依赖，那么我们很容易忘掉在测试代码中set新增的依赖，直到运行的时候我们才会看到可能有NPE异常爆出；但是构造方法就不必有这种烦恼，因为如果新增了一个依赖，测试方法会马上编译不通过。</p><p>使用字段注入，必须依赖Spring去帮助注入依赖的类</p><h1 id="总结">总结</h1><p>通过构造方法注入bean是我们更容易创建不可变类，代码更健壮、更具有可测试性、更容易避免NPE。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;问题&lt;/h1&gt;
&lt;p&gt;对于使用Spring框架的java开发人员对下面的代码应该很熟悉：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/0区块链的学习计划</title>
    <link href="https://nijixucai.github.io/2020/12/11/blockchain/0%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>https://nijixucai.github.io/2020/12/11/blockchain/0%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2020-12-11T11:04:50.000Z</published>
    <updated>2020-12-18T02:25:19.192Z</updated>
    
    <content type="html"><![CDATA[<p>区块链的学习计划</p><p>除了这些你还需要学习什么？</p><ul><li>X.509</li><li>TLS/SSL</li><li>分片（以太坊中有此概念、布比区块链也有）</li><li>跨链是如何实现的</li><li>国密从哪里能找到，有没有开源与标准</li><li>DeFi是什么？</li></ul><p>一个区块链公司需要哪些：</p><p><img src="https://gitee.com/guozhe001/images/raw/master/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%AC%E5%8F%B8%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90.png" alt="区块链公司调研分析"></p><p>业务持续学习：</p><ul><li>保理模式</li><li>承兑汇票</li><li>清分</li><li>应收账款</li><li>贴现</li><li>拆转融</li><li>ABS</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;区块链的学习计划&lt;/p&gt;
&lt;p&gt;除了这些你还需要学习什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X.509&lt;/li&gt;
&lt;li&gt;TLS/SSL&lt;/li&gt;
&lt;li&gt;分片（以太坊中有此概念、布比区块链也有）&lt;/li&gt;
&lt;li&gt;跨链是如何实现的&lt;/li&gt;
&lt;li&gt;国密从哪里能找到，有没有开源</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/2区块链开发框架-Corda学习总结</title>
    <link href="https://nijixucai.github.io/2020/12/11/blockchain/2%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6-Corda%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://nijixucai.github.io/2020/12/11/blockchain/2%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6-Corda%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2020-12-11T06:43:22.000Z</published>
    <updated>2020-12-16T06:51:02.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-Corda资料整理">0. Corda资料整理</h1><p><a href="https://www.corda.net/" target="_blank" rel="noopener">官网</a><br><a href="https://www.youtube.com/channel/UCoOuUZatvIC1U65OisCrIKg" target="_blank" rel="noopener">油管频道</a><br><a href="https://cncorda.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Corda中文文档</a><br><a href="https://docs.corda.net/" target="_blank" rel="noopener">开发文档</a><br><a href="https://cncorda.com/" target="_blank" rel="noopener">Corda中文社区</a><br><a href="https://stackoverflow.com/questions/tagged/corda" target="_blank" rel="noopener">Stack Overflow讨论区, corda标签</a><br><a href="https://training.corda.net/" target="_blank" rel="noopener">Corda Training</a></p><h1 id="1-Corda是什么？">1. Corda是什么？</h1><p>Corda是为企业构建的开源区块链/分布式账本帐平台；Corda使企业可以使用智能合约在严格的隐私下直接进行交易，从而降低交易和记录保存成本，并简化业务运营。<br>Corda不会定期将需要确认的交易分批处理再分成块之后一次性确认。相反，Corda会实时确认每笔交易。</p><h2 id="1-0-Corda有哪些概念">1.0 Corda有哪些概念</h2><h3 id="1-0-1-网络">1.0.1 网络</h3><ul><li>一个Corda网络由运行着Corda和CorDapps的节点构成的</li><li>不同的节点间的沟通是点对点的，不依赖于全局广播</li><li>每个节点都可以使用一个数字证书来将真实世界中的法律身份和网络身份相关联</li><li>这个网络是一个需要许可的网络，需要从网络维护者那里申请一个数字证书来获得访问权限</li></ul><h3 id="1-0-2-账本">1.0.2 账本</h3><ul><li>每个账本是针对于每一个节点的</li><li>对于账本上的共享事实，共享的两方（或多方）总是能够保证存在他们自己的账本中的事实是完全一致的</li><li>在 Corda 中是 <strong>没有唯一的中心化存储的数据</strong> 的。每个节点维护着一个独立的数据库，其中包含了所知道的事实。所以每个 peer 只能够看到账本中的事实中的一部分，没有节点能够知道所有的内容。</li></ul><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/ledger-venn.png" alt="img"></p><h3 id="1-0-3-States">1.0.3 States</h3><ul><li><em>State 代表的是存在账本上的事实</em></li><li><em>State 通过将原来的 State 变为历史记录然后添加一条新版本的 state 的方式来对 state 进行更新</em></li><li><em>每个节点都有一个 vault 来存储该节点所有相关的 States</em></li></ul><h4 id="1-0-3-0-State-顺序">1.0.3.0 State 顺序</h4><p>个共享的事实的生命周期是可以通过 <strong>state 顺序</strong> 来体现。当一个 state 需要更新的时候，我们会创建一个代表新的 state 的新版本的 state，然后将原来的那个 state 标注为历史版本。</p><h4 id="1-0-3-1-Vault">1.0.3.1 Vault</h4><p>Corda 网络中的每一个节点都维护着一个 <em>vault</em> - 它是一个数据库，其中跟踪了所有 states 的当前以及历史的 states 数据，以及跟它有关的数据：</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/vault-simple.png" alt="_images/vault-simple.png"></p><h4 id="1-0-3-2-参考-states">1.0.3.2 参考 states</h4><p>并不是所有的 states 都需要被使用他们的节点来更新的。对于参数数据的情况，有一种常见的模式，一方创建了参考数据，这些数据会被其他方使用（但是不会被更新）。对于这种情况，states 中包含的参考数据被称为 “参考 states”。</p><h3 id="1-0-4-Transactions">1.0.4 Transactions</h3><ul><li>Transaction 是关于更新账本的提议；（<strong>个人理解</strong>：<em>更准确的说应该是更新账本上的某些states的提议</em>）</li><li>一个 transaction 提议只能在满足以下条件的时候才会被提交：<ul><li>它不包含“双花”</li><li>它是合约有效的</li><li>它需要被所有相关方提供签名</li></ul></li></ul><p>Corda 使用 UTXO (未消费的 transaction output) 模型来使账本上的每条 state 都不可更改。对于账本上数据的变更都是通过使用 transaction 的方式来做的，就是将 0 条或多条已经存在的账本 states 变为历史记录（inputs），然后再新增0条或多条新的账本 states （outputs）。交易代表了 state 顺序中的一个单独的链接。</p><p>**个人理解：**<em>这一点和比特币很像，不同点是比特币的交易只需要支付的人的签名，而这里的transaction需要所有人相关人的签名</em></p><p>一个 transaction 中可以包含任何数量任何类型的 inputs 和 outputs：</p><ul><li>可以包含多种类型的 state（cash, bonds）</li><li>可以是 issuances 类型（有0个input）或者 exists 类型（有0个 output）</li><li>可以合并或拆分可替换的资产（比如把一个 $2 的 state 和 $5 的 state 合并为 $7 的 cash state）</li></ul><p>Transaction 是 原子性操作，一个 transaction 里边的所有 changes 必须要全部执行，或者一个也不会执行。</p><p>有两种基本类型的 transactions：</p><ul><li>Notary-change transactions（用来变更 state 的 notary - 查看 Notaries）</li><li>General transactions（其他任何类型的 transaction）</li></ul><h4 id="1-0-4-1-交易链">1.0.4.1 交易链</h4><p>一个新的 transaction 的 output state 在账本中应该是还不存在的，所以需要提出 transaction 的一方来创建。但是 transaction 中包含的 input 应该是在账本中已经存在的，应该是前一个 transaction 添加进去的 output。所以我们需要在新的 transaction 中引用这些已经存在的记录。</p><p>这些 Input state 的引用包含两部分(<strong>个人理解</strong>：与比特币的交易链一样)：</p><ul><li>创建这个 input 的 transaction 的 hash</li><li>这个 input 所指的前一个 transaction 带来的 output state 在 output list 中的位置或者索引值</li></ul><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/tx-chain1.png" alt="_images/tx-chain1.png"></p><h4 id="1-0-4-2-提交交易">1.0.4.2 提交交易</h4><p>初始的时候，一个 transaction 仅仅是一个更新账本的 提议。它表示了经过这次更新后账本的新的状态：</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/uncommitted_tx.png" alt="_images/uncommitted_tx.png" style="zoom:30%;"><p>为了成为真正的一笔交易，transaction 必须要获得所有 要求的签名*（查看下边的 *<em>command</em>）。每一个要求的签名者会将签名附加在 transaction 上来表示他们已经同意了这次更新：</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/tx_with_sigs.png" alt="_images/tx_with_sigs.png" style="zoom:30%;"><p>如果得到了所有需要的签名，这个 transaction 就会被提交了：</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/committed_tx.png" alt="_images/committed_tx.png" style="zoom:30%;"><p>一旦提交就意味着：</p><ul><li>Transaction 的 input 被标注为历史记录，并且不能再被之后的 transactions 使用了</li><li>Transaction 的 output 变为账本上的当前状态的一部分</li></ul><h4 id="1-0-4-3-交易的有效性">1.0.4.3 交易的有效性</h4><p>每一个被要求的签名方应该只有在满足以下两个条件的时候才应该提供签名：</p><ul><li><strong>Transaction 是有效的</strong>：对于当前的 transaction 提案以及产生当前提案的 Input 相关的所有以前的所有 transactions 的链条中：<ul><li>Transaction 应该获得所有相关方的数字签名</li><li>Transaction 是 <em>合约有效</em> 的</li></ul></li><li><strong>Transaction 唯一性</strong>：本次 transaction 提案要消费的 inputs 没有被任何已经存在的其他的已提交的 transaction 消费过</li></ul><h4 id="1-0-4-4-参考-states">1.0.4.4 参考 states</h4><p>正如 States 所描述的，一些 states 需要被其他的 input 或者 output states 的合约代码所引用，但是不需要被修改/消费。这就需要参考 states。当一个 state 被添加到一笔交易的参考 states 列表中，而不是 inputs 或者 outputs 列表的时候，那么它就被作为 参考 state。在常规的 states 和参考 states 间有两点区别：</p><ul><li>交易的节点指定的 notary 会检查参考 state 是不是当前的。然而，当包含他们的交易被提交到账本的时候，参考 states 是不会被消费的。</li><li>对于参考 states 的合约代码也不会被包含他们的交易所执行。</li></ul><h4 id="1-0-4-5-其他的交易组件">1.0.4.5 其他的交易组件</h4><p>就像 input states 和 output states 一样，transactions 还可能会包含下边的组件：</p><ul><li>Commands</li><li>Attachments</li><li>Timestamps</li><li>Notary</li></ul><p>比如一个交易中，Alice 使用 £5 的现金向 Bob 支付了一个 IOU 的 £5。该笔交易包含了两个附件，并且只能够在 notary pool 在指定的时间窗内收到该笔交易的时候被 NotaryClusterA 进行公证，看起来像下边这样：</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/full-tx.png" alt="_images/full-tx.png" style="zoom:30%;"><h4 id="1-0-4-5-1-Commands">1.0.4.5.1 Commands</h4><p><a href="https://zhuanlan.zhihu.com/p/33792878" target="_blank" rel="noopener">翻译视频讲解Corda 核心概念 - Commands</a></p><p>Commands是什么？</p><ul><li>Commands 是一些动词（verbs）</li><li>Commands 将 transaction 进行参数化（parameterise），这样除了从 State 中能够获取的信息外，commands 又能提供了更多的一些信息</li><li>Commands 也提示（hint）了 transaction 的意图（intent）</li><li>Commands 也可能包含通过 Oracle Service 提供的数据（off-ledger data）</li></ul><p>一些 Commands 典型的例子：</p><ul><li>发布（issue）新的 State 到账本上</li><li>交换（transfer）资产到账本中的另一方</li><li>付钱（pay）给账本中的另一方</li><li>偿还（redeem）一笔资产并结束/清除代表该资产的state</li><li>尝试（exercise）一个选项 option</li><li>履行（settle）一个义务来递交一个资产</li></ul><p>如何知道一个 transaction 都需要谁来提供签名呢？我们会把一个公钥列表关联至一个 command，来说明都谁需要对这个 command 提供签名。</p><ul><li>一个 command中会包含一个公钥列表（public key list），通过这个列表就知道了都会涉及哪些人来确认/签名该 state transaction</li><li>在 transaction中，input 和 output states 经常会被按照类别分组（还可能根据其他的条件进行分组）</li><li>每一组 state 都需要有一个 command</li></ul><h4 id="1-0-4-5-2-Attachments">1.0.4.5.2 Attachments</h4><p>有些时候，我们会有一些数据可以在不同的 transactions 中被重用。比如：</p><ul><li>一个公共假期的 calendar</li><li>支持的法律文档</li><li>一个货币代码的表格</li></ul><p>针对这些情况，我们使用附件。一个 transaction 可以通过 hash 引用 0 个或者多个附件。这些附件是 ZIP/JAR 文件，可以包含任何内容。这些附件中信息可以用来验证 transaction 的有效性。</p><h4 id="1-0-4-5-3-Time-window">1.0.4.5.3 Time-window</h4><p>一些时候，我们希望一个交易仅仅在一个指定的时间点被批准执行。例如：</p><ul><li>在一个指定的日期之后执行一个选项</li><li>一个债券只能在它的过期日期前被赎回</li></ul><p>在这些情况下，我们给 transaction 添加一个 time-window。time-windows 制定了交易会在哪个时间点被提交。</p><h4 id="1-0-4-5-4-Notary">1.0.4.5.4 Notary</h4><p>**个人理解：**为了在issuance/genesis 交易中提供公证证明的，证明此交易的合法性。</p><h3 id="1-0-5-Contracts">1.0.5 Contracts</h3><p>**个人理解：**与以太坊的智能合约类似</p><ul><li>一个有效的 transaction 必须要被它的所有 input 和 output states中的 contract 接受</li><li>Contracts 需要使用 JVM 编程语言编写（java 或者 kotlin）</li><li>Contract 的执行是一定要有一个确定性结果的，并且它对于一个 transaction 的接受是仅仅基于 transaction 的内容</li></ul><h4 id="1-0-5-1-Transaction-验证">1.0.5.1 Transaction 验证</h4><p>一个 transaction 仅仅当被所有要求的签名方提供了签名之后才会被认为是有效的。但是，除了获得到所有人的签名之后，还必须要满足 合约有效 才会被最终认为有效。</p><p>合约有效 的定义包含以下几点：</p><ul><li>每个 state 都指定了一个 合约 类别</li><li>合约将交易(transaction)作为输入，并根据合约规则说明该交易是否有效</li><li>仅当<strong>every input state</strong>和** every output state **的合约都认为其有效时，交易(transaction)才有效</li></ul><p>我们可以用下图来描述这个关系：</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/tx-validation.png" alt="_images/tx-validation.png" style="zoom:30%;"><p>合约代码可以用任何JVM语言编写，并可以使用该语言的全部功能，包括：</p><ul><li>检查 inputs，outputs，commands 的数量，时间，附件</li><li>检查这些组件中的任何一个的内容</li><li>循环构造，变量分配，函数调用，辅助方法等</li><li>将一些类似的 states 分组来验证（比如对于所有的现金 state 的组合定义一个规则）</li></ul><p>一个 transaction 如果不是合约有效的话，是不会被视为一个对账本的有效更新，也就不可能被提交至账本。通过这种方式，合同对state随时间的变化施加了规则，这些规则与所需签名者签署给定交易的意愿无关。</p><h4 id="1-0-5-2-The-contract-sandbox">1.0.5.2 The contract sandbox</h4><p>**个人理解：**为了保证验证的结果不根据外部的条件而改变，Corda提供了一个沙箱，以防止代码引入可能会造成不确定性结果的外部库</p><p><a href="https://cncorda.readthedocs.io/zh_CN/latest/deterministic-modules.html" target="_blank" rel="noopener">Deterministic Corda Modules</a></p><p>Transaction 验证必须是 一个确定性的结果： 在一个确定的transaction提议中，一个 contract 必须总是接受 或者 总是拒绝。比如 transaction 是否有效不能够取决于你在什么时间做的 verify 或者是基于某一方具有的信息量的多少来决定是有效的还是无效的。这是一个很重要的条件来确保网络上的相关节点能够在这个对账本的更新的操作达成共识。</p><h4 id="1-0-5-3-Contract-的局限性">1.0.5.3 Contract 的局限性</h4><p>因为 contract 没有办法访问到外部的信息，它只能检查 transaction 内部的有效性，比如它不能够检查确认当前这个 transaction 是不是已经同其他相关方达成了共识取得了其他方的确认。</p><p>所以在各方提供最终的签名确认之前，各方应该对transaction 的内容进行检查来确定他们是否同意这个对账本的更新，即使这个 transaction 是合约有效的。任何一方都没有义务因为transaction是是合约有效而提供签名。比如他们可能不愿意去提供一个巨额的借款，或者可能不会同意购买一个资产花费的钱的金额。</p><h4 id="1-0-5-4-Oracles">1.0.5.4 Oracles</h4><p>有时，交易有效性将取决于某些外部信息，例如汇率。在这些情况下，需要一个oracle。有关更多详细信息，请参见Oracle。</p><h4 id="1-0-5-5-Legal-prose">1.0.5.5 Legal prose</h4><p>每一个合约也会引用一个 legal prose 文档，这个文档中定义了合约中规定的内容，legal prose 也会被传统的法律系统所接受。这个文档会在发生法律纠纷的时候被用来进行判定依据。</p><h3 id="1-0-6-Flows">1.0.6 Flows</h3><ul><li>Flows 使同意更新账本的流程变得自动化</li><li>节点之间的沟通只能够在这些 Flows 的上下文中发生，并且是点对点的</li><li>内置的 flows 提供了常用的一些任务</li></ul><p>Corda 网络使用点对点的消息传输而不是全局广播。也就是说协调一个关于账本的更新需要网络上的参与者明确的指定需要发送什么信息，发送给谁，按照什么顺序发送。</p><h4 id="1-0-6-1-Flow-框架">1.0.6.1 Flow 框架</h4><p>一个 flow 是一系列有顺序的步骤来告诉一个节点应该如何实现一个指定的账本更新，比如发行一个资产或者结算一笔交易。<br>下边是一个上边图片所描述的简单账本更新所涉及到的顺序的流程：</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/flow-sequence.png" alt="_images/flow-sequence.png" style="zoom:30%;"><h4 id="1-0-6-2-运行-flows">1.0.6.2 运行 flows</h4><p>一旦一个业务流程被封装在了一个 flow 中并且在节点中作为 CorDapp 的一部分被安装好之后，节点的所有者可以在任何时间通过使用一个 RPC call 来告诉节点开始这个业务流程。Flow 将所有的网络，I/O 和并发问题都抽象了出来，这个节点 owner 就不需要关注这些了。</p><p>节点上所有的动作都是发生在这些 flows 的上下文上的。与 contract 不同，flows 不是在 sandbox 里执行的，也就是说节点可以在执行一个 flow 的过程中来进行一些动作比如 networking，I/O 或者随机地使用一些资源。</p><h4 id="1-0-6-3-节点内部通信">1.0.6.3 节点内部通信</h4><p>节点间是通过在不同的 flows间传递消息来进行沟通的。每个节点有0个或者多个注册的 flow classes 来回复另外个一个单独的 flow 的消息。</p><p>假设 Alice 是网络中的一个节点，并且她希望同 Bob（网络中的另一个节点） 一起同意一次账本的更新。为了跟 Bob 进行沟通， Alice 必须：</p><ul><li>开始一个 Bob 已经注册过的 flow</li><li>Alice 在这个 flow 的上下文中给 Bob 发送一个消息</li><li>Bob 会启动它注册的这个 conterparty flow</li></ul><p>连接已经建立起来了，Alice 和 Bob 就可以像 flow 步骤中描述的那样来回地沟通关于一个更新账本的改动并且最终达成一致。</p><h4 id="1-0-6-4-Subflows">1.0.6.4 Subflows</h4><p>Flows 可以通过在另外一个 flow 的上下文中开始一个新的 flow 作为一个子流程的方式被组成。作为子流程被启动的 Flow 被称为 subflow。父 flow 需要等待所有的 subflow 完成后才会继续运行。</p><h4 id="1-0-6-5-Flow-类库">1.0.6.5 Flow 类库</h4><p>Corda 对于一些常规的任务都提供了一套代码库（<a href="https://cncorda.readthedocs.io/zh_CN/latest/api-flows.html" target="_blank" rel="noopener">API: Flows</a>），所以开发者就不需要自己去定义这些常见流程背后的逻辑了，比如：</p><ul><li>公正和记录一个 transaction</li><li>从相关节点搜集签名</li><li>验证交易链</li></ul><h4 id="1-0-6-6-并发">1.0.6.6  并发</h4><p>Flow 框架允许节点可以同时运行多个 flows。这些 flows 可能由于节点的重启甚至升级会持续几天。<br>这个可以通过在 flow 变成阻塞的状态的时候，将 flows 序列化到硬盘中的方式来实现（比如他们在等待 I/O 或者是网络的调用）。出现这种情况的时候，节点不会等待这个阻塞状态的 flow变成非阻塞的状态，而会立即运行其他的 flow，只会在稍后返回到原来这个阻塞的flow。</p><h3 id="1-0-7-consensus-共识">1.0.7 consensus(共识)</h3><ul><li>为了交易能够被提交，transaction 必须要同时满足有效性和 唯一性的共识</li><li>有效性共识需要 transaction 和 它的所有依赖都是合约有效的</li><li>唯一性共识可以避免“双花”</li></ul><h4 id="1-0-7-1-两种类型的共识">1.0.7.1 两种类型的共识</h4><p>判断一个交易的提案是否是一次有效的账本更新要达到两种类型的共识：</p><ul><li>有效性共识：这给是交易所要求的签名者在提供他们签名之前去校验的</li><li>唯一性共识：这个只会被 notary service 去验证</li></ul><h5 id="1-0-7-1-1-有效性共识">1.0.7.1.1 有效性共识</h5><p>有效性共识是关于验证下边所描述的条件对于提交的 transaction 和生成该该 transaction 的 inputs 的交易链中的每次 transaction 都必须要满足：</p><ul><li>Transaction 中的每个 input 和 output 的 contracts 所接受</li><li>Transaction 得到了所有要求的签名</li></ul><p>仅仅检查交易提案本身信息是不够的。我们还需要检查跟产生当前这个 transaction 的 inputs 有关的所有以前的 transaction 链。<br>这个被称作 walking the chain。假设，例如网络中的一个节点提交了一个交换债券的一笔交易。我们只有了解下边的情况才能确保这个债券的交换是有效的：</p><ul><li>这个债券应该是由中心银行发行的，而且应该是在一次有效的发行交易中</li><li>关于这个债券的后续交易记录也应该都是有效的</li></ul><p>确保两点都满足的唯一方式就是查看整个交易链。我们可以用下图表示：</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/validation-consensus.png" alt="_images/validation-consensus.png" style="zoom:30%;"><p>当确认一个交易提案的时候，给定的一方可能没有它需要验证的交易链上的所有交易信息。这种情况下，他可以向交易的提出方索要缺少的那部分交易。交易的提出方应该永远会有整个的交易链信息，因为他们应该在验证之前的交易中已经获取了相关的交易链信息。</p><h5 id="1-0-7-1-2-唯一性共识">1.0.7.1.2 唯一性共识</h5><p>设想一下 Bob 持有有效的由中央银行发行的 $1,000,000 现金 state。Bob 可以创建两个交易提案：</p><ul><li>一笔交易要跟 Charlie 用这 $1,000,000 交换 £800,000</li><li>一笔交易要跟 Dan 用这 $1,000,000 交换 €900,000</li></ul><p>这会是一个问题，因为尽管这两笔交易都可以通过有效性共识，但是 Bob 确实现了一次“双花 double spend” 他的美元来获得了两倍价值的 GBP 和 EUR。我们可以用下图表示这个流程：</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/uniqueness-consensus.png" alt="_images/uniqueness-consensus.png" style="zoom:30%;"><p>为了避免这样的问题发生，一个有效的交易提案同时也要满足唯一性共识。唯一性共识要求一个 transaction 的 input 不能被任何其他的 transaction 消费掉过。</p><p>当一个交易中的一个或多个 inputs 已经被其他的交易消费掉的情况，通常被称为 双花，那么相关的交易应该被视为无效的交易。</p><p>唯一性共识是由 notaries 提供的。查看 Notaries 了解更多详细信息。</p><h3 id="1-0-8-Notaries">1.0.8 Notaries</h3><ul><li>Notary 集群避免 “双花”</li><li>Notary 集群也可以是时间戳授权。如果一笔交易包含一个 time-window，那么它只能在这个 time-window 内被公证</li><li>Notary 集群也可以可选地用来验证交易，在这种情况下他们被称为 “用于验证” 的 notaries，相对于 “非验证” 的 notaries</li><li>一个网络中可以有多个 notaries，每一个 notary 运行一个不同的共识算法</li></ul><h4 id="1-0-8-1-概览">1.0.8.1 概览</h4><p>一个 notary 集群 是一个网络服务，通过证明一个给定的交易的 input 是没有被其他的交易消费过的方式提供了 唯一性共识。</p><p>当被要求为一笔交易进行公证的时候，一个 notary 集群会进行下边两种操作中的一种：</p><ul><li>如果对于给定的交易中的 input，没有任何其他的交易已经消费该 input 的时候，会提供签名</li><li>拒绝这笔交易并且标明产生了双花的情况</li></ul><p>通过这样做，notary 集群就在系统中提供了一个终结点。在最终获得 notary 集群的签名之前，交易各方并不能确定交易的有效性。但是当收到了 notary 集群的签名之后，我们可以确认的是，交易中的 Input 是没有被其他任何的交易所消费过的。因此公证（notarisation）在系统里是最后的一步。</p><p>每个 state 都会有一个指定的 notary 集群，而且一个 notary 集群也只会去公正那些 input 指定它为 notary 集群的 transaction。</p><h4 id="1-0-8-2-共识算法">1.0.8.2 共识算法</h4><p>Corda 拥有一套 “可插拔” 的共识，允许 notary 集群根据不同的需求（私有化、扩展性、法律系统的兼容性和算法的便捷性）来选择一种共识算法。</p><p>特别的，notary 集群可能含有下边的不同：</p><ul><li>结构： 一个 notary 集群可能是一个单独的网络节点，或者是互相信任的节点集群，或者是互不信任的节点集群</li><li>共识算法： 一个 notary 集群可能会选择运行一个高速，高信任的算法（比如 RAFT），或者一个低速低信任的算法（比如 BFT），又或者是任何其他的选择的共识算法</li></ul><h4 id="1-0-8-3-验证">1.0.8.3 验证</h4><p>一个 notary 集群还需要选择是否在提交之前通过验证每个 transaction 的有效性来提供这种 有效性共识 服务。为了做出这个选择，他们需要面对下边的取舍问题：</p><ul><li>如果一个 transaction 没有 被验证了正确与否（非验证 notary），那么这就增加了 “denial of state” 袭击的风险，指的就是某个节点知道这是一个不正确的 transaction 会消费到一些 states，然后该节点还是把这个 transaction 发送给 notary 集群，但是 notary 如果不进行正确性验证的话，会把这个 state 变为历史记录被消费掉，这显然是不正确的</li><li>如果 transaction 已经 被验证了正确与否（验证 notary），notary 需要查看该 transaction 的全部内容以及它的所有依赖。这就向 notary 暴露了一些潜在的隐私数据。</li></ul><p>当我们考量这些取舍的时候，有一个后续观点需要始终要考虑的。对于非验证模式，Corda 的控制的数据分布模型意味着未被消费的 states 不会被大面积的共享。另外， Corda 的 permissioned network 也意味着 notary 能够存储造成 “denial of state” transaction 的一方的身份信息，这就允许能够在账本外去解决掉这个袭击。</p><p>对于验证模式，对于匿名的使用，使用新生成的公钥而不是使用法律的标识来标记一笔交易的各方也限制了 notary 集群能够看到的信息。</p><h4 id="1-0-8-4-数据的可视性">1.0.8.4 数据的可视性</h4><p>下边是关于哪些特殊的交易组件必须要暴露给每种类型的 notary 的一个总结：</p><table><thead><tr><th><strong>Transaction components</strong></th><th><strong>Validating</strong></th><th><strong>Non-validating</strong></th></tr></thead><tbody><tr><td>Input states</td><td>Fully visible</td><td>References only [1]</td></tr><tr><td>Output states</td><td>Fully visible</td><td>Hidden</td></tr><tr><td>Commands (with signer identities)</td><td>Fully visible</td><td>Hidden</td></tr><tr><td>Attachments</td><td>Fully visible</td><td>Hidden</td></tr><tr><td>Time window</td><td>Fully visible</td><td>Fully visible</td></tr><tr><td>Notary identity</td><td>Fully visible</td><td>Fully visible</td></tr><tr><td>Signatures</td><td>Fully visible</td><td>Hidden</td></tr></tbody></table><p>两种类型的 notaries 都会记录调用方的身份信息：公钥以及 X.500 唯一的名字。</p><h4 id="1-0-8-5-多个-Notaries">1.0.8.5 多个 Notaries</h4><p>每个 Corda 网络可以存在多个 notary 集群，每个 notary 集群可能会运行一套不同的共识算法。这会带来以下的好处：</p><ul><li><strong>隐私性</strong> - 我们可以在同一个网络中同时拥有验证和非验证的 notary 集群，每个集群运行着不同的算法。这就允许节点针对每个 transaction 来选择更喜欢的不同的 notary。</li><li><strong>负载平衡</strong> - 将 transaction 的工作分发给多个 notary 集群可以提高平台整体的交易吞吐量</li><li><strong>低延迟</strong> - 通过选择物理上离交易方最近的 notary 集群来获得最小化的延迟</li></ul><h4 id="1-0-8-6-更换-notaries">1.0.8.6 更换 notaries</h4><p>一个 notary 集群只有当它是这个 transaction 里的所有 input states 指定的 notary 的情况下才可以提供签名。然而下边的情况可能需要换一个 state 的指定的 notary 集群，包括：</p><ul><li>当一个 transaction 需要消费的 states 中指定了不同的 notary 集群</li><li>当一个节点因为隐私和效率的考虑希望选择一个不同的 notary 集群</li></ul><p>当这样的 transactions 被创建之前，states 必须首先被指定到同一个 notary 集群。这可以通过一个改变 notary 的 transaction 来实现:</p><ul><li>一个 input state</li><li>output state与input state相同，但指定的notary群集已更改</li></ul><p>如果该 transaction 不会造成“双花”，这个 input state 指定的 notary 会为该 transaction 提供签名，这种情况下，一个新的 state 会产生，它的所有属性和旧的 state相同，但是会指向一个不同的 notary 集群。</p><h3 id="1-0-9-Vault">1.0.9  Vault</h3><p>Vault 中存储的是跟节点的所有者相关的从账本上得到的数据，以关系模型存储以方便查询和使用。</p><p>Vault 同时会追踪未消费掉的和已消费掉的 states：</p><ul><li><strong>Unconsumed</strong>：未消费掉的 （或者未使用的） states 代表了可以用来花费的 fungible states （包括 spend-to-self 交易）以及可以用来更新的 linear states （比如对于一笔交易的生命周期）或者从一方转换给另一方。</li><li><strong>Consumed</strong>：已消费掉的 （或者已使用的） states 代表了为了交易报表、审计和归档的目的而在账本上存储的不可更改的 state，包括进行同 app-private 数据进行关联的能力（比如客户的 notes）。</li></ul><p>一个称为 soft locking 的功能提供了自动或者显式地预定 states 而避免同一个节点尝试同时在多笔交易中使用相同的 output 的能力。这种情况最终会被一个 notary 发现，soft locking 提供了一种能够在早期就发现这种无根据和不正确的情况的机制。Soft Locking 提供了更详细的的关于这个功能的描述。</p><p>Vault 支持管理需授权的（“on-ledger”）的数据，也可以管理 shadow（“off-ledger”）形式的数据：</p><ul><li>“On-ledger” 数据指的是指公司参与的分布式账本的state （现金、交易、）。</li><li>“Off-ledger” 数据指的是公司内部的参考数据、静态或者系统数据。</li></ul><p>下边的图表展示了将 vault 拆分为子系统组件：</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/vault.png" alt="_images/vault.png" style="zoom:80%;"><p>注意以下几点：</p><ul><li>Vault “On Ledger” 存储并追踪未消费掉的 state，并且在将一笔交易记录到账本的时候由节点内部进行更新（会按照成功执行了智能合约验证以及受到所有参与方的签名）</li><li>Vault “Off Ledger” 存储了交易记录以外节点的所有者添加的额外的数据</li><li>Vault 对 fungible state 进行了花费（并且在将来，fungible state 的优化管理包括合并、拆分以及再发行）。</li><li>Vault 扩展代表了开发者可以编写的额外的自定义 plugin 代码，用来查询指定的自定义 contract state 属性。</li><li>客户的 “Off Ledger”（私有的存储）代表了内部的组织型数据，可能被用来跟 vault 数据进行关联来进行额外的报表或者处理。</li><li><a href="https://cncorda.readthedocs.io/zh_CN/latest/api-vault-query.html" target="_blank" rel="noopener">Vault Query API</a> 可以使用标准的 Corda RPC 和 CorDapp plugin 机制暴露给开发者。</li><li>Vault 更新 API 可以被交易记录的 flows 内部使用。</li><li>Vault 数据库 schemas 可以通过 JDBC 和自定义的 joins 和查询进行直接地访问。</li></ul><h3 id="1-0-10-Time-windows">1.0.10 Time-windows</h3><ul><li>如果一个 transaction 包含了一个 time-window，那么这个 transaction 只能在这个 time-window 里被提交</li><li>Notary 具有控制发生的时间的权利，当在 time-window 之外的时候，notary 可以拒绝提交 transaction</li><li>Time-window 可以有开始和结束时间，或者只有两者之中的一个</li></ul><h4 id="1-0-10-1-分布式系统中的时间">1.0.10.1 分布式系统中的时间</h4><p>Notary 也可以作为 时间戳的验证者，在它确认一笔交易前，需要确保这笔交易是发生在指定的时间窗里。</p><p>为了让一个时间窗有意义，它必须要在一方请求它的时候被绑定。一方可以获得一个 time-window 的签名，以此来证明有些事件是在特定时间点 之前、当时 或者 之后 发生的。然而，如果交易参与者不能够在指定的 time-window 内提交到相关的交易，它可以选择是否在未来的某个时间点将这个事实暴露出去。因此，我们需要确保 notary 或者能够在一些可容错的时间范围内对交易进行签名，或者同时进行打时间戳 和 对交易进行公证。后边的这种方式是这个模型中使用的方式。</p><p>在创建交易的一方和 notary 之间是无法实现时间的同步的。这并不仅仅是因为物理或者网络的延迟，还会因为在插入命令和获得 notary 签名之间可能会发生很多其他的步骤（比如发送交易到涉及到的其他节点，请求人工的审批等）。所以交易被发送到 notary 的时间和交易创建的时间可能会不同。</p><h4 id="1-0-10-2-Time-windows">1.0.10.2 Time-windows</h4><p>因为上面的原因，交易中涉及到的时间会被制定为一个时间窗，而不是一个绝对的时间。在一个分布式系统中是永远不会有 “真实的时间” 的，只有一个大概的时间。时间窗可以是开放的（比如在某个时间点后，或者某个时间点之前）或者是一个闭合的范围。</p><p>通过这种方式，我们表达了我们的想法，就是 “当前的时间” 永远都是未知的。甚至当在某个时间之前和之后都被包含的时候，交易也可能会在那个时间窗中的任何时间发生。</p><p>通过在一端创建一个关闭或者开放的范围，我们允许用以下的方式生成时间窗模型：</p><ul><li>一笔交易在指定时间之后的某个时间发生（比如在一个终止事件之后）</li><li>一笔交易在指定时间之前的任何时间发生（比如破产事件之前）</li><li>一笔交易在指定时间区间的某个时间发生（比如在指定的某一天）</li></ul><h3 id="1-0-11-Oracles">1.0.11 Oracles</h3><ul><li>一个事实（fact）可以作为 command 的一部分被添加到一个 transaction 中</li><li>一个 oracle 是一个服务，它只会为那些包含正确事实的 transaction 提供签名</li></ul><p>很多时候 transaction 的合约有效性需要依赖一些外部的数据，比如当前的汇率是多少。如果让每个参与方给予他们对于汇率的观点来验证 transaction 的有效性的话，合约的执行就会变得没有确定性了：一些参与者可能会认为 transaction 是有效的，而其他的参与者可能认为无效。因此，在真正账本中的 state 之上就会提出一些不同的意见。</p><p>Corda 通过使用 Oracle 来解决这个问题。Oracle 是一个网络服务，可以根据要求提供包含某一事实的命令（比如在某个时间的汇率）并且将 Oracle 列为要求签名的一方。</p><p>如果一个节点希望在一个 transaction 中使用某一个事实，那么它可以提出从 Oracle 来获取该事实的一个命令。如果 Orale 认为这个事实是正确的，它会返回这个要求的命令。然后这个节点就可以把这个命令添加到 transaction 中了，然后 oracle 会为这个事实是真的提供签名。</p><p>为了隐私性的目的，Oracle 不需要能够访问交易的每个部分，他们唯一需要的信息就是看到他们内置的、跟这个 Oracle 相关的 command(s)。我们也应该提供让这些需要提供签名的 Oracle 实体能够看到这些 commands 的保证，但是不包括其他的部分。为了实现这个，我们使用过滤过的交易，是指交易的提案方使用一个内嵌的默克尔树的方式来将一些非相关的交易的部分隐藏掉。查看 Transaction tear-offs 了解关于交易如何拿掉工作的详细信息。</p><p>如果他们想为他们的服务定价，Oracles 可以选择只为那些包含服务费的交易提供签名并证明它包含的事实的有效性。</p><h3 id="1-0-12-node（节点）">1.0.12 node（节点）</h3><ul><li>Corda 中的节点指的是在网络中具有唯一标识的运行着 Corda 服务和 CorDapps 的 JVM 运行时环境。</li><li>节点对于外部世界包含两个接口：<ul><li>网络层，用来同其他的节点通信</li><li>RPC，为了跟节点的所有者通信</li></ul></li><li>节点的功能是通过在 plugin registry 里安装 CorDapps 方式来扩展的</li></ul><h4 id="1-0-12-1-节点架构">1.0.12.1 节点架构</h4><p>下边是节点的内部架构图：</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/node-architecture.png" alt="_images/node-architecture.png" style="zoom:40%;"><p>架构中的核心元素包括：</p><ul><li>存储数据的持久化层</li><li>同其他节点沟通的网络接口</li><li>同节点的所有者进行沟通的 RPC 接口</li><li>允许节点的 flows 来调用节点其他服务的 service hub</li><li>plugin registry 用来通过安装 CorDapps 来扩展节点</li></ul><h4 id="1-0-12-2-持久层">1.0.12.2 持久层</h4><p>持久层包含两部分：</p><ul><li>Vault，节点用来存储相关的当前和历史的 states 数据</li><li>存储服务，用来存储 transaction, attachment 和 flow checkpoints<br>节点的所有者可以通过使用 RPC 接口来查询节点的 storage。</li></ul><h4 id="1-0-12-3-网络接口">1.0.12.3 网络接口</h4><p>同网络中的其他节点进行沟通是节点自己来处理的，作为运行一个 flow 的一部分。节点的所有者不会直接地同网络中其他的节点进行交互。</p><h4 id="1-0-12-4-RPC-接口">1.0.12.4 RPC 接口</h4><p>节点的所有者是通过使用 Remote Procedure Calls(RPC) 来跟节点进行交互的。关键的节点暴露的 RPC 操作可以查看 <a href="https://cncorda.readthedocs.io/zh_CN/latest/api-rpc.html" target="_blank" rel="noopener">API: RPC 操作</a>。</p><h4 id="1-0-12-4-The-service-hub">1.0.12.4 The service hub</h4><p>在节点内部，节点可以在 flow 的执行过程中访问丰富的服务来协助更新账本。主要的服务包括：</p><ul><li>有关网络上其他节点及其提供的服务的信息</li><li>访问 vault 和存储服务的内容</li><li>访问和生成节点的公钥私钥对</li><li>节点本身的信息</li><li>节点跟踪的当前时间</li></ul><h4 id="1-0-12-5-CorDapp-提供者">1.0.12.5 CorDapp 提供者</h4><p>CorDapp 提供者是新的 CorDapps 被安装的地方，来扩展节点的行为。</p><p>节点默认会安装一些 CorDapps 来处理一些常见的任务，比如：</p><ul><li>从合作方那边获得交易和附件信息</li><li>更新合约</li><li>向交易其他方广播同意的账本更新信息</li></ul><h4 id="1-0-12-6-排空节点模式">1.0.12.6 排空节点模式</h4><p>为了执行一次干净的关闭节点操作，没有正在执行的 flows 非常重要，也就是说应该没有任何的 checkpoints 被持久化。节点能够被设置为排空状态，在这个状态中：</p><ul><li>通过 RPC 要求的启动新的 flows 的命令会被拒绝</li><li>预约的 flows 会被忽略</li><li>初始化 P2P 的会话消息将不会被处理，意味着 peers 将不能够初始化新的 flows</li><li>其他所有的活动还会照常进行，来确保正在执行的 flows 的数量在不断减少。</li></ul><p>对于他们的数量 - 可以通过 RPC 来进行监控 - 达到0，那么就是安全的了，可以进行关闭节点的操作了。这个属性是持久的，也就是说重新启动这个节点也不会重置这个值到默认和值，并且需要一个 RPC 命令。</p><p>节点可以使用 shell 来被排空然后安全地关闭。</p><h3 id="1-0-13-Transaction-tear-offs（交易剥离）">1.0.13 Transaction tear-offs（交易剥离）</h3><ul><li>隐藏交易组件出于隐私目的</li><li>Oracle和非验证公证人只能看到其“相关”交易组件，而不能看到完整的交易详细信息</li></ul><h3 id="1-0-13-1-总览">1.0.13.1 总览</h3><p>在某些情况下，交易中涉及的某些实体可能只对交易部分具有部分可见性。例如，当一个甲骨文应该签署一个交易时，它唯一需要查看的信息就是与该甲骨文命令相关的嵌入式信息。同样，非验证公证人只需要查看交易的输入状态即可。向Oracle提供任何其他交易数据将构成隐私泄漏。</p><p>为了解决这个问题，我们使用过滤交易的概念，其中交易提议者使用嵌套的默克尔树方法“剥离”Oracles/Notraries不需要的交易任何部分，然后再提交给他们进行签名。默克尔树是一种众所周知的加密方案，通常用于提供包含和数据完整性的证明。 Merkle树被广泛用于对等网络，区块链系统和git。</p><p>默克尔树的优点是，在向Oracle提交交易时被剥离的交易部分以后就无法更改，而又不会使Oracle的数字签名无效。</p><h3 id="1-0-13-2-Transaction-Merkle-trees">1.0.13.2 Transaction Merkle trees</h3><p>通过将transaction拆分为叶子，从transaction中构造Merkle树，其中每个叶子包含输入，输出，命令或附件。最终的嵌套树结构还包含事务的其他字段，例如时间窗口，公证人和必需的签名者。<br>如下图所示，唯一需要两棵树而不是一棵树的组件类型是command，为了可视性目的，该命令分为命令数据和必需的签名者。</p><p>Corda使用每种组件类型的嵌套Merkle树。简而言之，针对每种组件类型（即输入，输出，附件）生成一个组件子树。然后，这些子树的根形成顶部的Merkle树的叶子，最后，该树的根代表交易ID。</p><p>另一个重要特征是，以每个随机数独立的方式为每个组件确定性地生成一个随机数。然后，我们使用随机数及其对应的组件来计算组件哈希，即实际的Merkle树叶。需要使用随机数来防止暴力攻击，否则可能会泄露低熵散列值（即单个单词的文本附件）的内容。</p><p>计算完叶子后，通过散列当前节点下面的哈希值的连接，以正常方式构建每棵Merkle树。</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/merkleTreeFull.png" alt="img" style="zoom:60%;"><p>上图中的交易有三个input，两个output，两个command，一个attachment，一个notary和一个 time-window。请注意，如果树不是完整的二叉树，则将叶子填充为具有零哈希值的最接近的2的幂（因为找到sha256（x）== 0的原像是困难的计算任务）-上面标记为浅绿色。最后，根的哈希是交易的标识符，它也用于签名和验证数据完整性。叶子级别上的每次交易更改都会更改其标识符。</p><h3 id="1-0-13-3-Hiding-data">1.0.13.3 Hiding data</h3><p>隐藏数据并提供证明它构成事务一部分的证据是通过构造部分Merkle树（或Merkle分支）来完成的。 Merkle分支是一组散列，根据叶的数据，这些散列用于计算根的散列。然后，将该哈希与整个交易的哈希进行比较，如果它们匹配，则意味着我们获得的数据属于该特定交易。</p><p>假设只有第一个命令对Oracle是可见的。我们还应该保证所有需要该Oracle签名的命令对于Oracle实体都应该是可见的，而其余部分则不可见。这是此过滤后的交易将如何在Merkle树结构中表示的方式。</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/SubMerkleTree_Oracle.png" alt="_images/SubMerkleTree_Oracle.png" style="zoom:30%;"><p>向Oracle服务提供了蓝色节点和H(c2)，而省略了黑色节点。 HH(c2)是必需的，这样Oracle可以计算H(commandData)而不必看到第二条命令，但同时确保CommandData1是事务的一部分。突出显示所有签名者都是可见的，以证明没有恶意删除任何相关命令（Oracle应该看到）。此外，当前的Corda协议中还提供了子树的哈希（紫色节点）。在特殊情况下需要知道他们下面的数据，例如需要知道组件组是否为空时。</p><p>同样，如果我们想将同一交易发送给非验证notary，则应隐藏除输入状态，时间窗口和公证人信息之外的所有组件。该数据足以使公证人知道应检查哪些input statues进行双花，时间窗口是否有效以及此事务是否应由该notary公证。</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/SubMerkleTree_Notary.png" alt="_images/SubMerkleTree_Notary.png" style="zoom:30%;"><h3 id="1-0-14-权衡">1.0.14 权衡</h3><ul><li><em>许可的网络会更好的适合金融的 user-cases</em></li><li><em>点对点的通信允许信息是基于需要知道的原则被共享</em></li><li><em>UTXO model 允许每秒钟能够处理更多的 transactions</em></li></ul><h4 id="1-0-14-1-需要许可-vs-和不需要许可的">1.0.14.1 需要许可 vs 和不需要许可的</h4><p>传统的 blockchain 是 不需要许可 的。网络中的各方都是匿名的，而且可以随时加入或离开。</p><p>不同的是， Corda 网络是 需要许可 的。网络中的每一方都有一个大家都知道的标识，这个会在同其他节点进行沟通的时候使用，并且访问网络是由一个 doorman 来控制的。这有一下的好处：</p><ul><li>匿名的用户对于大多数跟金融有关的情况都是不适用的</li><li>知道你的合作方的身份可以允许当出现冲突的时候，可以使用已经存在的法律系统在账本外进行解决</li><li>可以不通过使用昂贵的机制（比如工作量证明 proof-of-work）来避免女巫攻击（Sybil attacks）</li></ul><h4 id="1-0-14-2-点对点-vs-全局广播">1.0.14.2 点对点 vs 全局广播</h4><p>传统的 blockchain networks 将每一条信息广播给网络上的所有参与者。原因是：</p><ul><li>合作方的身份是不知道的，所以一条消息需要发给网络上的所有人来确保原本需要收到这条消息的接受者能够接收到</li><li>让所有参与者知道每一个 transaction 能够允许网络防止“双花”<br>不好的地方是所有的参与者都能看到所有其他人的数据。这在很多的 use-cases 是无法接受的。</li></ul><p>在 Corda 中，每条消息都会指定一个具体的合作方，而且是不会被任何其他无关方看到的。开发者能够完全掌控什么消息被发送了，发送给了谁，应该按照什么顺序发送。所以 数据是根据需要知道的原则来共享的。为了避免“双花”，我们引入了 notaries 来替换掉工作量证明（proof-of-work）。</p><p>Corda 也是用了其他的一些技术来最大化的包括网络上的隐私：</p><ul><li><strong>Transaction 隐藏</strong>：Transactions 被结构化成不暴露 transaction 的内容就可以被数字化地签名。这个是通过使用一种叫默克尔树的数据结构来实现的。</li><li><strong>随机化秘钥</strong>：一个 transaction 的所有参与方是通过他们的公钥进行识别的，并且针对每一个 transaction 都会生成 一个新的 keypairs。所以一个监视者无法识别出来对于一个给定 transaction 都哪些方参与了。</li></ul><h4 id="1-0-14-3-UTXO-vs-账户模型">1.0.14.3 UTXO vs. 账户模型</h4><p>Corda 使用 <em>UTXO</em>（Unspent Transaction Output）model。每个 transaction 都会消费一系列的已经存在的 states 然后再生成一些新的 states。</p><p>相反的一种方式是 账户 模型。在账户模型中，stateful 对象被存在账本上，transaction 会通过请求的方式来对这些对象的当前的 state 进行更新。</p><p>UTXO 模型的主要优点在于含有不同的 inputs 的 transactions 能够并行地被执行，很大程度上地增加了网络中每秒能够处理的 transactions。在账户模型中，每秒钟能够处理的 transactions 数量有限，因为对于一个给定的 object 的更新需要按照给定的顺序来执行。</p><h4 id="1-0-14-4-代码即法律-vs-既有的法律系统">1.0.14.4 代码即法律 vs. 既有的法律系统</h4><p>金融体系需要在需要的时候使用传统的法律体系来解决冲突的能力。Corda 被设计用来使这个成为可能：</p><ul><li>拥有需要准入的网络，意味着所有参与方都能够知道在每一个 transaction 中他们都在跟谁打交道</li><li>所有代码合约背后都存在有描述着合约意图行为的法律文档，这个文档可以在解决冲突的时候使用</li></ul><h4 id="1-0-14-5-构建-vs-重用">1.0.14.5 构建 vs. 重用</h4><p>任何可能的情况，Corda 会使用 已经存在的技术来让这个平台更加的健壮。比如 Corda 重用了：</p><ul><li>用于开发CorDapps的标准JVM编程语言</li><li>已经存在的 SQL database</li><li>已经存在的 消息队列实现</li></ul><h3 id="1-0-15-Deterministic-JVM">1.0.15 <a href="https://cncorda.readthedocs.io/zh_CN/latest/key-concepts-djvm.html" target="_blank" rel="noopener">Deterministic JVM</a></h3><p><strong>个人理解</strong>：为了达成共识，Corda要求所有的节点运行相同的JVM沙箱，叫做DJVM；DJVM为了让智能合约的代码每次执行的结果都相同而做了一些限制。</p><h2 id="1-1-开发语言语言是什么？">1.1 开发语言语言是什么？</h2><ul><li>开发语言与智能合约的语言都是使用 JVM 编程语言编写（java 或者 kotlin）</li><li>源码使用kotlin语言编写</li></ul><h2 id="1-2-网络是什么样的？">1.2 网络是什么样的？</h2><p>可以选择加入<a href="https://corda.network/" target="_blank" rel="noopener">corda.network</a>，Corda Network由总部位于荷兰的非营利基金会管理。 Corda Network参与者有资格投票并代表基金会董事会做出重要决定，包括网络标准，参数和政策。</p><p>或者搭建自己的私有网络，<a href="https://www.r3.com/download-corda-enterprise-network-manager/" target="_blank" rel="noopener">下载corda网络管理软件，需要填写信息</a></p><h2 id="1-3-Corda是如何达成共识的？">1.3 Corda是如何达成共识的？</h2><p>假如A发起一个交易给B转账500元，那么A需要提交一个交易（transaction）并签名；然后把交易发送给B（如果需要Notary和Oracle参与也会把need-to-know的部分发送给他们）；B验证交易没有问题（包括整个交易链、智能合约是否验证通过、是否同意当前的交易、Notary和Oracle是否签名等）就会提供签名然后提交这次交易。并把签名后的交易发送给A，A也执行相同的提交交易动作。</p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/flow-sequence.png" alt="_images/flow-sequence.png" style="zoom:30%;"><h2 id="1-4-CorDapps是什么？">1.4 CorDapps是什么？</h2><p>CorDapps是以plugin的形式运行在node上的“应用”；一个node可以有多个CorDapps，比如一个银行的node可以既有贷款的CorDapp，也有存款的CorDapp。</p><p>CorDapp包含state, transaction, contract和flow类。</p><h2 id="1-5-Corda的隐私保护是怎么做的？">1.5 Corda的隐私保护是怎么做的？</h2><h3 id="1-5-1-在网络中的各节点之间的隐私保护">1.5.1 在网络中的各节点之间的隐私保护</h3><p>Corda的网络需要申请加入并且对应了现实世界中的一个合法身份，所以不可以把交易信息公开。</p><p>Corda的交易是通过一个节点发起的，除了交易涉及的其他节点知道全部的交易内容；和Oracle以及Notary知道交易的部分需要验证的内容之外，对其他节点来说是不知道这个交易的。所以在隐私性方面是比较好的。</p><p><em>比特币和以太坊中的身份信息与现实世界的身份是没有对应关系的，所以把所有的账户和交易信息放在互联网上也是安全的。</em></p><h3 id="1-5-2-在验证双花和依赖Oracle签名时的隐私保护">1.5.2 在验证双花和依赖Oracle签名时的隐私保护</h3><p>Corda通过<strong>Transaction tear-offs</strong>的方式在需要Notary做唯一性校验或需要Oracle提供签名时，提供的只有need-to-know的部分，并不包含交易的所有内容，所以隐私得到了保护。</p><h2 id="1-6-Corda交易的实时性怎么样？">1.6 Corda交易的实时性怎么样？</h2><p>Corda交易相较于比特币和以太坊来说比较实时，因为Corda不必等待挖矿只要交易被校验通过，所有人都签了名就写在了区块链上了。（以太坊和比特币需要在挖到矿之后打包很多个交易，所以实时性会差一些）</p><h2 id="1-7-Corda中是否有以太坊中的账本的概念？">1.7 Corda中是否有以太坊中的账本的概念？</h2><p><strong>个人理解</strong>：Corda也有账本的概念，但是Corda账本所包含的内容远比以太坊的账本（只有余额）要多；Corda的账本有很多不同类型的state，Corda只保管了当前的state和历史state，但是Corda没有一个汇总的显示余额的“账本”；应该可以在账本外记录。</p><h2 id="1-8-Corda中账户（Accounts）是什么？">1.8 Corda中账户（Accounts）是什么？</h2><p>Corda中的Accounts是一个虚拟的概念，值得是一个节点的Vault的states打上标签来表示归属的账户；这个账户和节点的账户不一样，Account就像个人在银行（节点）开的账户（Account）。</p><h2 id="1-9-Corda可以发布币吗？可以挖矿吗？">1.9 Corda可以发布币吗？可以挖矿吗？</h2><p>没有数字货币，因此也不能挖矿。因为共识协议也并不是通过工作量证明完成，而是通过交易的涉及方和一些公证人和Oracle来达成共识的，所以也不需要挖矿。</p><h2 id="1-10-Corda的Contract和以太坊中的智能合约有什么区别？">1.10 Corda的Contract和以太坊中的智能合约有什么区别？</h2><h3 id="不同点：">不同点：</h3><p>Corda的Contract主要是为了来做验证交易是否正确的，不可以做以太坊智能合约的转账的操作。</p><p>以太坊中的智能合约是一个特殊的账户，里面有余额、交易次数、代码、存储等；但是Corda的Contract只有代码，只用来验证交易是否正确。</p><h3 id="相同点：">相同点：</h3><p>只要执行中遇到异常就表示验证不通过；能够证明交易非法（不符合合约内容）。</p><h1 id="3、如何基于Corda构建应用">3、如何基于Corda构建应用</h1><p>详情查看：</p><ol><li><p><a href="3%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AACorDapp.md">如何开发一个CorDapp</a></p></li><li><p><a href="4%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AACorda%E7%BD%91%E7%BB%9C.md">如何搭建一个Corda网络</a></p></li></ol><h1 id="4、Corda汇总">4、Corda汇总</h1><h2 id="Corda优点">Corda优点</h2><ul><li>隐私保护做的很好，交易只有涉及到的节点才知道</li><li>提供了一些通用的State类，如现金、商品、商业票据、利率交换、债务等</li><li>开发CorDapp简单，可以直接使用Java开发并且有模板和套路可循</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-Corda资料整理&quot;&gt;0. Corda资料整理&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.corda.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://www.yo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/3如何开发一个CorDapp</title>
    <link href="https://nijixucai.github.io/2020/12/11/blockchain/3%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AACorDapp/"/>
    <id>https://nijixucai.github.io/2020/12/11/blockchain/3%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AACorDapp/</id>
    <published>2020-12-11T06:19:42.000Z</published>
    <updated>2020-12-11T06:19:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境准备">环境准备</h1><ul><li>JDK（8u131以上）</li></ul><h2 id="corda训练营">corda训练营</h2><h3 id="代码地址：">代码地址：</h3><p><a href="https://github.com/corda/bootcamp-cordapp" target="_blank" rel="noopener">https://github.com/corda/bootcamp-cordapp</a></p><p>个人gitee项目：<a href="https://gitee.com/zheshiyigegexingwangzhan/bootcamp-cordapp.git" target="_blank" rel="noopener">https://gitee.com/zheshiyigegexingwangzhan/bootcamp-cordapp.git</a></p><h3 id="添加国内镜像">添加国内镜像</h3><h4 id="当前项目修改">当前项目修改</h4><p>下载代码之后为了更快的下载依赖，添加国内的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maven &#123; url &#39;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&#39;&#125;</span><br></pre></td></tr></table></figure><h4 id="直接修改全局的gradle配置">直接修改全局的gradle配置</h4><p>在**~/.gradle<strong>目录下新建</strong>init.gradle**文件，写入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">allprojects&#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        def ALIYUN_REPOSITORY_URL &#x3D; &#39;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#39;</span><br><span class="line">        def ALIYUN_JCENTER_URL &#x3D; &#39;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;repositories&#x2F;jcenter&#39;</span><br><span class="line">        all &#123; ArtifactRepository repo -&gt;</span><br><span class="line">            if(repo instanceof MavenArtifactRepository)&#123;</span><br><span class="line">                def url &#x3D; repo.url.toString()</span><br><span class="line">                if (url.startsWith(&#39;https:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#39;)) &#123;</span><br><span class="line">                    project.logger.lifecycle &quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL.&quot;</span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">                if (url.startsWith(&#39;https:&#x2F;&#x2F;jcenter.bintray.com&#x2F;&#39;)) &#123;</span><br><span class="line">                    project.logger.lifecycle &quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_JCENTER_URL.&quot;</span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url ALIYUN_REPOSITORY_URL</span><br><span class="line">            url ALIYUN_JCENTER_URL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试代码">测试代码</h3><p>运行ProjectImportedOKTest单测，如果通过说明环境没有问题</p><p>我的运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; Configure project :</span><br><span class="line">Repository https:&#x2F;&#x2F;jcenter.bintray.com&#x2F; replaced by http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;repositories&#x2F;jcenter.</span><br><span class="line">&gt; Task :compileJava</span><br><span class="line">&gt; Task :processResources NO-SOURCE</span><br><span class="line">&gt; Task :classes</span><br><span class="line">&gt; Task :compileTestJava</span><br><span class="line">&gt; Task :processTestResources NO-SOURCE</span><br><span class="line">&gt; Task :testClasses</span><br><span class="line">&gt; Task :test</span><br></pre></td></tr></table></figure><h1 id="代码开发">代码开发</h1><h2 id="State开发">State开发</h2><p>一个state需要实现ContractState，ContractState中有一个方法<code>getParticipants()</code>，返回的是<code>List&lt;AbstractParty&gt;</code>,表示在这个state发生了交易时需要通知谁，让谁知道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bootcamp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.ImmutableList;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.ContractState;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.identity.AbstractParty;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.identity.Party;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IouState</span> <span class="keyword">implements</span> <span class="title">ContractState</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发行人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Party issuer;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拥有者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Party owner;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IouState</span><span class="params">(Party issuer, Party owner, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.issuer = issuer;</span><br><span class="line">        <span class="keyword">this</span>.owner = owner;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractParty&gt; <span class="title">getParticipants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ImmutableList.of(issuer, owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Party <span class="title">getIssuer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> issuer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Party <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Contract开发">Contract开发</h2><p>一个contract简单的理解就是一些校验的规则，需要实现<code>Contract</code>类，<code>Contract</code>类如下，只有一个<code>verify</code>方法，验证<code>LedgerTransaction</code>是否正确，如果不正确就抛<code>IllegalArgumentException</code>异常。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Takes an object that represents a state transition, and ensures the inputs/outputs/commands make sense.</span></span><br><span class="line"><span class="comment">     * Must throw an exception if there's a problem that should prevent state transition. Takes a single object</span></span><br><span class="line"><span class="comment">     * rather than an argument so that additional data can be added without breaking binary compatibility with</span></span><br><span class="line"><span class="comment">     * existing contract code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Throws(IllegalArgumentException::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发一个contract时，Corda提议的三个验证的类型：</p><ul><li>输入与输出个数的校验（Shape Constraint，No. input states, No. output states, command）</li><li>输入与输出的内容的校验（Context Constraint），业务校验</li><li>需要的签名的校验（Required Singer Constraint）</li></ul><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/image-20201202115747238.png" alt="image-20201202115747238"></p><p>按照上图的规则IouContract的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bootcamp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.Command;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.CommandData;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.Contract;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.ContractState;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.transactions.LedgerTransaction;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IouContract</span> <span class="keyword">implements</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String ID = <span class="string">"bootcamp.IouContract"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verify</span><span class="params">(LedgerTransaction tx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、Shape Constraint，No. input states, No. output states, command</span></span><br><span class="line">        <span class="keyword">if</span> (tx.getCommands().size() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"command size must be one"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Command&lt;CommandData&gt; command = tx.getCommand(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!(command.getValue() <span class="keyword">instanceof</span> Commands.Issue)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"command must be Issue"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(tx.getInputs())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Issue must be not inputs"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tx.getOutputs().size() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Issue outputs must be one"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ContractState output = tx.getOutput(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 2、Context Constraint</span></span><br><span class="line">        <span class="keyword">if</span> (!(output <span class="keyword">instanceof</span> IouState)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"state must be IouState"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        IouState iouState = (IouState) output;</span><br><span class="line">        <span class="keyword">if</span> (iouState.getAmount() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"issue amount must big than zero"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、Required Singer Constraint</span></span><br><span class="line">        <span class="keyword">if</span> (!command.getSigners().contains(iouState.getIssuer().getOwningKey())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"issue business must be sing by issuer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Commands</span> <span class="keyword">extends</span> <span class="title">CommandData</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Issue</span> <span class="keyword">implements</span> <span class="title">Commands</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flow开发">Flow开发</h2><p>flow有两种</p><ul><li>可以在本地主动启动的flow</li><li>只能通过其他的flow启动的flow</li></ul><p>发起一个交易的flow都是可以在本地主动启动的flow，有以下特点</p><ul><li>需要添加注解<code>@InitiatingFlow</code>来表示他是一个可以初始化的flow</li><li>需要添加注<code>@StartableByRPC</code>或者<code>@StartableByService</code>来说明启动的方式</li><li>flow需要继承自<code>FlowLogic</code>，业务逻辑在call方法中实现</li><li>call方法需要添加<code>@Suspendable</code>注解</li><li>指定notary，校验是否双花</li><li>创建交易，交易中必须包含command，如果有output必须指定contract来进行验证；可以没有input</li><li>然后就是通用的流程，验证交易、收集签名、交易入库</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bootcamp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> co.paralleluniverse.fibers.Suspendable;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.ImmutableList;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.StateAndRef;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.*;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.identity.Party;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.transactions.SignedTransaction;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.transactions.TransactionBuilder;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.utilities.ProgressTracker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Collections.singletonList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nicai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@InitiatingFlow</span></span><br><span class="line"><span class="meta">@StartableByRPC</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IouIssueFlowInitiator</span> <span class="keyword">extends</span> <span class="title">FlowLogic</span>&lt;<span class="title">SignedTransaction</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Party owner;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IouIssueFlowInitiator</span><span class="params">(Party owner, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.owner = owner;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProgressTracker progressTracker = <span class="keyword">new</span> ProgressTracker();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProgressTracker <span class="title">getProgressTracker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> progressTracker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Suspendable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SignedTransaction <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> FlowException </span>&#123;</span><br><span class="line">        <span class="comment">// We choose our transaction's notary (the notary prevents double-spends).</span></span><br><span class="line">        Party notary = getServiceHub().getNetworkMapCache().getNotaryIdentities().get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// We get a reference to our own identity.</span></span><br><span class="line">        Party issuer = getOurIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We create our new IouState.</span></span><br><span class="line">        IouState iouState = <span class="keyword">new</span> IouState(issuer, owner, amount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We build our transaction.</span></span><br><span class="line">        TransactionBuilder transactionBuilder = <span class="keyword">new</span> TransactionBuilder(notary)</span><br><span class="line"><span class="comment">//                .addInputState()</span></span><br><span class="line">                .addOutputState(iouState, IouContract.ID)</span><br><span class="line">                .addCommand(<span class="keyword">new</span> IouContract.Commands.Issue(), ImmutableList.of(issuer.getOwningKey(), owner.getOwningKey()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We check our transaction is valid based on its contracts.</span></span><br><span class="line">        transactionBuilder.verify(getServiceHub());</span><br><span class="line"></span><br><span class="line">        FlowSession session = initiateFlow(owner);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We sign the transaction with our private key, making it immutable.</span></span><br><span class="line">        SignedTransaction signedTransaction = getServiceHub().signInitialTransaction(transactionBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The counterparty signs the transaction</span></span><br><span class="line">        SignedTransaction fullySignedTransaction = subFlow(<span class="keyword">new</span> CollectSignaturesFlow(signedTransaction, singletonList(session)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We get the transaction notarised and recorded automatically by the platform.</span></span><br><span class="line">        <span class="keyword">return</span> subFlow(<span class="keyword">new</span> FinalityFlow(fullySignedTransaction, singletonList(session)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被动启动的flow有以下特点：</p><ul><li>需要注解<code>@InitiatedBy(IouIssueFlowInitiator.class)</code>指定谁能启动这个flow</li><li>flow需要继承自<code>FlowLogic</code>，业务逻辑在call方法中实现</li><li>call方法需要添加<code>@Suspendable</code>注解</li><li>需要有实例变量FlowSession，保存调用者的FlowSession</li><li>call方法需要验证交易，然后执行接收交易的标准流程<code>ReceiveFinalityFlow</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bootcamp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> co.paralleluniverse.fibers.Suspendable;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.*;</span><br><span class="line"><span class="keyword">import</span> net.corda.core.transactions.SignedTransaction;</span><br><span class="line"></span><br><span class="line"><span class="meta">@InitiatedBy</span>(IouIssueFlowInitiator<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">IouIssueFlowResponder</span> <span class="keyword">extends</span> <span class="title">FlowLogic</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FlowSession otherSide;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IouIssueFlowResponder</span><span class="params">(FlowSession otherSide)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.otherSide = otherSide;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Suspendable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> FlowException </span>&#123;</span><br><span class="line">        SignedTransaction signedTransaction = subFlow(<span class="keyword">new</span> SignTransactionFlow(otherSide) &#123;</span><br><span class="line">            <span class="meta">@Suspendable</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkTransaction</span><span class="params">(SignedTransaction stx)</span> <span class="keyword">throws</span> FlowException </span>&#123;</span><br><span class="line">                <span class="comment">// Implement responder flow transaction checks here</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        subFlow(<span class="keyword">new</span> ReceiveFinalityFlow(otherSide, signedTransaction.getId()));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行">运行</h2><h3 id="打包">打包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew deployNodes</span><br></pre></td></tr></table></figure><h3 id="运行所有的节点">运行所有的节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./build/nodes/runnodes</span><br></pre></td></tr></table></figure><h3 id="启动一个流程">启动一个流程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flow start IouIssueFlow owner: PartyB, amount: 99</span><br></pre></td></tr></table></figure><p>我本地日志如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ✅   Starting</span><br><span class="line">          Requesting signature by notary service</span><br><span class="line">              Requesting signature by Notary service</span><br><span class="line">              Validating response from Notary service</span><br><span class="line">     ✅   Broadcasting transaction to participants</span><br><span class="line">➡️   Done</span><br><span class="line">Flow completed with result: SignedTransaction(id=14D268667D208D26BF92ADC1F58003DFC9EAF7E036ACB2C2CABC153E627500C0)</span><br></pre></td></tr></table></figure><h3 id="查询生成的数据">查询生成的数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run vaultQuery contractStateType: bootcamp.IouState</span><br></pre></td></tr></table></figure><p>我本地的结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">states:</span><br><span class="line">- state:</span><br><span class="line">    data: !&lt;bootcamp.IouState&gt;</span><br><span class="line">      issuer: "O=PartyA, L=London, C=GB"</span><br><span class="line">      owner: "O=PartyB, L=New York, C=US"</span><br><span class="line">      amount: 99</span><br><span class="line">    contract: "bootcamp.IouContract"</span><br><span class="line">    notary: "O=Notary, L=London, C=GB"</span><br><span class="line">    encumbrance: null</span><br><span class="line">    constraint: !&lt;net.corda.core.contracts.SignatureAttachmentConstraint&gt;</span><br><span class="line">      key: "aSq9DsNNvGhYxYyqA9wd2eduEAZ5AXWgJTbTEw3G5d2maAq8vtLE4kZHgCs5jcB1N31cx1hpsLeqG2ngSysVHqcXhbNts6SkRWDaV7xNcr6MtcbufGUchxredBb6"</span><br><span class="line">  ref:</span><br><span class="line">    txhash: "14D268667D208D26BF92ADC1F58003DFC9EAF7E036ACB2C2CABC153E627500C0"</span><br><span class="line">    index: 0</span><br><span class="line">statesMetadata:</span><br><span class="line">- ref:</span><br><span class="line">    txhash: "14D268667D208D26BF92ADC1F58003DFC9EAF7E036ACB2C2CABC153E627500C0"</span><br><span class="line">    index: 0</span><br><span class="line">  contractStateClassName: "bootcamp.IouState"</span><br><span class="line">  recordedTime: "2020-12-03T09:49:48.373Z"</span><br><span class="line">  consumedTime: null</span><br><span class="line">  status: "UNCONSUMED"</span><br><span class="line">  notary: "O=Notary, L=London, C=GB"</span><br><span class="line">  lockId: null</span><br><span class="line">  lockUpdateTime: null</span><br><span class="line">  relevancyStatus: "RELEVANT"</span><br><span class="line">  constraintInfo:</span><br><span class="line">    constraint:</span><br><span class="line">      key: "aSq9DsNNvGhYxYyqA9wd2eduEAZ5AXWgJTbTEw3G5d2maAq8vtLE4kZHgCs5jcB1N31cx1hpsLeqG2ngSysVHqcXhbNts6SkRWDaV7xNcr6MtcbufGUchxredBb6"</span><br><span class="line">totalStatesAvailable: -1</span><br><span class="line">stateTypes: "UNCONSUMED"</span><br><span class="line">otherResults: []</span><br></pre></td></tr></table></figure><h1 id="节点可视化工具">节点可视化工具</h1><p>参考网站：<a href="https://docs.corda.net/docs/corda-os/4.6/node-explorer.html" target="_blank" rel="noopener">https://docs.corda.net/docs/corda-os/4.6/node-explorer.html</a></p><p>可以下载<a href="https://github.com/corda/node-explorer/releases" target="_blank" rel="noopener">node-explorer</a>来查看节点信息。</p><p>第一次打开界面</p><p><img src="https://docs.corda.net/docs/corda-os/4.6/resources/node-explorer/node-explorer-ssh-login.png" alt="login"></p><ul><li>Node Hostname：localhost</li><li>Node Port：<strong>RPC connection address</strong>可以在启动的窗口查看，或者配置文件查看</li><li>RPC Username：在配置文件</li><li>RPC Password:在配置文件查看</li></ul><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/node-explorer-cl.png" alt="RPC connection address"></p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/image-20201207165759379.png" alt="image-20201207165759379"></p><p>使用spring开发corda：</p><p><a href="https://manosbatsis.github.io/corbeans/" target="_blank" rel="noopener">https://manosbatsis.github.io/corbeans/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境准备&quot;&gt;环境准备&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;JDK（8u131以上）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;corda训练营&quot;&gt;corda训练营&lt;/h2&gt;
&lt;h3 id=&quot;代码地址：&quot;&gt;代码地址：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://githu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/4如何搭建一个Corda网络</title>
    <link href="https://nijixucai.github.io/2020/12/11/blockchain/4%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AACorda%E7%BD%91%E7%BB%9C/"/>
    <id>https://nijixucai.github.io/2020/12/11/blockchain/4%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AACorda%E7%BD%91%E7%BB%9C/</id>
    <published>2020-12-11T06:13:43.000Z</published>
    <updated>2020-12-11T06:13:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>在查看此文档之前，先查看<a href="%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AACorDapp.md">如何开发一个CorDapp</a></p><p>参考文档：<a href="https://gitlab.com/cordite/network-map-service" target="_blank" rel="noopener">NMS</a>的FAQ.md文件</p><h3 id="1、网络服务启动，docker版的网络服务启动：">1、网络服务启动，docker版的网络服务启动：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=network-map -e NMS_ROOT_CA_FILE_PATH="" -p 8080:8080 cordite/network-map:latest</span><br></pre></td></tr></table></figure><h3 id="2、启动后打开接口文档用于验证启动是否成功">2、启动后打开接口文档用于验证启动是否成功</h3><p><a href="http://localhost:8080/swagger/#/" target="_blank" rel="noopener">http://localhost:8080/swagger/#/</a></p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/image-20201207175926945.png" alt="image-20201207175926945"></p><h3 id="3、build和配置CorDapp">3、build和配置CorDapp</h3><h4 id="build之前修改build-gradle的配置，修改cordapp节点不给cordapp签名">build之前修改build.gradle的配置，修改cordapp节点不给cordapp签名</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cordapp &#123;</span><br><span class="line">    signing &#123;</span><br><span class="line">        enabled <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行build命令">运行build命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean deployNodes</span><br></pre></td></tr></table></figure><h4 id="修改配置删除自动生成的key等文件">修改配置删除自动生成的key等文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pushd build/nodes</span><br><span class="line">for N in */; do</span><br><span class="line">      echo 'compatibilityZoneURL="http://localhost:8080"' &gt;&gt; $N/node.conf</span><br><span class="line">      echo 'devModeOptions.allowCompatibilityZone=true' &gt;&gt; $N/node.conf</span><br><span class="line">      pushd $N</span><br><span class="line">      rm -rf network-parameters nodeInfo-* persistence.mv.db certificates additional-node-infos</span><br><span class="line">      popd</span><br><span class="line">done</span><br><span class="line">popd</span><br></pre></td></tr></table></figure><h3 id="4、把节点注册到网络">4、把节点注册到网络</h3><p>下载网络的truststore</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/network-map/truststore -o ~/tmp/network-truststore.jks</span><br></pre></td></tr></table></figure><p>每个节点都初始化注册</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pushd build/nodes</span><br><span class="line">for N in */; do</span><br><span class="line">      pushd $N</span><br><span class="line">      java -jar corda.jar --initial-registration --network-root-truststore ~/tmp/network-truststore.jks --network-root-truststore-password trustpass</span><br><span class="line">      popd</span><br><span class="line">done</span><br><span class="line">popd</span><br></pre></td></tr></table></figure><h3 id="5、指定Notary节点">5、指定Notary节点</h3><h4 id="启动Notary节点">启动Notary节点</h4><p>进到Notary节点的目录下执行,如果没有权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar corda.jar</span><br></pre></td></tr></table></figure><p><em>注意：如果报错：Unable to create logging directory /Users/apple/code/open-source/blockchain/my-corda/logs. Node will now shutdown.说明没有权限，在命令前加sudo即可</em></p><h4 id="指定Notary节点">指定Notary节点</h4><p>1、登陆NMS（network-map-service）并获取token信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TOKEN=`curl -X POST "http://localhost:8080//admin/api/login" -H  "accept: text/plain" -H  "Content-Type: application/json" -d "&#123;  \"user\": \"sa\",  \"password\": \"admin\"&#125;"`</span><br></pre></td></tr></table></figure><p>2、上传notary</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pushd build/nodes/Notary</span><br><span class="line">NODEINFO=`ls nodeInfo*`</span><br><span class="line">curl -X POST -H "Authorization: Bearer $TOKEN" -H "accept: text/plain" -H "Content-Type: application/octet-stream" --data-binary @$NODEINFO http://localhost:8080//admin/api/notaries/validating</span><br><span class="line">popd</span><br></pre></td></tr></table></figure><p>在执行上面的命令时，注意自己当前的所在的目录，如果已经在build/nodes/Notary目录下需要退出到bootcamp-cordapp目录</p><h3 id="6、停止Notary节点">6、停止Notary节点</h3><p>在notary节点的shell命令行执行 <code>bye</code></p><h3 id="7、修改notary节点的validating">7、修改notary节点的validating</h3><p>因为在第5步指定Notary的时候调用的是validating接口，所以确认一下notary的配置是的validating是否为true，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">notary &#123;</span><br><span class="line">    validating&#x3D;true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果配置的是<code>validating=false</code>则会报异常：<br><code>[ERROR] 16:25:22+0800 [main] internal.NodeStartupLogging. - Exception during node startup: There is a discrepancy in the configured notary type and the one advertised in the network parameters - shutting down. Configured as validating: false. Advertised as validating: true [errorCode=r8le54, moreInformationAt=https://errors.corda.net/OS/4.3/r8le54]</code></p><h3 id="8、删除Notary节点的network-parameters文件">8、删除Notary节点的network-parameters文件</h3><p>进入到notary节点的目录，删除<code>network-parameters</code>文件</p><h3 id="9、启动notary节点和其他节点">9、启动notary节点和其他节点</h3><p>进入到各个节点的目录，启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar corda.jar</span><br></pre></td></tr></table></figure><h3 id="10、发起交易测试">10、发起交易测试</h3><p>可以下载<a href="https://github.com/corda/node-explorer/releases" target="_blank" rel="noopener">node-explorer</a>来查看节点信息并发起交易，我的测试结果如下：</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/image-20201209165525748.png" alt="image-20201209165525748"></p><h3 id="扩展">扩展</h3><p>因为上面的文档是按照</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在查看此文档之前，先查看&lt;a href=&quot;%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AACorDapp.md&quot;&gt;如何开发一个CorDapp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;https://git</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/1北京大学肖臻老师《区块链技术与应用》学习总结</title>
    <link href="https://nijixucai.github.io/2020/12/11/blockchain/1%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%82%96%E8%87%BB%E8%80%81%E5%B8%88%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://nijixucai.github.io/2020/12/11/blockchain/1%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%82%96%E8%87%BB%E8%80%81%E5%B8%88%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2020-12-11T06:13:05.000Z</published>
    <updated>2020-12-11T06:13:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="北京大学肖臻老师《区块链技术与应用》学习总结">北京大学肖臻老师《区块链技术与应用》学习总结</h1><h1 id="3-数据结构">3 数据结构</h1><h2 id="hash-printers-（hash指针）">hash printers （hash指针）</h2><p>hash指针既可以找到块的位置，也可以验证hash的正确性</p><h3 id="Block-chain-is-a-linked-list-using-hash-pointers">Block chain is a linked list using hash pointers</h3><p>每一个区块都包含前一个区块的hash指针</p><ul><li>后面一个区块的hash指针是通过前一个区块的值算出来的。</li><li>通过上面的数据结构可以实现：tamper-evident-log</li></ul><p>只要记住最后一个块的hash值，就可以保证整个链的值无法篡改。</p><ul><li>我们也可以只保存其中的部分区块，区块的前面的部分我们不必保存，如果需要的时候找别人要；然后验证要的区块的hash值是否是当前区块的hash值即可</li></ul><h2 id="Merkle-tree">Merkle tree</h2><p><img src="/2020/12/11/blockchain/1%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%82%96%E8%87%BB%E8%80%81%E5%B8%88%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/apple/code/open-source/python/che168/291.png" alt="291"></p><p>上图：</p><ul><li>最下面的一层是数据块，data blocks；每个数据块都是交易（tx）</li><li>上面的那些都是hash pointers</li><li>最上面的节点是根hash值（root hash）</li></ul><h3 id="Merkle-tree数据结构的好处：">Merkle tree数据结构的好处：</h3><p>只要记住root hash就可以检测出节点的修改</p><p>每个区块分成块头（block header）和块身（block body）</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/295.png" alt="295"></p><h3 id="默克尔证明（Merkle-proof）：指一笔交易到跟节点的路径">默克尔证明（Merkle proof）：指一笔交易到跟节点的路径</h3><p>这种证明也叫做：proof of membership或proof of inclusion（证明节点存在于Merkle tree之中）</p><h3 id="proof-of-non-membership（证明节点存不在于Merkle-tree之中）">proof of non-membership（证明节点存不在于Merkle tree之中）</h3><p>排序所有交易节点的hash值（Sorted Merkle tree），然后计算需要证明的交易的hash值，找到此hash值应该出现的位置，如果应该出现的位置的两边的节点的hash满足Merkle proof，则说明需要证明的节点不在此Merkle tree之中。</p><p><strong>只要不是有环的数据结构，都可以使用hash指针</strong></p><h1 id="4-BTC-协议">4 BTC 协议</h1><h2 id="如何发行数字货币">如何发行数字货币</h2><h3 id="央行发行数字货币，如果只使用私钥签名，可以吗？">央行发行数字货币，如果只使用私钥签名，可以吗？</h3><p>无法防止double spending attack：花两次攻击</p><h3 id="中心化方案：">中心化方案：</h3><p>如果央行给发行的货币打上编号并且记录货币当前属于谁，那么可以解决double spending attack；</p><p><strong>但是每次花钱都要去央行验证货币是否是真的，并且属于当前花钱的人，花钱之后再变更钱的归属。</strong></p><h3 id="去中心化方案">去中心化方案</h3><h4 id="每个交易（如A给B转账）中都包含输入和输出两个部分">每个交易（如A给B转账）中都包含输入和输出两个部分</h4><ul><li>输入部分需要说明币的来源</li><li>输入部分需要包含付款人的公钥（因为付款时有付款人的签名，带上公钥为了供别人校验）</li><li>输出部分要给出收款人公钥的hash</li></ul><p><strong>铸币交易（coinbase tx）里面有A的公钥的hash，这样就知道铸币交易的钱是给谁的。</strong></p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/471.png" alt="471"></p><p>上图中的数据结构有两种hash指针</p><ul><li>第一种是链接块的hash指针（即前一个区块的hash指针）</li><li>第二种hash指针是说明币的来源</li></ul><p><strong>问题：是否可以检测dobule spending？</strong></p><p>如果币的来源是不合法的（验证不合法的方式是币的来源是否存在与UTXO），是不会添加到区块链中，可以检测dobule spending</p><p><strong>问题：在A给B转账时，所有人都需要知道A的公钥，为了验证A的签名；那么怎么才能知道A的公钥呢？</strong></p><p>在交易的输入部分，付款人需要给出自己的公钥</p><p>在比特币的系统里，地址是通过公钥推算出来的，地址相当于银行账号，A需要给B转钱需要B的地址；比特币系统里面是没有功能查询某个人的地址</p><p>BitCoin Script：交易脚本，把A的输入部分和上一步的输出脚本拼在一起执行，如果不报错说明交易是合法的。</p><p>每一个块包含不止一个交易，每个块包含Block header和Block body</p><p>哈希指针包含的hash，是通过Block header做hash的值</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/474.png" alt="474"></p><h3 id="Block-header包含：">Block header包含：</h3><ul><li>version：用的哪个比特币协议的版本</li><li>hash of previous block header：上一个区块头的hash</li><li>Merkle root hash：整个Tree的root hash值</li><li>target：挖矿的目标target（满足H(block header + nonce) &lt;= target）</li><li>随机数nonce</li></ul><h3 id="Block-body包含：">Block body包含：</h3><ul><li>transaction list</li></ul><h3 id="系统中的节点分为全节点和轻节点">系统中的节点分为全节点和轻节点</h3><h4 id="full-node">full node</h4><p>全节点是保存区块链的所有信息的，验证每一个交易，所以全节点也叫做fully validating node</p><h4 id="light-node">light node</h4><p>轻节点无法独立验证交易的合法性</p><p><strong>问题：每个账户都可以发布交易，谁来决定哪个交易写到区块中？顺序是什么样的？</strong></p><p>挖矿决定谁有记账权，有记账权的节点可以申请写入区块，顺序由拥有记账权的节点定</p><h2 id="账本的内容要取得分布式的共识">账本的内容要取得分布式的共识</h2><p>distributed consensus（分布式共识）</p><p>distributed hash table</p><p>需要取得共识的内容是什么？</p><h3 id="FLP-impossibility-result：">FLP impossibility result：</h3><p>在一个异步的系统里，即使只有一个成员是有问题的，也不可能取得共识</p><h3 id="CAP-Theorem（定理）">CAP Theorem（定理）</h3><p>CAP：</p><ul><li><a href="https://baike.baidu.com/item/%E4%B8%80%E8%87%B4%E6%80%A7/9840083" target="_blank" rel="noopener">一致性</a>（Consistency）</li><li><a href="https://baike.baidu.com/item/%E5%8F%AF%E7%94%A8%E6%80%A7/109628" target="_blank" rel="noopener">可用性</a>（Availability）</li><li><a href="https://baike.baidu.com/item/%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7/23734073" target="_blank" rel="noopener">分区容错性</a>（Partition tolerance）</li></ul><p>这三个特性分布式系统中最多同时满足两个</p><p>分布式的一个协议：<a href="https://zhuanlan.zhihu.com/p/31780743" target="_blank" rel="noopener">Paxos</a>，能够保证Consistency</p><h2 id="比特币中的共识协议Consensus-in-BitCoin">比特币中的共识协议Consensus in BitCoin</h2><p>假设系统中大部分的节点是好的，小部分有恶意。</p><p>直接投票选择哪些交易是合法的，如果超过半数就接受可以吗？</p><p>membership，谁有投票权</p><p>hyperledger fabric（联盟链）：可以投票决定</p><p>sybil attack（女巫攻击）：超级计算机一直制造账户，参与投票，直到制造的恶意账户超过半数。</p><h3 id="比特币的投票，按照算力值">比特币的投票，按照算力值</h3><p>谁先获得下面公式中的nonce，谁就能获得记账权，并且给予初块奖励</p><p>Puzzle friendly: H(block header) &lt;= target</p><p>longest valid chain 最长合法链</p><p>如果不在最长合法链上，新的区块也不会被接受；</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/476.png" alt="476"></p><p>上面的图片是分叉攻击（forking attack）</p><h3 id="block-reward-初块奖励">block reward 初块奖励</h3><h4 id="一次性能造多少币？">一次性能造多少币？</h4><p>刚发布的时候50 BTC，21万个区块之后可以铸造25个比特币</p><p>50 BTC -&gt; 25 BTC -&gt; 12.5 BTC</p><p>coinbase transaction</p><p>mining（挖矿）：争夺记账权</p><p>digital gold：数字黄金</p><p>miner：矿工</p><h1 id="BTC-实现">BTC 实现</h1><p>transaction-based ledger：基于交易的账本模式</p><p>每个区块记录的是交易信息，包括转账交易和铸币交易</p><p>UTXO：Unspent Transaction Output（还没有被花出去的输出）</p><p>UTXO数据结构，以便快速检测double spending；如果想花掉的币不存在UTXO中，说明不存在或已经花出</p><p>total inputs = total outputs</p><p>比特币的第二个激励机制：transaction fee</p><p>其他的模式：account-based ledger，在这种模式中，系统要显示的记录账户的余额，以太坊是基于此种模式记账。</p><h2 id="每次尝试nonce可以看作是Bernoulli-trial：a-random-experiment-with-binary-outcome">每次尝试nonce可以看作是Bernoulli trial：a random experiment with binary outcome</h2><p>所有的尝试的集合构成了Bernoulli Process：a sequence of independent Bernoulli trials</p><p>尝试计算nonce是memoryless的：即无论以前尝试过多少次下一次的概率还是一样</p><p>可以使用Poisson Process近似</p><p>出块时间服从指数分布：exponential distribution</p><p>BitCoin is secured by mining</p><h2 id="比特币的安全性">比特币的安全性</h2><p><strong>问题：能不能把别人的钱转给自己？</strong></p><p>不可以，因为你没有别人的私钥，无法签名。（<em>比特币在花每一笔钱的时候都要制定币的来源，即某次交易的output，这个output中有币的所有人的公钥，在花钱的时候币的所有人需要用自己的私钥做签名，然后别人通过当前交易的input和币来源的output来验证这个交易的合法性。</em>）</p><p><strong>问题：能不能double spending？</strong></p><p>不可以，因为第二次花的时候在UTXO里面不存在，会验证不通过。</p><h1 id="6-BTC-网络">6-BTC-网络</h1><p>application layer：BitCoin Block chain</p><p>network layer：P2P Overlay Network</p><p>设计原则：simple, robust, but not efficient</p><h1 id="7-BTC-挖矿难度">7-BTC-挖矿难度</h1><p>如何调整挖矿难度：调整挖矿难度就是调整目标空间在整个输出空间中所占的比例。</p><p>挖矿即是算出满足：H(block header) &lt;= target的nonce值</p><p>sha-256: 可能的值是2的256次方</p><p>difficulty = difficulty_1_target/target</p><p><strong>问题：为什么要调整挖矿难度？</strong></p><p>为了保证出块时间平均10分钟</p><p><strong>问题：出块时间太短会有什么问题？</strong></p><p>两个节点同时发布区块，可能会出现分叉</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/487.png" alt="487"></p><p>平均出块时间过短可能导致上图的很多分叉，这会分散诚实节点的算力</p><p>平均出块时间不论设置的多长，都不可以无限的减小下去</p><p>如果分叉过多就无法防止51% attack</p><p>以太坊的共识协议：ghost</p><h3 id="什么时候调整难度？">什么时候调整难度？</h3><p>每2016个区块之后调整一次</p><h3 id="如何调整挖矿难度：">如何调整挖矿难度：</h3><h4 id="调整的target值">调整的target值</h4><p>**公式：**target = target_current * (actual time)/(expected time)</p><p>当actual time大于expected time，说明难度太大， (actual time)/(expected time)得出的值就大于1，最终算出来的target会比当前的target大，也就是变得容易</p><h4 id="调整难度">调整难度</h4><p>next_difficulty = previous_diffculty * (2 weeks)/ (time to mine last 2016 blocks)</p><p>调整难度与目标域值（target）成反比</p><p>expected time = 2016 * 10min</p><p>actual time = time spent mining the last 2016 blocks</p><p>目标域值调整最大不会超过4倍，最小不会小于1/4</p><h3 id="怎么让所有的矿工都调整域值呢？">怎么让所有的矿工都调整域值呢？</h3><p>代码里自动调，如果恶意节点修改了源码不调整，他发布的区块的检查区块合法性就通不过。</p><h1 id="8-BTC-挖矿">8-BTC-挖矿</h1><h2 id="全节点">全节点</h2><ul><li>一直在线</li><li>在本地硬盘上维护完整的区块链信息</li><li>在内存里维护UTXO，以便快速验证交易的正确性</li><li>监听比特币网络上的交易信息，验证每个交易的合法性</li><li>决定哪些交易会被打包到区块里</li><li>监听别的矿工挖出来的区块，验证其合法性</li><li>挖矿</li><li>决定沿着哪条链挖下去？</li><li>当出现等长的分叉的时候，选择哪个分叉？</li><li>缺省情况下是沿着最先听到的区块</li></ul><h2 id="轻节点">轻节点</h2><ul><li>不是一直在线</li><li>不用保存整个区块链，只要保存每个区块的块头</li><li>不用保存全部交易，只保存与自己相关的交易</li><li>无法检验大多数交易的合法性，只能检测与自己相关的那些交易的合法性</li><li>无法检测网上发布的区块的正确性</li><li>可以验证挖矿的难度</li><li>只能检测哪个是最长链，不知道哪个是最长合法链</li></ul><p>挖矿具有特性：</p><p>memoryless或叫做progress free</p><h2 id="挖矿的设备">挖矿的设备</h2><ul><li>第一代，CPU</li><li>闲置的cpu、内存、硬盘</li><li>第二代，GPU</li><li>为了通用并行计算而设计的</li><li>也存在浪费</li><li>第三代，ASIC：Application Specific Integrated Circuit</li></ul><p>挖矿的设备的趋势是从通用到专业</p><h2 id="puzzle">puzzle</h2><p>mining puzzle:挖矿时求解的puzzle</p><p>merge mining：使用别的币的mining puzzle</p><p>Alternative mining puzzle: 抗ASIC芯片</p><h2 id="矿池">矿池</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/489.png" alt="489"></p><p>（share almost valid block）</p><h3 id="假如一个矿池占了51-的比例，他能发动哪些攻击呢？">假如一个矿池占了51%的比例，他能发动哪些攻击呢？</h3><ul><li>forking attack</li><li>Boycott（封锁）</li></ul><h1 id="9-BTC-比特币脚本">9-BTC-比特币脚本</h1><p>比特币脚本是stack-based的脚本，包括下面三种类型</p><ul><li><p>P2PK（Pay to Public Key）</p></li><li><p>P2PH（Pay to Public Key Hash）</p></li><li><p>P2SH（Pay to Script Hash）对多重签名的支持</p></li></ul><h3 id="redeemScript：">redeemScript：</h3><p>当一个需要联合签名的账号B（如需要5个中的三个签名）需要支付时，需要至少有三个签名才可以，那么在B支付给C时需要验证B的币来来源的output和当前的交易的input做验证。如果需要验证成功则需要在上一步交易的output中包含这些公钥信息。</p><p>当一个账号A支付给另一个需要联合签名的账号B时，如果需要A支付时提供B的所有的账户的公钥信息，会导致A支付时特别麻烦。</p><p><strong>redeemScript</strong>就是解决上面的问题而存在的，详情参考<a href="https://zhuanlan.zhihu.com/p/93823558" target="_blank" rel="noopener">深入理解比特币脚本</a></p><h2 id="Proof-of-Burn">Proof of Burn</h2><p>燃烧证明，在输出脚本中添加return，使这个output在验证时永远报错，也就是这个输出的币永远也花不出去。</p><p><strong>自问：如果A在给B付款时，output中面包含return语句，那么B虽然真实收到了款，但是永远花不出去。B能够在接收时验证吗？还是只能等到花钱时才能发现这个问题呢？</strong></p><p>**自答：**因为B需要验证这比交易有没有写入区块链中，所以A会把交易发给B，此时B需要检查output是否包含return，如果包含则认为这比交易无效；假如B是商家并在交易刚发生时不验证，把货发送给A，那么B就收到一笔花不出去的钱。</p><h3 id="digital-commitment">digital commitment</h3><p>发布交易不需要记账权，发布区块才需要记账权</p><h1 id="10-BTC-分叉">10-BTC-分叉</h1><p>fork</p><ul><li>state fork</li><li>forking attack（deliberate fork）</li><li>protocol fork（协议分叉）</li><li>hard fork</li><li>soft fork</li></ul><h2 id="hard-fork">hard fork</h2><p>系统中只有有一部分节点不更新软件，就会出现永久性的分叉</p><p>eg：block size limit</p><p>block size不超过1M，计算出7tx/sec（每秒7笔交易）；如果new nodes把软件升级为区块大小最多可以4M，那么旧的节点如果不一起升级继续沿着旧链挖就会导致硬分叉；旧节点认为超过1M大小的区块为非法的。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/image%20(1).png" alt="image (1)"></p><p>只要old nodes不更新软件，分叉就不会变更</p><h2 id="soft-fork">soft fork</h2><p>只要系统中有半数中的节点更新软件，就不会出现永久性的分叉；只会出现临时性的分叉</p><p>接着使用调整区块大小的例子，如果调整为限制不超过0.5M，那么新节点产生的区块旧节点也认可；但是旧节点产生的区块新节点不认可，如果新节点占多数时就会迫使旧节点升级。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/499.png" alt="499"></p><h3 id="软分叉的例子（P2SH：Pay-to-Script-Hash）">软分叉的例子（P2SH：Pay to Script Hash）</h3><h1 id="11-BTC-问答">11-BTC-问答</h1><h2 id="如果转账的时候地址写错了怎么办？">如果转账的时候地址写错了怎么办？</h2><p>答：没有办法取消一经发布的交易</p><h2 id="Proof-of-Burn，如果OP-RETURN无条件的返回错误，这笔交易是如何写入到区块链里的呢？">Proof of Burn，如果OP_RETURN无条件的返回错误，这笔交易是如何写入到区块链里的呢？</h2><p>答：因为OP_RETURN是写在当前交易的输出脚本里，所以当前交易的验证不会验证这个脚本</p><h2 id="你怎么知道哪个矿工最先找到的同一个nonce？">你怎么知道哪个矿工最先找到的同一个nonce？</h2><p>答：不可以偷答案，因为区块里面的coinbase tx指向的收款账户是真正计算出nonce的账户，这个信息如果被修改了，交易就不会验证通过。</p><h2 id="transaction-fee，如何确定交易费给哪个矿工，给多少？">transaction fee，如何确定交易费给哪个矿工，给多少？</h2><p>只要total inputs &gt; total outputs，之间的差额就是交易费</p><h1 id="12-BTC-比特币中的匿名性">12-BTC-比特币中的匿名性</h1><p>BitCoin and anonymity</p><p>pseudonymity</p><h2 id="什么情况下会破坏匿名性？">什么情况下会破坏匿名性？</h2><p>在多个inputs的时候，多个输入可能是同一个人</p><h2 id="什么情况下别人能直到比特币账户对应现实中的某个人呢？">什么情况下别人能直到比特币账户对应现实中的某个人呢？</h2><p>资金的转入转出，购买比特币或者比特币套现；比特币支付的时候也可以</p><p>silk road：eBay for illegal drugs</p><h2 id="采取什么方法提高匿名性？">采取什么方法提高匿名性？</h2><h2 id="零知识证明">零知识证明</h2><p>零知识证明是指一方（证明者）向另一方（验证着）证明一个陈述是正确的，而无需透露除该陈述是正确的外的任何信息。</p><p>**我的理解：**如比特币的转账（A转给B）签名就是零知识证明，因为这个签名证明了这个交易是A转出去的，却不需要让A提供其他信息。</p><h1 id="13-BTC-思考">13-BTC-思考</h1><h2 id="为什么比特币系统能够绕过被证明的分布式系统的不可能的结论？">为什么比特币系统能够绕过被证明的分布式系统的不可能的结论？</h2><p>比特币并没有绕过</p><h1 id="14-ETH-以太坊概述">14-ETH-以太坊概述</h1><ul><li><p>memory hard mining puzzle</p></li><li><p>ASIC resistance：挖矿时需要访问内存</p></li><li><p>proof of work -&gt; proof of stake：目标是从工作量证明过度到权益证明</p></li><li><p>smart contract: 智能合约</p></li><li><p>BitCoin: decentralized currency（去中心化的货币）</p></li><li><p>Ethereum: decentralized contract（去中心化的合同）</p></li></ul><h1 id="15-ETH-账户">15-ETH-账户</h1><ul><li><p>以太坊是一个accounting-based ledger（基于账户的去中心化的账本）</p></li><li><p>天然防御double spending attack</p></li><li><p>记录交易次数（nonce），以防御replay attack（重放攻击）</p></li></ul><h2 id="账户类型">账户类型</h2><h3 id="externally-owned-account（外部账户）">externally owned account（外部账户）</h3><p>记录：</p><ul><li>balance</li><li>nonce</li></ul><h3 id="Smart-contract-account（智能合约账户）">Smart contract account（智能合约账户）</h3><p>记录：</p><ul><li>balance</li><li>nonce</li><li>code</li><li>storage</li></ul><h4 id="智能合约账户有以下几个特点：">智能合约账户有以下几个特点：</h4><ul><li><p>合约账户无法主动发起一个交易</p></li><li><p>创建合约账户的时候会返回一个地址，可以调用这个地址</p></li></ul><h1 id="16-ETH-以太坊中的状态树">16-ETH-以太坊中的状态树</h1><p>维护的功能是账户地址到账户状态的映射：addr -&gt; state</p><p><strong>问题：如果把所有账户直接组成一个merkle tree 可以吗？</strong></p><p>不可以，因为修改账户时成了串行</p><p><strong>问题：为什么比特币可以把所有交易组成一个merkle tree呢？</strong></p><p>因为比特币只有一个人拥有记账权，所以这个有记账权的人随意记录即可</p><p>即使以太坊使用sorted merkle tree，在有新的账户出现时也会大量的更新merkle tree中的hash值。</p><h2 id="数据结构：trie（retrieval-检索）">数据结构：trie（retrieval-检索）</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/628.png" alt="628"></p><h2 id="数据结构：Patricia-tree（trie）">数据结构：Patricia tree（trie）</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/629.png" alt="629"></p><ul><li>树的高度变短</li><li>如果插入新的单词，原来压缩的节点可能需要扩展开</li></ul><h2 id="数据结构：MPT（Merkle-Patricia-tree）">数据结构：MPT（Merkle Patricia tree）</h2><p>把Patricia tree的指针改为Hash Pointer就成了MPT</p><h2 id="数据结构：Modified-MPT">数据结构：Modified MPT</h2><p>下面状态树的例子中的节点有三种：</p><ul><li>Extention Node：如果路径出现压缩，就会出现此节点</li><li>Branch Node：分支节点</li><li>Leaf Node：最终的节点</li></ul><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/image-20201126151730381.png" alt="image-20201126151730381"></p><h1 id="16-ETH-交易树和收据树">16-ETH-交易树和收据树</h1><p>用处：</p><ul><li>提供Merkle proof</li></ul><h2 id="数据结构：bloom-filter">数据结构：bloom filter</h2><p>**用途：**支持查找某个元素是否在一个比较大的集合中</p><p>**实现：**把集合中的所有的hash值映射到一个小的数组中，然后把数组中的对应位置的值由0改为1。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/630.png" alt="630"></p><ul><li><p>有可能出现误报（一个值的hash映射的数组中的位置，如果是1只能说明可能存在，因为存在hash碰撞）</p></li><li><p>不会出现漏报（因为只要某个值的hash映射的数组的位置的值是0，说明此值不存在）</p></li></ul><h3 id="以太坊中如何使用bloom-filter">以太坊中如何使用bloom filter</h3><p>包含在块头里面，可以快速过滤某些节点不包含指定交易；然后再在可能包含的节点中检索。</p><p>transaction-driven state machine（交易驱动的状态机）</p><h1 id="18-ETH-GHOST协议">18-ETH-GHOST协议</h1><h2 id="如果只有和父节点平级的才是uncle-block">如果只有和父节点平级的才是uncle block</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/633.png" alt="633"></p><h3 id="存在问题：">存在问题：</h3><p>1、uncle block的个数只能是两个，如果分叉超过3个就无法全部包含进来。<br>2、故意不包含某个叔父区块</p><h2 id="只要与当前节点有共同的主链就认为是uncle-block">只要与当前节点有共同的主链就认为是uncle block</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/634.png" alt="634"></p><h3 id="存在问题：-v2">存在问题：</h3><p>某个矿工在挖矿难度低的时候产生多个分叉（即以后节点的叔父）区块，期待以后被包含进去以获取初块奖励</p><h2 id="GHOST协议：与当前区块在7代以内，才被认为是uncle-block">GHOST协议：与当前区块在7代以内，才被认为是uncle block</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/637.png" alt="637"></p><p>距离当前区块越远的uncle block，得到的奖励越少；为了防止分叉过多，有利于鼓励出现分叉尽快合并。叔父区块得不到gas fee（汽油费）</p><h1 id="19-ETH-挖矿算法（ethash）">19-ETH-挖矿算法（ethash）</h1><p>Block chain is secured by mining。</p><p>bug bounty：bug赏金</p><p>one cpu， one vote（一个cpu，一张投票）</p><p>设计puzzle的原则：difficult to solve， but easy to verify</p><p>以太坊的挖矿算法的目标是做到：AISC resistance</p><p>memory hard mining puzzle</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/676.png" alt="676"></p><h1 id="20-ETH-难度调整">20-ETH-难度调整</h1><h2 id="自适应难度调整">自适应难度调整</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/680.png" alt="680"></p><h3 id="子公式解释">子公式解释</h3><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/681.png" alt="681"></p><h2 id="难度炸弹（difficulty-bomb）">难度炸弹（difficulty bomb）</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/682.png" alt="682"></p><h2 id="以太坊发展的四个阶段">以太坊发展的四个阶段</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//%E4%B8%8B%E8%BD%BD.png" alt=" 以太坊发展的四个阶段"></p><h1 id="21-权益证明（Proof-of-stake）">21-权益证明（Proof of stake）</h1><p>TWH：Terawatt hours</p><p><strong>问题：为什么需要权益证明？</strong></p><p>工作量证明太费电了</p><p>初块奖励是为了激励矿工参与比特币系统的维护。</p><p>virtual mining</p><p><strong>权益证明：</strong></p><ul><li><p>每个人按照持有币的数量来投票，省去了挖矿的过程；持有的币越多，权益越大。</p></li><li><p>持有的币只能从加密货币的系统中获取，如果有人大量购买这个币以获取权益然后搞垮他，会导致币价大涨；涨价会让搞垮这个币所付出的代价很大。</p></li></ul><p>AltCoin Infanticide：把新币扼杀在摇篮里</p><p>Proof of Deposit</p><p>如果出现分叉的时候，一个人两边都挖，并不会影响他的币的数量。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/674.png" alt="674"></p><p>Casper the Friendly Finality Gadget（FFG）</p><p>验证者有任期，验证者在任期外有等待期，如果没有人检举则给验证者保证金和奖励。</p><p>EOS币的权益证明：</p><p>DPOS：Delegated Proof of Stake</p><h1 id="22-ETH-智能合约">22-ETH-智能合约</h1><h2 id="外部账户如何调用智能合约？">外部账户如何调用智能合约？</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/638.png" alt="638"></p><ul><li><p>SENDER ADDRESS：调用者的地址</p></li><li><p>TO CONTRACT ADDRESS：智能合约的地址</p></li><li><p>VALUE：调用时转多少ETH</p></li><li><p>GAS USED：汽油费</p></li><li><p>GAS PRICE：汽油费的价格</p></li><li><p>CAS LIMIT：此调用愿意支付的汽油费上限</p></li><li><p>TX DATA：调用的函数及其参数的编码值</p></li></ul><h2 id="一个合约如何调用另一个合约中的函数">一个合约如何调用另一个合约中的函数</h2><h3 id="1、直接调用">1、直接调用</h3><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/639.png" alt="639"></p><h3 id="2、使用adress类型的call-函数">2、使用adress类型的call()函数</h3><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/640.png" alt="640"></p><h3 id="3、代理调用delegatecall">3、代理调用delegatecall()</h3><h3 id="错误处理">错误处理</h3><ul><li><p>assert：一般用来判断内部条件</p></li><li><p>required：一般用于判断外部条件</p></li><li><p>revert：无条件的抛出异常</p></li></ul><h2 id="嵌套调用">嵌套调用</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/641.png" alt="641"></p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/642.png" alt="642"></p><p>先执行交易再挖矿,因为挖矿之后发布的账户状态需要先执行交易。</p><p>就算账户的代码执行错误，也会被发布；然后收取汽油费，为了防止有恶意节点发送大量的不能验证通过的交易。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/658.png" alt="658"></p><p><strong>问题：智能合约的代码支持多线程执行吗？</strong></p><p>不支持多线程,多线程可能造成执行结果的不一致。</p><h2 id="智能合约可以获得的区块信息">智能合约可以获得的区块信息</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/659.png" alt="659"></p><h2 id="智能合约可以获得的调用信息">智能合约可以获得的调用信息</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/660.png" alt="660"></p><h2 id="地址类型">地址类型</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/661.png" alt="661"></p><p>地址类型中的不同方法转账时的特点：</p><ul><li>transfer：会导致连锁性回滚</li><li>send：不会导致连锁性回滚</li><li>call：不会导致连锁式回滚，call的方式转账会把剩余的汽油全部发送过去</li></ul><h2 id="一个例子：简单拍卖">一个例子：简单拍卖</h2><h3 id="构造方法">构造方法</h3><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/662.png" alt="662"></p><h3 id="出价和结束拍卖的方法">出价和结束拍卖的方法</h3><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/663.png" alt="663"></p><h3 id="如果黑客的智能合约中没有callback方法怎么办？">如果黑客的智能合约中没有callback方法怎么办？</h3><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/664.png" alt="664"></p><p>没有办法。。。</p><h2 id="Code-is-low：">Code is low：</h2><p>优点：没有人能够修改规则</p><p>缺点：如果规则有问题，也无法修正，导致上面的问题成为所有人的钱都取不出来</p><h2 id="优化后的拍卖代码">优化后的拍卖代码</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/665.png" alt="665"></p><h3 id="无法防止重入攻击（Re-entrancy-Attack）">无法防止重入攻击（Re-entrancy Attack）</h3><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/666.png" alt="666"></p><p>解决的方法是，先把金额修改为0，再发起转账。</p><p>转账交易时需要使用这个步骤：先判断条件，再改变条件，再发生交互</p><p>better safe by sorry</p><h3 id="不要使用call方法转账，因为call支付的汽油费太多">不要使用call方法转账，因为call支付的汽油费太多</h3><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/667.png" alt="667"></p><h1 id="23-ETH-TheDAO">23-ETH-TheDAO</h1><p>DAO：Decentralized Autonomous Organization（去中心化的自治的组织）</p><p>DAC：Decentralized Autonomous Corporation（去中心化的自治的公司）</p><p>因为先转账再更改余额导致被发起了重入攻击：</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/image-20201126161738940.png" alt="image-20201126161738940"></p><p>too big to fail</p><p>升级后产生两个分叉：通过在链上增加ChainID（为了防止回放），以区分ETC(Ethereum Classic)和ETH</p><h2 id="为什么不能只针对黑客的账户？">为什么不能只针对黑客的账户？</h2><p>因为智能合约有bug，所以就算只针对黑客的账户其他人也可以针对这个bug进行攻击。</p><h1 id="24-ETH-思考">24-ETH-思考</h1><h2 id="Is-smart-contract-really-smart？（智能合约真的智能吗）">Is smart contract really smart？（智能合约真的智能吗）</h2><p>smart contract is anything but smart</p><h2 id="Nothing-is-irrevocable（没有什么是不可篡改的）">Nothing is irrevocable（没有什么是不可篡改的）</h2><p>如TheDAO的例子；所以不能迷信“不可篡改”</p><h2 id="Is-solidity-the-right-programming-language？">Is solidity the right programming language？</h2><p>solidity存在一些问题，但是没有什么东西是没有问题的。所以随着时间的检验可能会出现</p><ul><li><p>智能合约模板</p></li><li><p>编写智能合约的公司</p></li></ul><p>虽然智能合约的内容是开源的，但是Many eyeball fallacy；在涉及到自己的利益时还是需要自己检查代码。</p><h2 id="What-does-decentralization（权利下放）-mean？">What does decentralization（权利下放） mean？</h2><p>分叉是去中心化和民主的体现</p><h2 id="decentralized-distributed-去中心化不等于分布式">decentralized != distributed(去中心化不等于分布式)</h2><p>state machine的应用场景：</p><ul><li>mission critical application（关键任务应用程序）</li><li>air traffic control（空中交通管制）</li><li>stock exchange（证券交易）</li><li>space shuttle（航天飞机）</li></ul><p>智能合约是用来编写控制程序的，只有在互不信任的实体之间建立共识的操作才需要写在智能合约里</p><h1 id="25-ETH-Beauty-Chain（美链）">25-ETH-Beauty Chain（美链）</h1><p>IPO：Initial Public Offering</p><p>ICO：Initial Coin Offering</p><h2 id="美链背景介绍">美链背景介绍</h2><p>下图中出现的ERC为Ethereum Request for Comments（以太坊征求意见）</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/683.png" alt="683"></p><h2 id="因为下面的代码在计算时出现了溢出，从而导致被攻击，凭空出现了很多的代币BEC">因为下面的代码在计算时出现了溢出，从而导致被攻击，凭空出现了很多的代币BEC</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/image-20201126163601352.png" alt="image-20201126163601352"></p><h2 id="如何预防此类（计算溢出）问题？">如何预防此类（计算溢出）问题？</h2><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/image-20201126163925215.png" alt="image-20201126163925215"></p><h1 id="26-总结">26-总结</h1><ul><li><p>加密货币应该用在法币支持的不太好的地方，而不是用在法币已经支持的很好的地方。</p></li><li><p>下一代的的互联网是价值交换网络</p></li><li><p>Democracy is the worst from of Government except for all those other forms that have bean tried from time to time</p></li><li><p>Is decentralized aways right thing?</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;北京大学肖臻老师《区块链技术与应用》学习总结&quot;&gt;北京大学肖臻老师《区块链技术与应用》学习总结&lt;/h1&gt;
&lt;h1 id=&quot;3-数据结构&quot;&gt;3 数据结构&lt;/h1&gt;
&lt;h2 id=&quot;hash-printers-（hash指针）&quot;&gt;hash printers （hash指</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>others/读书笔记-《我的第一本算法书》</title>
    <link href="https://nijixucai.github.io/2020/09/30/others/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E7%AE%97%E6%B3%95%E4%B9%A6%E3%80%8B/"/>
    <id>https://nijixucai.github.io/2020/09/30/others/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E7%AE%97%E6%B3%95%E4%B9%A6%E3%80%8B/</id>
    <published>2020-09-30T03:23:49.091Z</published>
    <updated>2020-09-30T03:25:26.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：数据结构">第一章：数据结构</h1><h2 id="链表">链表</h2><h3 id="特性">特性</h3><ul><li>呈线性排列的数据结构，元素中有字段指向下一个元素</li></ul><h3 id="内存">内存</h3><ul><li>内存空间不连续</li></ul><h3 id="时间复杂度">时间复杂度</h3><ul><li><p>删除：</p><ul><li><p>直接在最后把指向被删除的元素改为指向被删除的下一个元素修改即可</p></li><li><p>时间复杂度：O(1)</p></li></ul></li><li><p>添加：</p><ul><li><p>直接在当前列表的最后的元素的指向另一个元素即可</p></li><li><p>时间复杂度：O(1)</p></li></ul></li><li><p>查询：</p><ul><li><p>需要从最开始的元素查询</p></li><li><p>时间复杂度：O(n)</p></li></ul></li></ul><h3 id="扩展">扩展</h3><ul><li>循环链表，最后一个元素的下一个元素指向开头的元素</li><li>每个元素有两个指向，分别指向前一个元素和后一个元素</li></ul><h2 id="数组">数组</h2><h3 id="特性-v2">特性</h3><ul><li>呈线性排列的数据结构，元素有下标</li></ul><h3 id="内存-v2">内存</h3><ul><li>元素在内存中是连续的</li></ul><h3 id="时间复杂度-v2">时间复杂度</h3><ul><li><p>添加：</p><ul><li><p>首先需要在末尾增加需要的存储空间，把需要添加的位置以及以后的元素的下标全部+1，把需要添加的位置放进新的元素</p></li><li><p>时间复杂度：O(n)</p></li></ul></li><li><p>删除：</p><ul><li><p>依此把需要删除的位置的以后的元素的下标-1</p></li><li><p>时间复杂度：O(n)</p></li></ul></li><li><p>查询：</p><ul><li><p>根据下标直接随机访问</p></li><li><p>时间复杂度：O(1)</p></li></ul></li></ul><h2 id="栈">栈</h2><h3 id="特性-v3">特性</h3><ul><li><p>呈线性排列的数据结构；后进先出Last In First Out，简称 LIFO</p></li><li><p>push（入栈），pop（出栈）</p></li></ul><h3 id="时间复杂度-v3">时间复杂度</h3><ul><li>入栈和出栈，时间复杂度都是：O(1)</li></ul><h2 id="队列">队列</h2><h3 id="特性-v4">特性</h3><ul><li>呈线性排列的数据结构；先进先出First In First Out，简称FIFO</li><li>入队，出队</li></ul><h3 id="时间复杂度-v4">时间复杂度</h3><ul><li>入队和出队的时间复杂度都是：O(1)</li></ul><h2 id="哈希表">哈希表</h2><h3 id="特性-v5">特性</h3><ul><li>哈希表存储的是由键（key）和值（value）组 成的数据</li><li>如果在hash值不冲突时，哈希表的每个桶都只保存一个key；如果hash值冲突了，则会变成链表存储</li><li>先用key计算hash值，将得到的哈希值除以数组的长度，求得其余数、就找到了存储位置。这样的求余运算叫作“mod 运算”</li><li>如果两个key的hash值求余后找到的存储位置已经有值，这种存储位置重复了的情况便叫作“冲突”。遇到这种情况，可使用链表在已有数据的后面 继续存储新的数据</li></ul><h3 id="时间复杂度-v5">时间复杂度</h3><ul><li>哈希表的时间复杂度与hash算法有关<ul><li>如果hash值不会冲突（理想情况），则新增、修改、删除、查询的时间复杂度都是：O(1)</li><li>如果hash值全部一致，则hash表其实就是一个链表，时间复杂度也与链表一致</li></ul></li></ul><h3 id="补充说明">补充说明</h3><p>在存储数据的过程中，如果发生冲突，可以利用链表在已有数据的后面插入新数据 来解决冲突；这种方法被称为“链地址法”。</p><p>除了链地址法以外，还有几种解决冲突的方法。</p><p>其中，应用较为广泛的是“开放地址法”。这种方法是指当冲突发生时，立刻计算出一个候补地址（数组上的位置）并将数 据存进去。如果仍然有冲突，便继续计算下一个候补地址，直到有空地址为止。可以通过多次使用哈希函数或“线性探测法”等方法计算候补地址。</p><h2 id="堆">堆</h2><h3 id="特性-v6">特性</h3><ul><li><p>堆是一种图的树形结构，被用于实现“优先队列”（priority queues）。</p></li><li><p>优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺 序取出。</p></li><li><p>在堆的树形结构中，各个顶点被称为“结点”（node），数据就存储在这些结点中。</p></li><li><p>堆中的节点最多有两个子节点，节点的排序为从上到下，同一行则从左到右。</p></li><li><p>堆中存储数据的规则：子节点必须大于父节点</p></li></ul><h3 id="时间复杂度-v6">时间复杂度</h3><ul><li><p>添加数据</p><ul><li>增加节点时在最下面一行的最左边增加，如果最下面的一行没有位置则增加新的一行</li><li>如果增加的数据比父节点的数字小，则与父节点交换位置，重复此步骤直到比父节点大或者没有父节点为止</li><li>时间复杂度：O(logn)</li></ul></li><li><p>取出数据</p><ul><li>取出数据永远是取最上面节点的数据</li><li>最上面节点的数据被取走之后，需要重新调整</li><li>重新调整时，需要把最后的数据（即最下面一行最右边的节点）移动到最上面</li><li>然后与最上面的两个子节点做比较，如果数字小于两个子节点，则调整完成</li><li>如果最上面的数据大于子节点的数据，则与较小的子节点的位置进行交换，重复此操作直到所有父节点小于子节点为止</li><li>时间复杂度:O(logn)</li></ul></li></ul><h2 id="二叉查找树">二叉查找树</h2><h3 id="特性-v7">特性</h3><ul><li><p>二叉查找树（又叫作二叉搜索树或二叉排序树）是一种采用了图的树形结构的数据结构</p></li><li><p>每个节点最多有两个子节点</p></li><li><p><strong>每个节点的值大于其左子树的任意节点的值</strong></p></li><li><p><strong>每个节点的值小于其右子树的任意节点的值</strong></p></li><li><p>根据上面的特性，我们可以知道如果想要查找最小值，则在左边的最末端</p></li></ul><h3 id="时间复杂度-v7">时间复杂度</h3><ul><li><p>添加数据</p><ul><li>从顶端开始查找添加位置</li><li>如果添加的值大于顶端的值，则往右移；小于它则往左移</li><li>时间复杂度：O(logn)</li></ul></li><li><p>删除数据</p><ul><li>如果删除的节点没有子节点，则直接删除此节点</li><li>如果删除的节点有一个子节点，则删除此节点后把子节点移到当前的节点</li><li>如果删除的节点有两个子节点，则删除此节点后把左边子节点的最右端移到当前节点（也可以把右边子节点的最左端移到当前节点）</li><li>上面的一句可以理解为：把小于被删除的节点的最大值移到删除的节点；或者把大于被删除节点的最小值移到删除节点</li><li>如果移动的节点还有子节点，也按照同样的方式移动</li><li>时间复杂度：O(logn)</li></ul></li><li><p>查找数据</p><ul><li>从顶端开始查找</li><li>如果大于查找节点的值，则向右移；如果小于查找节点的值，则向左移；循环此操作</li><li>时间复杂度：O(logn)</li></ul></li></ul><h3 id="扩展-v2">扩展</h3><h4 id="关于时间复杂度">关于时间复杂度</h4><ul><li>如果数的形状比较均衡，查找的时间复杂度是O(logn)</li><li>如果不均衡极端情况下是一个链表，查找的时间复杂度是O(n)</li></ul><h4 id="以二叉查找树为基础扩展的数据结构">以二叉查找树为基础扩展的数据结构</h4><ul><li>“平衡二叉查找树”：这种数据结构可以修正形状不均衡的树，让其始终保持均衡形态，以提高查找效率</li><li>“B 树”：二叉查找树中一个结点最多有两个子结点，如果我们把子结点数扩展为 m（m 为预先设定好的常数）。像这种子结点数可以自由设定，并且形状均衡的树便是 B 树</li></ul><h1 id="第二章：排序">第二章：排序</h1><h2 id="冒泡排序">冒泡排序</h2><h3 id="算法释义">算法释义</h3><p>冒泡排序就是重复“从序列右边开始比较相邻两个数字的大小，再根据结果交换两个数字 的位置”这一操作的算法。</p><p>在这个过程中，数字会像泡泡一样，慢慢从右往左“浮”到序列的 顶端，所以这个算法才被称为“冒泡排序”。</p><h3 id="时间复杂度：O-n²">时间复杂度：O(n²)</h3><p>在冒泡排序中：</p><ul><li><p>第 1 轮需要比较 n -1 次</p></li><li><p>第 2 轮需要比较 n -2 次</p></li><li><p>第 n -1 轮需 要比较 1 次</p></li></ul><p>因此，总的比较次数为 (n -1) +(n -2) +…+1 ≈ n² /2。这个比较次数恒定为 该数值，和输入数据的排列顺序无关。</p><h3 id="Java代码实现">Java代码实现</h3><p><a href="https://github.com/nijixucai/my-tools/blob/master/my-learn/my-algorithm/src/main/java/com/nicai/algorithm/sort/BubbleSortStartFromLeft.java" target="_blank" rel="noopener">冒泡排序</a></p><h2 id="选择排序">选择排序</h2><h3 id="算法释义-v2">算法释义</h3><ul><li>选择排序就是重复“从待排序的数据中寻找最小值，将其与序列最左边的数字进行交换” 这一操作的算法。</li><li>在序列中寻找最小值时使用的是线性查找。</li></ul><h3 id="时间复杂度：O-n²-v2">时间复杂度：O(n²)</h3><p>选择排序使用了线性查找来寻找最小值，因此在</p><ul><li>第 1 轮中需要比较 <em>n</em> - 1 个数字</li><li>第 2 轮需要比较 <em>n</em> - 2 个数字</li><li>到第 <em>n</em> - 1 轮的时候就只需比较 1 个数字</li><li>因此，总的比较次数与冒泡排序的相同，都是(<em>n</em>-1)+(<em>n</em>-2)+…+1 ≈ <em>n</em>2/2 次。</li></ul><h3 id="Java代码实现-v2">Java代码实现</h3><p><a href="https://github.com/nijixucai/my-tools/blob/master/my-learn/my-algorithm/src/main/java/com/nicai/algorithm/sort/SelectSort.java" target="_blank" rel="noopener">选择排序</a></p><h2 id="插入排序">插入排序</h2><h3 id="算法释义-v3">算法释义</h3><p>插入排序是一种从序列左端开始依次对数据进行排序的算法。</p><p>在排序过程中，左侧的数据陆续归位，而右侧留下的就是还未被排序的数据。</p><p>插入排序的思路就是从右侧的未排序区域内取出一个数据，然后将它插入到已排序区域内合适的位置上。</p><h3 id="时间复杂度：O-n²-v3">时间复杂度：O(n²)</h3><h3 id="Java代码实现-v3">Java代码实现</h3><p><a href="https://github.com/nijixucai/my-tools/blob/master/my-learn/my-algorithm/src/main/java/com/nicai/algorithm/sort/InsertSort.java" target="_blank" rel="noopener">插入排序</a></p><h2 id="堆排序">堆排序</h2><h3 id="算法释义-v4">算法释义</h3><p>堆排序的特点是利用了数据结构中的堆</p><ul><li>首先，在堆中存储所有的数据，并按降序来构建堆</li><li>然后从堆中取出数据，并把取出的数据放在最右边的空位置</li></ul><h3 id="时间复杂度：O-nlogn">时间复杂度：<em>O</em>(<em>n</em>log<em>n</em>)</h3><p>堆排序一开始需要将 <em>n</em> 个数据存进堆里，所需时间为 <em>O</em>(<em>n</em>log<em>n</em>)</p><p>每轮取出最大的数据并重构堆所需要的时间为 <em>O</em>(log<em>n</em>)</p><p>由于总共有 <em>n</em> 轮，所以重构后排序的时间也是 <em>O</em>(<em>n</em>log<em>n</em>)</p><p>因此，整体来看堆排序的时间复杂度为 <em>O</em>(<em>n</em>log<em>n</em>)</p><h3 id="Java代码实现-v4">Java代码实现</h3><p>暂无</p><h2 id="归并排序">归并排序</h2><h3 id="算法释义-v5">算法释义</h3><p>归并排序算法会把序列分成长度相同的两个子序列，当无法继续往下分时(也就是每个子序列中只有一个数据时)，就对子序列进行归并。</p><p>归并指的是把两个排好序的子序列合并成一个有序序列。</p><p>该操作会一直重复执行，直到所有子序列都归并为一个整体为止。</p><h3 id="时间复杂度-O-nlogn">时间复杂度:O(nlogn)</h3><ul><li>把数组拆分成不可分割的最小单元的数组，时间复杂度O(n)</li><li>依次把所有数组进行合并排序，每一轮的比较次数为O(n)；需要进行logn轮</li><li>最终的时间复杂度是O(nlogn)</li></ul><h3 id="Java代码实现-v5">Java代码实现</h3><p><a href="https://github.com/nijixucai/my-tools/blob/master/my-learn/my-algorithm/src/main/java/com/nicai/algorithm/sort/MergeSort.java" target="_blank" rel="noopener">归并排序</a></p><h2 id="快速排序">快速排序</h2><h3 id="算法释义-v6">算法释义</h3><ul><li><p>快速排序算法首先会在序列中随机选择一个基准值（pivot）</p></li><li><p>然后将除了基准值以外的数分为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。</p><ul><li>[ 比基准值小的数 ] 基准值 [ 比基准值大的数 ]</li></ul></li><li><p>接着，对两个“[ ]”中的数据进行排序之后，整体的排序便完成了。对“[ ]”里面的数据进行排序时同样也会使用快速排序。</p></li></ul><h3 id="时间复杂度：O-nlogn-v2">时间复杂度：O(nlogn)</h3><ul><li>每一轮比较的次数为n次，时间复杂度O(n)</li><li>需要进行logn轮的比较</li><li>最终的时间复杂度是O(nlogn)</li></ul><h3 id="Java代码实现-v6">Java代码实现</h3><p><a href="https://github.com/nijixucai/my-tools/blob/master/my-learn/my-algorithm/src/main/java/com/nicai/algorithm/sort/FastSort.java" target="_blank" rel="noopener">快速排序</a></p><h3 id="扩展-v3">扩展</h3><p>基准值约接近数组的平均值，排序的速度越快；基准值一般都使用第一个数字</p><h1 id="第三章：数组的查找">第三章：数组的查找</h1><h2 id="线性查找">线性查找</h2><h3 id="特性-v8">特性</h3><ul><li>遍历整个数组，逐个进行比较，直到找到为止</li></ul><h3 id="时间复杂度：O-n">时间复杂度：O(n)</h3><h3 id="Java代码实现-v7">Java代码实现</h3><p><a href="https://github.com/nijixucai/my-tools/blob/master/my-learn/my-algorithm/src/main/java/com/nicai/algorithm/search/LinearSearch.java" target="_blank" rel="noopener">线性查找</a></p><h2 id="二分查找">二分查找</h2><h3 id="特性-v9">特性</h3><ul><li>只能查找已经排好序的数组</li><li>每次查找取中间位置的值与需要查找的数字比较，如果中间值大于待查找数据，则继续在中间值左边的数组进行查找；反之亦然</li></ul><h3 id="时间复杂度-O-logn">时间复杂度 O(logn)</h3><ul><li>每一次查找都会把待查找的范围缩小一半，直到结束为止</li><li>查找需要logn轮，每一轮比较1次；所以时间复杂度为O(logn)</li></ul><h3 id="Java代码实现-v8">Java代码实现</h3><p><a href="https://github.com/nijixucai/my-tools/blob/master/my-learn/my-algorithm/src/main/java/com/nicai/algorithm/search/BinarySearch.java" target="_blank" rel="noopener">二分查找</a></p><h1 id="第四章：图的搜索">第四章：图的搜索</h1><h2 id="图的定义">图的定义</h2><p>计算机科学或离散数学中说的“图”是下面这样的：</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/null/image-20200822163332465.png" alt="image-20200822163332465"></p><p>上图中的圆圈叫作“顶点”(也叫“结点”)，连接顶点的线叫作“边”。也就是说，<strong>由顶点和连接每对顶点的边所构成的图形就是图</strong>。<em>图可以表示各种关系</em></p><h3 id="加权图">加权图</h3><p>我们可以给边加上一个值，这个值叫作边的“权重”或者“权”，加了权的图被称为“加权图”。</p><p>没有权的边只能表示两个 顶点的连接状态，而有权的边就可以表示顶点之间的“连接程度”。</p><p>所谓“程度”在不同的场景意思也不一样：</p><ul><li>地铁线路图两站之间的权是两站之间的距离</li><li>同样是地铁线路图，两站之前的权也可以是两站之间的时间</li><li>如果是高铁站线路图，两站之间的权也可以表示两站之间的乘车费</li></ul><h3 id="有向图">有向图</h3><p>当我们想在路线图中表示该路线只能单向行驶时，就可以给边加上箭头，而这样的图就叫 作“有向图”。</p><p>和无向图一样，有向图也可以在边上添加权重，而且根据方向的不同，权重也不一样。</p><p>如下图中，如果权重表示花费时间，则B点到C点是下坡路，反过来C到B就是上坡路。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/null/image-20200822164224711.png" alt="image-20200822164224711"></p><h3 id="图能给我们带来哪些便利">图能给我们带来哪些便利</h3><p>假设图中有两个顶点 <em>s</em> 和 <em>t</em>，而我们设计出了一种算法， 可以找到“从 <em>s</em> 到 <em>t</em> 的权重之和最小”的那条路径，如：</p><ul><li>寻找计算机网络中通信时间最短的路径</li><li>寻找路线图中耗时最短的路径</li><li>寻找路线图中最省乘车费的路径</li></ul><h3 id="图在代码中如何实现">图在代码中如何实现</h3><ul><li>图是用来表示节点与节点的关系的，所以可以使用Map来实现图</li><li>有向图，如上面图两个节点A和B、map中key为A的值有B，而key为B的值没有A，就可以表示方向</li><li>加权图，同样适用Map实现，区别是在value中既包含下一个节点的信息，又包含权重信息<a href="https://github.com/nijixucai/my-tools/blob/master/my-learn/my-algorithm/src/main/java/com/nicai/algorithm/map/AssignWeightsNode.java" target="_blank" rel="noopener">加权图Java实现</a></li></ul><h2 id="图的搜索">图的搜索</h2><h3 id="广度优先搜索">广度优先搜索</h3><p>假设我们一开始位于某个顶点(即起点)，此时并不知道图的整体结构，而我们的目的是从起点开始顺着边搜索，直到到达指定顶点(即终点)。</p><p>在此过程中每走到一个顶点，就会判断一次它是否为终点。广度优先搜索会优先从离起点近的顶点开始搜索。</p><h4 id="Java代码实现-v9">Java代码实现</h4><p><a href="https://github.com/nijixucai/my-tools/blob/master/my-learn/my-algorithm/src/main/java/com/nicai/algorithm/map/BreadthFirstSearch.java" target="_blank" rel="noopener">广度优先搜索</a></p><h3 id="深度优先搜索">深度优先搜索</h3><p>深度优先搜索会沿着一条路径不断往下搜索直到不能再继续为止，然后再折返，开始搜索下一条候补路径。</p><h4 id="Java代码实现-v10">Java代码实现</h4><p><a href="https://github.com/nijixucai/my-tools/blob/master/my-learn/my-algorithm/src/main/java/com/nicai/algorithm/map/DepthFirstSearch.java" target="_blank" rel="noopener">深度优先搜索</a></p><h3 id="广度优先搜索和深度优先搜索对比">广度优先搜索和深度优先搜索对比</h3><p>广度优先搜索选择的是最早成为候补的顶点，因为顶点离起点越近就越早成为候补，所以会从离起点近的地方开始按顺序搜索;</p><p>而深度优先搜索选择的则是最新成为候补的顶点，所以会一路往下，沿着新发现的路径不断深入搜索。</p><h3 id="贝尔曼-福特算法">贝尔曼 - 福特算法</h3><h4 id="解决的问题">解决的问题</h4><ul><li><p>贝尔曼 - 福特(Bellman-Ford)算法是一种在图中求解最短路径问题的算法。</p></li><li><p>最短路径问题就是在加权图指定了起点和终点的前提下，寻找从起点到终点的路径中权重总和最小的那条路径。</p></li></ul><h4 id="求解的步骤">求解的步骤</h4><ul><li>首先设置各个顶点的初始权重 :起点为 0，其他顶点为无穷大(∞)；这个权重的意思是从起点到当前节点的最短路径暂定值。</li><li>从起点（A）开始遍历，找到子节点（B），更新子节点的权重：min(A的权重+A到B边的权重,B节点权重)</li><li>循环上面的步骤一直更新所有节点</li></ul><h4 id="时间复杂度O-nm">时间复杂度<em>O</em>(<em>nm</em>)</h4><ul><li>将图的顶点数设为 <em>n</em>、边数设为 <em>m</em>。</li><li>该算法经过 <em>n</em> 轮更新操作后就会停止，而在每轮更新操作中都需要对各个边进行 1 次确认</li><li>因此 1 轮更新所花费的时间就是 <em>O</em>(<em>m</em>)，整体的时间复杂度就是 <em>O</em>(<em>nm</em>)</li></ul><h4 id="Java代码实现-v11">Java代码实现</h4><p><a href="https://github.com/nijixucai/my-tools/blob/7629245129fcdb4422e45fe37a8c332b1244140f/my-learn/my-algorithm/src/main/java/com/nicai/algorithm/map/BellmanFord.java" target="_blank" rel="noopener">贝尔曼-福特算法</a></p><h3 id="狄克斯特拉算法">狄克斯特拉算法</h3><h4 id="解决的问题-v2">解决的问题</h4><p>狄克斯特拉(Dijkstra)算法也是求解最短路径问题 的算法，使用它可以求得从起点到终点的路径中权重总和最小的那条路径。</p><h4 id="求解的步骤-v2">求解的步骤</h4><ul><li>首先设置各个顶点的初始权重 :起点为 0，其他顶点为无穷大(∞)；这个权重的意思是从起点到当前节点的最短路径暂定值。</li><li>从起点出发，寻找可以从目前所在的顶点直达且尚未被搜索过的顶点。</li><li>计算各个候补顶点的权重。计算方法是“目前所在顶点的权重+目前所在顶点到候补顶点的权重”。</li><li>如果计算结果小于候补顶点的值，就更新这个值。</li><li><strong>从候补顶点中选出权重最小的顶点，作为下一个被搜索的点</strong>，这一点与贝尔曼-福特算法不一样</li></ul><h4 id="时间复杂度-v8">时间复杂度</h4><p>将图的顶点数设为 <em>n</em>、边数设为 <em>m</em>，那么如果事先不进行任何处理，该算法的时 间复杂度就是 <em>O</em>(<em>n</em>2)。</p><p>不过，如果对数据结构进行优化，那么时间复杂度就会变为 <em>O</em>(<em>m</em> + <em>n</em>log<em>n</em>)。</p><h4 id="Java代码实现-v12">Java代码实现</h4><p><a href="https://github.com/nijixucai/my-tools/blob/master/my-learn/my-algorithm/src/main/java/com/nicai/algorithm/map/Dijkstra.java" target="_blank" rel="noopener">狄克斯特拉(Dijkstra)算法</a></p><h3 id="贝尔曼福特算法和迪克斯特拉算法对比">贝尔曼福特算法和迪克斯特拉算法对比</h3><h4 id="说明">说明</h4><p>如果在一个闭环中边的权重总和是负数，那么只要不断遍历这个闭环，路径的权重就能不断减小，也就是说根本不存在最短路径。</p><p>贝尔曼 - 福特算法可以直接认定不存在最短路径，但在狄克斯特拉算法中，即便不存在最短路径，它也会 算出一个错误的最短路径出来。因此，有负数权重时不能使用狄克斯特拉算法。</p><p>总的来说，就是不存在负数权重时，更适合使用效率较高的狄克斯特拉算法，而存 在负数权重时，即便较为耗时，也应该使用可以得到正确答案的贝尔曼 - 福特算法。</p><h3 id="A-（A-Star）算法">A*（A-Star）算法</h3><h4 id="解决的问题-v3">解决的问题</h4><p>A-Start算法也是解决在图中求解最短路径问题的算法，由狄克斯特拉算法发展而来。</p><p>狄克斯特拉算法会从离起点近的顶点开始，按顺序求出起点到各个顶点的最短路径。</p><p>也就是说，一些离终点较远的顶点的最短路径也会被计算出来，但这部分其实是无用的。</p><p>与之不同，A* 就 会预先估算一个值，并利用这个值来省去一些无用的计算</p><h1 id="第五章-安全算法">第五章 安全算法</h1><h2 id="安全和算法">安全和算法</h2><h3 id="传输数据时的四个问题">传输数据时的四个问题</h3><h4 id="窃听">窃听</h4><p>A 向 B 发送的消息可能会在传输途中被 X 偷看(如下图)。这就是“窃听”。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200918183116803.png" alt="image-20200918183116803"></p><h4 id="假冒">假冒</h4><p>A 以为向 B 发送了消息，然而 B 有可能是 X 冒充的(如下图);反过来，B 以为从 A 那里收到了消息，然而 A 也有可能是 X 冒充的。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200918183227754.png" alt="image-20200918183227754"></p><h4 id="篡改">篡改</h4><p>即便 B 确实收到了 A 发送的消息，但也有可能像右图 这样，该消息的内容在途中就被 X 更改了。</p><p>除了被第三者篡改外，通 信故障导致的数据损坏也可能会使消息内容发生变化。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200918183344985.png" alt="image-20200918183344985"></p><h4 id="事后否认">事后否认</h4><p>B 从 A 那里收到了消息，但作为消息发送者的 A 可 能对 B 抱有恶意，并在事后声称“这不是我发送的消息”。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200918183430948.png" alt="image-20200918183430948"></p><h3 id="解决这些问题的安全技术">解决这些问题的安全技术</h3><ul><li><p>为了应对“窃听”，我们会使用“加密” 技术。</p></li><li><p>为了应对“假冒”，我们会使用“消息认证码”(下图左)或“数字签名”(下图右)技术。</p></li><li><p>为了应对“篡改”，我们同样会使用 “消息认证码”或“数字签名”技术。</p></li><li><p>其中“数字签名”技术还可以用于预防“事后否认”。</p></li></ul><h2 id="哈希函数">哈希函数</h2><ul><li><p>哈希函数可以把给定的数据转换成固定长度的无规律数值。</p></li><li><p>转换后的无规律数值可以作为数据摘要应用于各种各样的场景。</p></li></ul><p>希函数的特征：</p><ul><li>第一个特征是输出的哈希值数据长度不变。（不论输入的参数长短，得到的哈希值是定长的）</li><li>第二个特征是如果输入的数据相同，那么输出 的哈希值也必定相同。</li><li>第三个特征是即使输入的数据相似，但哪怕它们只有一比特的差别，那么输出的哈希值也会有很大的差异。</li><li>第四个特征是即使输入的两个数据完全不同，输 出的哈希值也有可能是相同的；这种情况叫作“哈希冲突”。</li><li>第五个特征是不可能从哈希值反向推算出原本的数据。（输入和输出不可逆）</li></ul><p>哈希函数的算法中具有代表性的是 MD5 1、SHA-1 2和 SHA-2 等。其中 SHA-2 是现 在应用较为广泛的一个，而 MD5 和 SHA-1 存在安全隐患，不推荐使用。</p><h3 id="应用示例">应用示例</h3><p>将用户输入的密码保存到服务器时也需要用到哈希函数。</p><p>如果把密码直接保存到服务器，可能会被第三者窃听，因此需要算出密码的哈希值，并只存储哈希值。</p><p>当用户输入密码时，先算出该输入密码的哈希值，再把它和服务 器中的哈希值进行比对。</p><h2 id="共享密钥加密（对称加密）">共享密钥加密（对称加密）</h2><p>共享密钥加密是加密和解密都<strong>使用相同密钥</strong>的一种加密方式。</p><p>实现共享密钥加密的算法有凯撒密码、AES 1、DES 2、动态口令等，其中 AES 的应用最 为广泛。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200918185110697.png" alt="对称加密"></p><h3 id="存在密钥分配问题">存在密钥分配问题</h3><p>如上图，如果在A给B发送密钥时，被X监听了，则X就能用相同的密钥解密截获的密文。</p><h2 id="公开密钥加密（非对称加密）">公开密钥加密（非对称加密）</h2><ul><li><p>公开密钥加密是加密和解密使用不同密钥的一种加密方法。</p></li><li><p>由于使用的密钥不同，所以这种算法也被称为“非对称加密”。</p></li><li><p>加密用的密钥叫作“公开密钥”，解密用的叫作“私有密钥”。</p></li></ul><p>实现公开密钥加密的算法有 RAS 算法、椭圆曲线加密算法等，其中使用最为广泛的是 RSA 算法。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200918185651314.png" alt="image-20200918185651314"></p><h3 id="不存在密钥分配问题">不存在密钥分配问题</h3><p>公开密钥和密文都是通过互联网传输的，因此可能会被 X 窃听。</p><p>但是，使用公开密钥无法解密密文，因此 X 也无法得到原本的数据。</p><h3 id="密钥数量不会过多">密钥数量不会过多</h3><p>只需要生成一对公私钥，就可以把公钥共享给n个人使用。</p><p>对称加密就的密钥数量会随着人的增多而增多。</p><h3 id="公开密钥加密存在公开密钥可靠性的问题">公开密钥加密存在公开密钥可靠性的问题</h3><p>如下图，加入B在把公钥Pb共享给A的时候，被X截获了；X把自己的公钥Px发送给了A。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919111210334-20200919113122148.png" alt="image-20200919111210334"></p><p>这时A在不知情的情况下使用Px对数据进行加密发送给B时，X截获密文就可以通过私钥Sx进行解密。</p><p>然后X可以截获的通过公钥Pb加密恶意数据发送给B，B能够使用自己的密钥Sb进行解密，以为数据是A发送的。</p><p>如下图所示：</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919113151447.png" alt="image-20200919113151447"></p><h3 id="非对称加密算法的条件">非对称加密算法的条件</h3><ul><li>可以使用某个数值对数据进行加密(计算)。</li><li>使用另一个数值对加密数据进行计算就可以让数据恢复原样。</li><li>无法从一种密钥推算出另一种密钥。</li></ul><h2 id="混合加密">混合加密</h2><p>共享密钥加密存在无法安全传输密钥的密钥分配问题，公开密钥加密又存在加密解密速度较慢的问题。</p><p>在混合加密中，要用处理速度较快的共享密钥加密对数据进行加密。不过，加密时使用的密钥，则需要用没有密钥分配问题的公开密钥加密进行处理。混合加密可以拆分成下面两步操作：</p><p>1、A在给B发送数据之前，先使用非对称的公钥对”对称加密的密钥“进行加密，然后把加密后的密文发送给A，A解密后就得到了”对称加密的密钥“。如下图：</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919113611840.png" alt="image-20200919113611840"></p><p>2、发送数据时，A使用”对称加密的密钥“对数据进行加密，然后发送给B，这样B就能使用之前收到的”对称加密的密钥“对数据进行解密。如下图：</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919114040964.png" alt="image-20200919114040964"></p><h2 id="迪菲-赫尔曼密钥交换">迪菲 - 赫尔曼密钥交换</h2><p>迪菲 - 赫尔曼(Diffie-Hellman)密钥交换是一种可以在通信双方之间安全交换密钥的方法。</p><p>这种方法通过将双方共有的秘密数值隐藏在公开数值相关的运算中，来实现双方之间密钥的安全交换。</p><h3 id="算法的概念">算法的概念</h3><p>假设有一种方法可以合成两个密钥。使用这种方法来合成密钥P和密钥S，就会得到由这两个密钥的成分所构成的密钥 P-S。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919114844473.png" alt="image-20200919114844473"></p><p>这种合成方法有三个特征。</p><ul><li>第一，即使持有密钥 P 和合成的密钥 P-S，也无法把密钥 S 单独取出来。</li><li>第二，不管是怎样合成而来的密钥，都可以把它作为新的元素，继续与别的密钥进行合成。如下图，使用密钥 P 和密钥 P-S，还能合成出新的密钥 P-P-S。<ul><li><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919115000979-0487431.png" alt="image-20200919115000979"></li></ul></li><li>第三，密钥的合成结果与合成顺序无关，只与用了哪些密钥有关。比如合成密钥 B 和密钥 C 后，得到的是密 钥 B-C，再将其与密钥 A 合成，得到的就是密钥 A-B-C。而合成密钥 A 和密钥 C 后，得到的是密钥 A-C， 再将其与密钥 B 合成，得到的就是密钥 B-A-C。此处的密钥 A-B-C 和密钥 B-A-C 是一样的。<ul><li><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919115117042.png" alt="image-20200919115117042"></li></ul></li></ul><h3 id="密钥的交换">密钥的交换</h3><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919115514893.png" alt="image-20200919115514893"></p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919115535132.png" alt="image-20200919115535132"></p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919115557280.png" alt="image-20200919115557280"></p><h2 id="消息认证码，MAC（Message-Authentication-Code）">消息认证码，MAC（Message Authentication Code）</h2><p>消息认证码可以实现“认证”和“检测篡改”这两个功能。</p><p>举个例子，如下图，假设 A 发送给 B 的密文（abc）在通信过程中被 X 恶意篡改了，而 B 收到密文后没有意识到这个问题。</p><p>B对密文进行解密可能无法解密或者解密后的数据是xyz。如果A在向B进行商品订购，如果B解密出的密文是xyz，就会给A发送xyz商品从而导致问题。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919115921527.png" alt="image-20200919115921527"></p><h3 id="如何使用消息认证码解决篡改问题呢？">如何使用消息认证码解决篡改问题呢？</h3><ol><li>A在发送数据之前，先生成一个用于制作消息验证码的密钥（key），然后用安全的方法（如混合加密）发送给B</li><li>A对数据进行加密，并且使用第一步生成的key和密文生成一个数值，此值就是MAC</li><li>A把MAC和密文一起发送给B</li><li>B接收到密文和MAC后，先使用第一步A发送过来的key和密文使用同样的方法生成一个数值；并且使用此数值和收到的MAC进行比对<ol><li>如果比对一致，则说明数据未被篡改</li><li>如果比对不一致，则说明数据被篡改了，直接丢弃数据；然后通知A重发</li></ol></li></ol><h3 id="如果MAC和密文都被X截获了怎么办？">如果MAC和密文都被X截获了怎么办？</h3><ul><li>X可以修改密文，此时B使用被篡改后的密文和key生成的数值不等于MAC，就能确认通信过程中发生了篡改</li><li>X如果篡改了MAC，也与上一步一样，B也能确认通信过程中发生了篡改</li><li>X既篡改了密文也篡改了MAC，因为X没有生成MAC的key，所以B收到被篡改后的数据时同样能确认发生了篡改</li></ul><p><strong>我们可以把 MAC 想象成是由密钥和密文组成的字符串的“哈希值”。</strong></p><p><strong>计算 MAC 的算法有 HMAC 1、OMAC 2、CMAC 3等。目前，HMAC 的应用最为广泛。</strong></p><h3 id="消息验证码无法防止“事后否认”">消息验证码无法防止“事后否认”</h3><p>然而，这种方法也有缺点。在使用消息认证码的过程中，AB 双方都可以对消息进行加密并且算出 MAC。</p><p>也就是说，我们无法证明原本的消息是 A 生成的还是 B 生成的。 因此，假如 A 是坏人，他就可以在自己发出消息后声称“这条消息是 B 捏造的”，而否认自己的行为。如果 B 是坏人，他也可以自己准备一条消息，然后声称“这是 A 发 给我的消息”。</p><h2 id="数字签名">数字签名</h2><p>数字签名不仅可以实现消息认证码的认证和检测篡改功能，还可以预防事后否认问题的发生。</p><p>由于在消息认证码中使用的是共享密钥加密，所以持有密钥的收信人也有可能是消息的发 送者，这样是无法预防事后否认行为的。</p><p>而数字签名是只有发信人才能生成的，因此使用它就可以确定谁是消息的发送者了。</p><h3 id="数字签名的特征">数字签名的特征</h3><p>比如A给B发送消息，那么数字签名必须满足下面两个条件：</p><ul><li>只要发送的消息上有 A 的数字签名，就能确定消息的发送者就是 A。</li><li>B 可以验证数字签名的正确性，但无法生成数字签名。</li></ul><h3 id="如何实现数字签名">如何实现数字签名</h3><p>先回想一下非对称加密的流程，A给B发送消息时使用B提供的公钥进行加密，B使用自己的私钥进行解密。如下图：</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919153334400.png" alt="image-20200919153334400"></p><p>那么我们把这个过程反过来，就可以做到数字签名，如下图：</p><ol><li>A 使用自己的私有密钥加密消息。加密后的消息就是数字签名。</li><li>A把数字签名和原始的数据都发送给B</li><li>B接收到数字签名和数据后，使用A提供的公钥进行解密，并把解密后的数据和发送来的数据做比对</li><li>如果一致，则说明此消息是由A发送的，因为A的公钥只能解密经有A的私钥加密的数据</li></ol><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919153913102.png" alt="image-20200919153913102"></p><p>能够用 A 的公开密钥解密的密文，必定是由 A 生成的。因此，我们可以利用这个结论来确认消息的发送者是否为 A，消息是否被人篡改。</p><p>由于 B 只有公开密钥，无法生成 A 的签名，所以也预防了“事后否认”这一问题的 发生。</p><p><strong>在使用此方式进行加密时，A使用自己的私钥加密的数据最好没有任何意义，只是用来验证发送着是否是A，并且没有被篡改。</strong></p><h2 id="数字证书">数字证书</h2><p>“公开密钥加密”和“数字签名”无法保证公开密钥确实来自信息的发送者。因此，就算公 开密钥被第三者恶意替换，接收方也不会注意到。</p><p>而数字证书，就能保证公开密钥的正确性。</p><h3 id="如何使用数据证书发送公钥">如何使用数据证书发送公钥</h3><p>A持有公开密钥Pa 和 A私有密钥 Sa ，现在想要将公开密钥PA发送给B，如何做呢？</p><ol><li>A首先需要向认证中心 (Certification Authority， CA)申请发行证书，证明公开密钥PA 确实由自己生成</li><li>认证中心里保管着他们自己准备的公开密钥Pc和私有密钥 Sc</li><li>A将公开密钥Pa 和包含邮箱信息的个人资料发送给认证中心</li><li>认证中心对收到的资料进行确认，判断其是否为A本人的资料。确认完毕后，认证中心使用自己的私有密钥 Sc，根据 A 的资料生成数字签名。</li><li>认证中心将生成的数字签名和资料放进同一个文件中，并把这个文件发送给 A。（这个文件就是 A 的数字证书）</li><li>A 将作为公开密钥的数字证书发送给了 B。</li><li>B 收到数字证书后，确认证书里的邮件地址确实是 A 的地址。接着，B 获取了认证中心的公开密钥。</li><li>B 对证书内的签名进行验证，判断它是否为认证中心给出的签名。证书中的签名只能用认证中心的公开密钥 Pc 进行验证。如果验证结果没有异常，就能说明这份证书的确由认证中心发行。</li><li>确认了证书是由认证中心发行的，且邮件地址就是 A的之后，B从证书中取出A的公开密钥PA。这样，公开密钥便从 A 传到 了B。</li></ol><p>经过以上步骤信息的接收者B可以确认公开密钥的制作者是A。</p><h3 id="循环质疑，我们从认证中心获取的公钥Pc真的来自认证中心吗">循环质疑，我们从认证中心获取的公钥Pc真的来自认证中心吗</h3><p>由于公开密钥自身不能表示其制作者，所以有可能是冒充认证中心的 X 所生成的。也就是说，这里同样存在公开密钥问题(请参考下图)。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919165548842.png" alt="image-20200919165548842"></p><p>实际上，认证中心的公开密钥 PC 是以数字证书的形式交付的，会有更高级别的认证 中心对这个认证中心署名(请参考下图)。</p><p>所以我们有所怀疑可以一直验证下去。</p><p>最顶端的认证中心被称为“根认证中心”(root CA)，其自身的正当性由自己证明。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master//image-20200919165633696.png" alt="image-20200919165633696"></p><h1 id="第六章-聚类">第六章 聚类</h1><h2 id="什么是聚类">什么是聚类</h2><h3 id="将相似的对象分为一组">将相似的对象分为一组</h3><p>聚类就是在输入为多个数据时，将“相似”的数据分为一组的操作。1个组就叫作1个 “簇”。</p><p>下面的示例中每个点都代表 1 个数据，在平面上位置较为相近、被圈起来的点就代表一类相似的数据。</p><p>也就是说，这些数据被分为了 3 个簇。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/null/%E6%88%AA%E5%B1%8F2020-09-21%20%E4%B8%8B%E5%8D%8811.05.28.png" alt="截屏2020-09-21 下午11.05.28"></p><h3 id="如何定义“相似”">如何定义“相似”</h3><h4 id="定义数据间的差距">定义数据间的差距</h4><p>根据数据类型不同，定义该数据是否“相似”的标准也不同。具体来说，就是要对两个数 据之间的“差距”进行定义。</p><p>如：假设某所高中的某个年级中共有 400 名学生，现在我们想要将这些学生在考试中取得的语 文、数学、英语成绩数据化，并将他们按照“擅长或不擅长的科目相似”进行聚类。</p><p>把每个学生都转换成“(语文成绩 , 数学成绩 , 英语成绩)”形式的数据后，就可以将两个数据(<em>c</em>1, <em>m</em>1, <em>e</em>1)和(<em>c</em>2, <em>m</em>2, <em>e</em>2)之间的差距定义为 (<em>c</em>1-<em>c</em>2) + (<em>m</em>1-<em>m</em>2) + (<em>e</em>1-<em>e</em>2) ，其中差距小的数据 就互为“相似的数据”。</p><h4 id="符合条件的算法">符合条件的算法</h4><p>即使定义好了数据间的差距，聚类的方法也会有很多种。我们可以设定各种各样的条件， 比如想把数据分为 10 个簇，或者想把 1 个簇内的数据定在 30~50 人之间，再或者想把簇内数据 间的最大距离设为 10，等等。而设定什么样的条件取决于进行聚类的目的。</p><h2 id="k-means-算法">k-means 算法</h2><p><em>k</em>-means 算法是聚类算法中的一种，它可以根据事先给定的簇的数量进行聚类。</p><h3 id="k-means算法步骤">k-means算法步骤</h3><ol><li>首先准备好需要聚类的数据，然后决定簇的数量（比如下面图示簇的数量为3）。</li><li>随机选择 3 个点作为簇的中心点。</li><li>计算各个数据分别和 3 个中心点中的哪一个点距离最近。</li><li>将数据分到相应的簇中。这样，3 个簇的聚类就完成了。</li><li>计算各个簇中数据的重心，然后将簇的中心点移动到这个位置。</li><li>重新计算距离最近的簇的中心点，并将数据分到相应的簇中。</li><li>重复执行“将数据分到相应的簇中”和“将中心点移到重心的位置”这两个操作，直到中心点不 再发生变化为止。</li></ol><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/null/image-20200921231952128.png" alt="image-20200921231952128"></p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/null/image-20200921232008317.png" alt="image-20200921232008317"></p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/null/image-20200921232023522.png" alt="image-20200921232023522"></p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/null/image-20200921232039847.png" alt="image-20200921232039847"></p><h3 id="解说：">解说：</h3><p><em>k</em>-means 算法中，随着操作的不断重复，中心点的位置必定会在某处收敛，这一点 已经在数学层面上得到证明。</p><p>前面的例子中我们将簇的数量定为 3，若现在使用同样的数据，将簇的数量定为 2， 那么聚类将如下图所示。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/null/image-20200921232309104.png" alt="image-20200921232309104"></p><p>位于左边和下边的两个数据块被分到了一个簇中。就像这样，由于 <em>k</em>-means 算法需 要事先确定好簇的数量，所以设定的数量如果不合理，运行的结果就可能会不符合我们的需求。</p><p>如果对簇的数量没有明确要求，那么我们可以事先对数据进行分析，推算出一个合适的数量，或者不断改变簇的数量来试验 <em>k</em>-means 算法。</p><p>另外，如果簇的数量同样为 2，但中心点最初的位置不同，那么也可能会出现下图 这样的聚类结果。</p><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/null/image-20200921232443009.png" alt="image-20200921232443009"></p><p>与之前的情况不同，这次右上和右下的两个数据块被分到了一个簇中。也就是说， 即使簇的数量相同，只要随机设置的中心点最初的位置不同，聚类的结果也会产生变化。 因此，我们可以通过改变随机设定的中心点位置来不断尝试 <em>k</em>-means 算法，再从中选择 最合适的聚类结果。</p><h3 id="补充说明-v2">补充说明</h3><p>除了 <em>k</em>-means 算法以外，聚类算法还有很多，其中“层次聚类算法”较为有名。与 <em>k</em>-means 算法不同，层次聚类算法不需要事先设定簇的数量。</p><p>在层次聚类算法中，一开始每个数据都自成一类。也就是说，有 <em>n</em> 个数据就会形成 <em>n</em> 个簇。然后重复执行“将距离最近的两个簇合并为一个”的操作 <em>n</em>-1 次。每执行 1 次， 簇就会减少 1 个。执行 <em>n</em> - 1 次后，所有数据就都被分到了一个簇中。在这个过程中，每个阶段的簇的数量都不同，对应的聚类结果也不同。只要选择其中最为合理的 1 个结果 就好。</p><p>合并簇的时候，为了找出“距离最近的两个簇”，需要先对簇之间的距离进行定义。 根据定义方法不同，会有“最短距离法”“最长距离法”“中间距离法”等多种算法。</p><h1 id="第七章-其他算法">第七章 其他算法</h1><h2 id="欧几里得算法">欧几里得算法</h2><p>欧几里得算法(又称辗转相除法)用于计算两个数的最大公约数**(GCD:greatest common divisor)**，被称为世界上最古老的算法。</p><h3 id="使用欧几里得算法求1112和695的最大公约数">使用欧几里得算法求1112和695的最大公约数</h3><ol><li>首先用较小的数字去除较大的数字，求出余数。也就是对两个数字进行 mod 运算，除完后的余数为417。<ol><li>mod运算即取余运算，<em>A</em> mod <em>B</em> 就是算出<em>A</em>除以<em>B</em>后的余数<em>C</em>。</li></ol></li><li>接下来再用除数695和余数417进行mod运 算。结果为 278。</li><li>继续重复同样的操作，对 417 和 278 进行 mod 运算，结果为139。</li><li>对 278 和 139 进行 mod 运算，结果为 0。也就 是说，278 可以被 139 整除。</li><li>余数为 0 时，最后一次运算中的除数 139 就是 1112 和 695 的最大公约数。</li></ol><p><img src="https://gitee.com/zheshiyigegexingwangzhan/images/raw/master/null/image-20200921233013836.png" alt="image-20200921233013836"></p><h3 id="Java实现">Java实现</h3><p><a href="https://github.com/nijixucai/my-tools/blob/master/my-learn/my-algorithm/src/main/java/com/nicai/algorithm/other/EuclideanGreatestCommonDivisor.java" target="_blank" rel="noopener">欧几里得最大公约数算法</a></p><h2 id="素性测试">素性测试</h2><p>素性测试是判断一个自然数是否为素数的测试。素数(prime number)就是只能被 1 和其自身整除，且大于 1 的自然数。</p><p>素数从小到大有 2、3、5、7、11、13…目前在加密技术中被广泛应用的 RSA 算法就会用到大素数，因此“素性测试”在该算法中起到了重要的作用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章：数据结构&quot;&gt;第一章：数据结构&lt;/h1&gt;
&lt;h2 id=&quot;链表&quot;&gt;链表&lt;/h2&gt;
&lt;h3 id=&quot;特性&quot;&gt;特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;呈线性排列的数据结构，元素中有字段指向下一个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;内存&quot;&gt;内存&lt;/h3&gt;
&lt;ul</summary>
      
    
    
    
    
  </entry>
  
</feed>
